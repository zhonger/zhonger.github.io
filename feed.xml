<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://lisz.me/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lisz.me/" rel="alternate" type="text/html" /><updated>2025-06-16T18:28:49+09:00</updated><id>https://lisz.me/feed.xml</id><title type="html">仲儿的自留地</title><subtitle>个人的一个技术博客站点，主要用于记录个人在学习过程中遇到的技术问题及解决方法、技术实验，以及一些比较有趣的事情。</subtitle><author><name>zhonger</name></author><entry><title type="html">Kubernetes 应用之 JupyterHub 搭建和运维</title><link href="https://lisz.me/tech/k8s/k8s-jupyterhub.html" rel="alternate" type="text/html" title="Kubernetes 应用之 JupyterHub 搭建和运维" /><published>2025-06-16T13:42:00+09:00</published><updated>2025-06-16T13:42:00+09:00</updated><id>https://lisz.me/tech/k8s/k8s-jupyterhub</id><content type="html" xml:base="https://lisz.me/tech/k8s/k8s-jupyterhub.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  之前在<a href="/tech/docker/jupyterlab.html">《JupyterLab 的搭建与运维》</a>一文中，尝试了在单机上搭建部署 JupyterHub。不得不说，的确方便了团队内部共同使用同一台 GPU 服务器。但也有比较大的限制：</p>

<ul>
  <li><strong>运行中的实例对于 CPU、GPU、内存、硬盘等资源完全共享</strong>。当所有用户都申请的资源总和超出服务器所拥有的资源时，任务的运行效率将会大打折扣。甚至可能会容易出现內存溢出的问题，造成宿主机出现 BUG。</li>
  <li><strong>难以同时管理多台服务器</strong>。在有多台不同 CPU/GPU 服务器时，单机部署的方案会造成多个入口，且很难实现用户数据在多机间的实时同步。</li>
  <li><strong>资源回收和重置存在一定的难度</strong>。在单机部署方案中虽然也可以通过 JupyterHub 来限制闲置时间不超过多久，但是实例只会被关闭，而非销毁。如果用户实例出现了某些未知的配置问题，只能依靠管理员手动销毁实例来解决。</li>
</ul>

<p>  其实，JupyterHub 官方很早就意识到了这些，并通过拥抱 Kubernetes （以下简称“K8S”）来解决以上限制。可以说 K8S 天然是为 JupyterHub 多机资源管理调度而生，可以：</p>

<ul>
  <li>对运行实例的资源进行<strong>严格地限制</strong>，防止运行实例申请资源总和超出节点资源。</li>
  <li>根据集群实际运行情况来<strong>自动分布部署</strong>运行实例，在具有很大的节点池的情况下非常有效。</li>
  <li><strong>共享持久化存储</strong>，平稳迁移运行实例到任一节点，自由切换 CPU/GPU 节点。</li>
  <li><strong>自动销毁</strong>超过一定闲置时间的实例，并且在每次启动运行实例时都会拉取<strong>最新镜像</strong>。</li>
</ul>

<p><img src="https://i.lisz.top/blog/sDLThq.webp" alt="JupyterHub for K8S 架构图（来自 https://z2jh.jupyter.org/）" /></p>

<h2 id="搭建">搭建</h2>

<p>  这里我们以一个简单的 CPU/GPU 科学计算集群为例：</p>

<ul>
  <li><strong>登录节点 l0</strong>：提供服务入口（Web）</li>
  <li><strong>CPU/GPU 共用节点 l1、l2</strong>：运行实例部署池（可以根据实际情况和需求扩充或缩小）</li>
  <li><strong>存储节点 nas</strong>：提供持久化存储（独立存储方案优于登录节点 NFS 服务）</li>
</ul>

<h3 id="网络规划">网络规划</h3>

<p>  以下为集群节点对应的 IP 地址信息：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">节点主机名</th>
      <th style="text-align: center">IP 地址</th>
      <th style="text-align: center">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">l0</td>
      <td style="text-align: center">192.168.120.100</td>
      <td style="text-align: center">登录节点，K8S 控制节点</td>
    </tr>
    <tr>
      <td style="text-align: center">l1</td>
      <td style="text-align: center">192.168.120.101</td>
      <td style="text-align: center">CPU/GPU 节点，K8S 工作节点</td>
    </tr>
    <tr>
      <td style="text-align: center">l2</td>
      <td style="text-align: center">192.168.120.102</td>
      <td style="text-align: center">CPU/GPU 节点，K8S 工作节点</td>
    </tr>
    <tr>
      <td style="text-align: center">nas</td>
      <td style="text-align: center">192.168.120.99</td>
      <td style="text-align: center">存储节点，NFS 服务</td>
    </tr>
  </tbody>
</table>

<p>K8S 集群节点子网为 <code class="language-plaintext highlighter-rouge">192.168.120.0/24</code>。另外<strong>Pod 子网</strong>设置为 <code class="language-plaintext highlighter-rouge">192.168.144.0/20</code>、<strong>Service 子网</strong>设置为 <code class="language-plaintext highlighter-rouge">192.168.244.0/20</code>。</p>

<h3 id="k8s-集群搭建">K8S 集群搭建</h3>

<p>  集群搭建过程请见<a href="/tech/k8s/k8s-introduction.html">《Kubernetes 不完全入门》</a>一文，需配置好节点识别 NVIDIA 显卡和 NFS CSI 存储。</p>

<h3 id="helm-部署-jupyterhub">Helm 部署 JupyterHub</h3>

<h4 id="安装-helm">安装 Helm</h4>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> Helm 是什么？ </div> </div> <div class="content"> <p>  类似于操作系统的 APT 等包管理器，Helm 是 Kubernetes 的包管理器，一般定义了部署在 K8S 集群中的应用所需的所有配置文件。</p>



 </div> </div>
<p>  Helm 可以通过系统包管理工具安装或者直接下载二进制文件使用。Ubuntu 系统如下操作：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl https://baltocdn.com/helm/signing.asc | gpg <span class="nt">--dearmor</span> | <span class="nb">sudo tee</span> /usr/share/keyrings/helm.gpg <span class="o">&gt;</span> /dev/null
<span class="nb">sudo </span>apt-get <span class="nb">install </span>apt-transport-https <span class="nt">--yes</span>
<span class="nb">echo</span> <span class="s2">"deb [arch=</span><span class="si">$(</span>dpkg <span class="nt">--print-architecture</span><span class="si">)</span><span class="s2"> signed-by=/usr/share/keyrings/helm.gpg] https://baltocdn.com/helm/stable/debian/ all main"</span> | <span class="nb">sudo tee</span> /etc/apt/sources.list.d/helm-stable-debian.list
<span class="nb">sudo </span>apt-get update
<span class="nb">sudo </span>apt-get <span class="nb">install </span>helm <span class="nt">-y</span>
</code></pre></div></div>

<p>二进制文件请自行前往 <a href="https://github.com/helm/helm/releases">https://github.com/helm/helm/releases</a> 下载。</p>

<h4 id="添加-chart">添加 Chart</h4>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> Chart 是什么？ </div> </div> <div class="content"> <p>  Chart 是 Helm 使用的包格式，可以被认为是“软件源中的软件名”（实际是多种软件的集合）。这主要是因为如果要编写部署一整套应用所需的配置文件实在太复杂、耗时了，使用 Chart 只需要写一个<strong>自定义配置文件</strong>来覆盖想要修改的默认配置即可。</p>



 </div> </div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>helm repo add jupyterhub https://hub.jupyter.org/helm-chart/
helm repo update
</code></pre></div></div>

<h4 id="准备自定义配置文件">准备自定义配置文件</h4>

<p>  自定义配置文件可以是任意文件名，但必须是 <code class="language-plaintext highlighter-rouge">yaml</code> 格式，比如 <code class="language-plaintext highlighter-rouge">config.yaml</code>。对于以下配置我们可能需要进行自定义：</p>

<ul>
  <li><strong>对外代理服务</strong>：一般来说，JupyterHub 只有 Web 访问端口需要由 K8S 集群在控制节点暴露给反向代理服务（比如 Nginx）。这里的 <code class="language-plaintext highlighter-rouge">proxy.service.nodePorts.http</code> 配置为 <code class="language-plaintext highlighter-rouge">34567</code> 端口。另外，我们可以将 <code class="language-plaintext highlighter-rouge">proxy.chp.networkPolicy.enabled</code> 置为 <code class="language-plaintext highlighter-rouge">false</code> 来取消 K8S 网络限制。为了安全,在 <code class="language-plaintext highlighter-rouge">1.0.0</code> 版本之前也许手动设置 <code class="language-plaintext highlighter-rouge">proxy.secretToken</code> 字段(使用 <code class="language-plaintext highlighter-rouge">openssl rand -hex 32</code> 命令生成)。</li>
  <li><strong>hub 配置</strong>：(1)设置 <code class="language-plaintext highlighter-rouge">hub.networkPolicy.enabled</code> 为 <code class="language-plaintext highlighter-rouge">false</code> 取消网络限制；(2)(可选)使用 <code class="language-plaintext highlighter-rouge">hub.extraVolumes</code> 字段来添加指定的持久化卷名；(3)(可选，推荐)配置 <code class="language-plaintext highlighter-rouge">hub.config</code> 来启用 Oauth2 认证登录，目前官方支持 Github、Gitlab 在内的多款认证方式，详细请见 <a href="https://jupyterhub.readthedocs.io/en/stable/reference/authenticators.html">The OAuthenticator</a>。这里我们使用自建 Gitlab 来测试。</li>
  <li><strong>全局配置</strong>：(1)(可选)可以修改 <code class="language-plaintext highlighter-rouge">prePuller.hook.enabled</code> 为 <code class="language-plaintext highlighter-rouge">false</code> 来禁用节点预拉取运行实例镜像。启用的情况下，当有新节点加入可用集群时可以自动拉取，以避免第一次在新节点部署实例时用户需要等待一段时间。(2)(可选)限制实例最长可运行时间 <code class="language-plaintext highlighter-rouge">cull.maxAge</code>和最长闲置时间<code class="language-plaintext highlighter-rouge">cull.timeout</code>，通过自动销毁来提升集群的可用率。<code class="language-plaintext highlighter-rouge">cull.enabled</code>字段也需要置为 <code class="language-plaintext highlighter-rouge">true</code> 从而生效。<code class="language-plaintext highlighter-rouge">cull.every</code> 字段可以设置每分钟检查是否超出限制。</li>
  <li><strong>用户实例配置</strong>：(1)<strong>NFS 持久化</strong>，通过设置 <code class="language-plaintext highlighter-rouge">singleuser.extraPodConfig.securityContext</code> 中的 <code class="language-plaintext highlighter-rouge">fsGroup</code> (值为 <code class="language-plaintext highlighter-rouge">100</code>) 和 <code class="language-plaintext highlighter-rouge">fsGroupChangePolicy</code> (值为 <code class="language-plaintext highlighter-rouge">OnRootMismatch</code>) 来实现启动实例<strong>跳过每次修改文件夹权限</strong>，仅当文件夹父目录不为 <code class="language-plaintext highlighter-rouge">root</code> 用户 (id 为 <code class="language-plaintext highlighter-rouge">100</code>) 拥有时才会修改文件夹权限。(2)<strong>基本配置</strong>，包括网络策略、环境变量、启动超时最长限制（即最长等待启动时间）。(3)<strong>动态存储卷配置</strong>，设置 <code class="language-plaintext highlighter-rouge">singleuser.storage.dynamic.storageClass</code> 为 <code class="language-plaintext highlighter-rouge">nfs-csi</code> 来启用自动动态存储卷，可以用 <code class="language-plaintext highlighter-rouge">singleuser.storage.capacity</code> 来设置默认卷大小限制。由于实例中默认的缓冲区较小，在內存有限的情况下某些任务可能用缓冲区，因此可以挂载较大的本地临时卷来充当 <code class="language-plaintext highlighter-rouge">/dev/shm</code> 和 <code class="language-plaintext highlighter-rouge">/dev/fuse</code>。(4)<strong>可用资源配置方案</strong>，相比单机部署的单一选择，K8S 部署方案可以提供多样化的资源配置方案，不仅包括 CPU、内存资源的集合，还有 GPU 资源。甚至于还可以通过 K8S 的节点标签来由用户手动选择哪个节点（当然仅在资源满足的情况下会成功创建）。</li>
</ul>

<p>以下为一个样例：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">proxy</span><span class="pi">:</span>
  <span class="na">chp</span><span class="pi">:</span>
    <span class="na">networkPolicy</span><span class="pi">:</span>
      <span class="na">enabled</span><span class="pi">:</span> <span class="kc">false</span>
  <span class="na">service</span><span class="pi">:</span>
    <span class="na">nodePorts</span><span class="pi">:</span>
      <span class="na">http</span><span class="pi">:</span> <span class="m">34567</span>
  <span class="na">secretToken</span><span class="pi">:</span> <span class="s2">"</span><span class="s">&lt;GENERATE</span><span class="nv"> </span><span class="s">SECRET</span><span class="nv"> </span><span class="s">TOKEN</span><span class="nv"> </span><span class="s">BY</span><span class="nv"> </span><span class="s">YOURSELF&gt;"</span>

<span class="na">hub</span><span class="pi">:</span>
  <span class="na">networkPolicy</span><span class="pi">:</span>
    <span class="na">enabled</span><span class="pi">:</span> <span class="kc">false</span>
  <span class="na">extraVolumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">hub-db-dir</span>
      <span class="na">persistentVolumeClaim</span><span class="pi">:</span>
        <span class="na">claimName</span><span class="pi">:</span> <span class="s">hub-db-dir</span>
  <span class="na">config</span><span class="pi">:</span>
    <span class="na">JupyterHub</span><span class="pi">:</span>
      <span class="na">authenticator_class</span><span class="pi">:</span> <span class="s">oauthenticator.gitlab.GitLabOAuthenticator</span>
    <span class="na">GitLabOAuthenticator</span><span class="pi">:</span>
      <span class="na">client_id</span><span class="pi">:</span> <span class="s2">"</span><span class="s">&lt;COPY</span><span class="nv"> </span><span class="s">IT</span><span class="nv"> </span><span class="s">FROM</span><span class="nv"> </span><span class="s">YOUR</span><span class="nv"> </span><span class="s">OAUTH2</span><span class="nv"> </span><span class="s">SERVER&gt;"</span>
      <span class="na">client_secret</span><span class="pi">:</span> <span class="s2">"</span><span class="s">&lt;COPY</span><span class="nv"> </span><span class="s">IT</span><span class="nv"> </span><span class="s">FROM</span><span class="nv"> </span><span class="s">YOUR</span><span class="nv"> </span><span class="s">OAUTH2</span><span class="nv"> </span><span class="s">SERVER&gt;"</span>
      <span class="na">oauth_callback_url</span><span class="pi">:</span> <span class="s2">"</span><span class="s">https://jupyter.lisz.me/hub/oauth_callback"</span>
      <span class="na">gitlab_url</span><span class="pi">:</span> <span class="s2">"</span><span class="s">https://git.lisz.me"</span>
      <span class="na">login_service</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Gitlab"</span>
      <span class="na">scope</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s">read_user</span>
        <span class="pi">-</span> <span class="s">read_api</span>
        <span class="pi">-</span> <span class="s">api</span>
        <span class="pi">-</span> <span class="s">openid</span>
        <span class="pi">-</span> <span class="s">profile</span>
        <span class="pi">-</span> <span class="s">email</span>
      <span class="na">admin_users</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s">&lt;adminer_username&gt;</span>
      <span class="na">allowed_gitlab_groups</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s">&lt;group_name&gt;</span>

<span class="na">prePuller</span><span class="pi">:</span>
  <span class="na">hook</span><span class="pi">:</span>
    <span class="na">enabled</span><span class="pi">:</span> <span class="kc">false</span>

<span class="na">cull</span><span class="pi">:</span>
  <span class="na">enabled</span><span class="pi">:</span> <span class="kc">true</span>
  <span class="na">maxAge</span><span class="pi">:</span> <span class="m">172800</span>
  <span class="na">timeout</span><span class="pi">:</span> <span class="m">600</span>
  <span class="na">every</span><span class="pi">:</span> <span class="m">60</span>

<span class="na">singleuser</span><span class="pi">:</span>
   <span class="na">extraPodConfig</span><span class="pi">:</span>
    <span class="na">securityContext</span><span class="pi">:</span>
      <span class="na">fsGroup</span><span class="pi">:</span> <span class="m">100</span>
      <span class="na">fsGroupChangePolicy</span><span class="pi">:</span> <span class="s2">"</span><span class="s">OnRootMismatch"</span>
<span class="err">  </span><span class="na">networkPolicy</span><span class="pi">:</span>
    <span class="na">enabled</span><span class="pi">:</span> <span class="kc">false</span>
  <span class="na">extraEnv</span><span class="pi">:</span>
    <span class="na">EDITOR</span><span class="pi">:</span> <span class="s2">"</span><span class="s">vim"</span>
    <span class="na">SHELL</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/bin/zsh"</span>
    <span class="na">PYTHONUNBUFFERED</span><span class="pi">:</span> <span class="s2">"</span><span class="s">1"</span>
  <span class="na">startTimeout</span><span class="pi">:</span> <span class="m">300</span>
  <span class="na">storage</span><span class="pi">:</span>
    <span class="na">capacity</span><span class="pi">:</span> <span class="s">100Gi</span>
    <span class="na">dynamic</span><span class="pi">:</span>
      <span class="na">storageClass</span><span class="pi">:</span> <span class="s">nfs-csi</span>
    <span class="na">extraVolumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">shm-volume</span>
        <span class="na">emptyDir</span><span class="pi">:</span>
          <span class="na">medium</span><span class="pi">:</span> <span class="s">Memory</span>
          <span class="na">sizeLimit</span><span class="pi">:</span> <span class="s2">"</span><span class="s">20Gi"</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">fuse-device</span>
        <span class="na">hostPath</span><span class="pi">:</span>
          <span class="na">path</span><span class="pi">:</span> <span class="s">/dev/fuse</span>
          <span class="na">type</span><span class="pi">:</span> <span class="s">CharDevice</span>
    <span class="na">extraVolumeMounts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">shm-volume</span>
        <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/dev/shm</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">fuse-device</span>
        <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/dev/fuse</span>
  <span class="na">image</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">quay.io/zhonger/base-notebook</span>
    <span class="na">tag</span><span class="pi">:</span> <span class="s">v3</span>
    <span class="na">pullPolicy</span><span class="pi">:</span> <span class="s">Always</span>
  <span class="na">profileList</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">display_name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">CPU</span><span class="nv"> </span><span class="s">分区"</span>
      <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">包含</span><span class="nv"> </span><span class="s">Conda、Python</span><span class="nv"> </span><span class="s">环境（8核16G）'</span>
      <span class="na">default</span><span class="pi">:</span> <span class="kc">true</span>
      <span class="na">kubespawner_override</span><span class="pi">:</span>
        <span class="na">cpu_gurantee</span><span class="pi">:</span> <span class="m">1</span>
        <span class="na">memo_gurantee</span><span class="pi">:</span> <span class="s2">"</span><span class="s">1G"</span>
        <span class="na">cpu_limit</span><span class="pi">:</span> <span class="m">8</span>
        <span class="na">mem_limit</span><span class="pi">:</span> <span class="s2">"</span><span class="s">16G"</span>
      <span class="na">profile_options</span><span class="pi">:</span>
        <span class="na">image</span><span class="pi">:</span>
          <span class="na">display_name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">主机"</span>
          <span class="na">choices</span><span class="pi">:</span>
            <span class="na">lab6</span><span class="pi">:</span>
              <span class="na">display_name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">l1"</span>
              <span class="na">kubespawner_override</span><span class="pi">:</span>
                <span class="na">node_selector</span><span class="pi">:</span> <span class="pi">{</span><span class="s1">'</span><span class="s">kubernetes.io/hostname'</span><span class="pi">:</span> <span class="s1">'</span><span class="s">l1'</span><span class="pi">}</span>
            <span class="na">lab9</span><span class="pi">:</span>
              <span class="na">display_name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">l2"</span>
              <span class="na">kubespawner_override</span><span class="pi">:</span>
                <span class="na">node_selector</span><span class="pi">:</span> <span class="pi">{</span><span class="s1">'</span><span class="s">kubernetes.io/hostname'</span><span class="pi">:</span> <span class="s1">'</span><span class="s">l2'</span><span class="pi">}</span>
    <span class="pi">-</span> <span class="na">display_name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">GPU</span><span class="nv"> </span><span class="s">分区"</span>
      <span class="na">description</span><span class="pi">:</span> <span class="s2">"</span><span class="s">包含</span><span class="nv"> </span><span class="s">Conda、Python、CUDA</span><span class="nv"> </span><span class="s">环境（8核16G）"</span>
      <span class="na">kubespawner_override</span><span class="pi">:</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">quay.io/zhonger/gpu-notebook:v3</span>
        <span class="na">image_pull_policy</span><span class="pi">:</span> <span class="s">Always</span>
        <span class="na">cpu_gurantee</span><span class="pi">:</span> <span class="m">1</span>
        <span class="na">mem_gurantee</span><span class="pi">:</span> <span class="s2">"</span><span class="s">1G"</span>
        <span class="na">cpu_limit</span><span class="pi">:</span> <span class="m">8</span>
        <span class="na">mem_limit</span><span class="pi">:</span> <span class="s2">"</span><span class="s">16G"</span>
      <span class="na">profile_options</span><span class="pi">:</span>
        <span class="na">image</span><span class="pi">:</span>
          <span class="na">display_name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">资源配置"</span>
          <span class="na">choices</span><span class="pi">:</span>
            <span class="na">A100x1</span><span class="pi">:</span>
              <span class="na">display_name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">A100</span><span class="nv"> </span><span class="s">(Python</span><span class="nv"> </span><span class="s">3.11,</span><span class="nv"> </span><span class="s">CUDA</span><span class="nv"> </span><span class="s">12)</span><span class="nv"> </span><span class="s">GPU</span><span class="nv"> </span><span class="s">x1"</span>
              <span class="na">kubespawner_override</span><span class="pi">:</span>
                <span class="na">node_selector</span><span class="pi">:</span> <span class="pi">{</span><span class="s1">'</span><span class="s">gputype'</span><span class="pi">:</span> <span class="s1">'</span><span class="s">A100'</span><span class="pi">}</span>
                <span class="na">extra_resource_limits</span><span class="pi">:</span>
                  <span class="na">nvidia.com/gpu</span><span class="pi">:</span> <span class="s2">"</span><span class="s">1"</span>
            <span class="na">P100x1</span><span class="pi">:</span>
              <span class="na">display_name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">P100</span><span class="nv"> </span><span class="s">(Python</span><span class="nv"> </span><span class="s">3.11,</span><span class="nv"> </span><span class="s">CUDA</span><span class="nv"> </span><span class="s">12)</span><span class="nv"> </span><span class="s">GPU</span><span class="nv"> </span><span class="s">x1"</span>
              <span class="na">kubespawner_override</span><span class="pi">:</span>
                <span class="na">node_selector</span><span class="pi">:</span> <span class="pi">{</span><span class="s1">'</span><span class="s">gputype'</span><span class="pi">:</span> <span class="s1">'</span><span class="s">P100'</span><span class="pi">}</span>
                <span class="na">extra_resource_limits</span><span class="pi">:</span>
                  <span class="na">nvidia.com/gpu</span><span class="pi">:</span> <span class="s2">"</span><span class="s">1"</span>
</code></pre></div></div>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  如果用标签来选择节点的话，需要通过类似 <code class="language-plaintext highlighter-rouge">kubectl label node l1 gputype=A100</code> 命令预先配置好标签。</p>



 </div> </div>
<h4 id="启动-jupyterhub">启动 JupyterHub</h4>

<p>  准备好以上配置文件后，可以使用以下命令启动。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>helm upgrade <span class="nt">--cleanup-on-fail</span> <span class="se">\</span>
  <span class="nt">--install</span> &lt;helm-release-name&gt; jupyterhub/jupyterhub <span class="se">\</span>
  <span class="nt">--namespace</span> &lt;k8s-namespace&gt; <span class="se">\</span>
  <span class="nt">--create-namespace</span> <span class="se">\</span>
  <span class="nt">--version</span><span class="o">=</span>&lt;chart-version&gt; <span class="se">\</span>
  <span class="nt">--values</span> config.yaml
</code></pre></div></div>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  建议先下载好 JupyterHub 所需的镜像，可以通过 <code class="language-plaintext highlighter-rouge">helm show values jupyterhub</code> 来查看所有的镜像列表。或者可以用 <code class="language-plaintext highlighter-rouge">helm pull jupyterhub/jupyterhub --version 4.2.0</code> 来下载原始 Chart 文件，解压后查看 <code class="language-plaintext highlighter-rouge">values.yaml</code> 文件即可。如果想要使用国内镜像的话，就修改 <code class="language-plaintext highlighter-rouge">values.yaml</code> 文件里的镜像名再启动 JupyterHub。这里可以用本地的文件夹名称或压缩包名称来替代 <code class="language-plaintext highlighter-rouge">jupyterhub/jupyterhub</code> 。</p>



 </div> </div>
<h4 id="配置-nginx">配置 Nginx</h4>

<p>  当 JupyterHub 启动后，默认用户还是无法从本地访问服务器上部署的 JupyterHub 的，还需要使用 Nginx 代理一下。以下是 Nginx 虚拟主机配置样例。这样一来，就可以在用户端通过域名来直接访问部署好的 JupyterHub 了。</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">server</span> {
    <span class="n">listen</span> <span class="m">443</span> <span class="n">ssl</span>;
    <span class="n">server_name</span> <span class="n">jupyter</span>.<span class="n">lisz</span>.<span class="n">me</span>;

    <span class="n">ssl_certificate</span> /<span class="n">home</span>/<span class="n">ubuntu</span>/<span class="n">ssl</span>/<span class="n">jupyter</span>.<span class="n">lisz</span>.<span class="n">me</span>.<span class="n">cert</span>.<span class="n">pem</span>;
    <span class="n">ssl_certificate_key</span> /<span class="n">home</span>/<span class="n">ubuntu</span>/<span class="n">ssl</span>/<span class="n">jupyter</span>.<span class="n">lisz</span>.<span class="n">me</span>.<span class="n">key</span>.<span class="n">pem</span>;

    <span class="c"># SSL settings (optional but recommended)
</span>    <span class="n">ssl_protocols</span> <span class="n">TLSv1</span>.<span class="m">2</span> <span class="n">TLSv1</span>.<span class="m">3</span>;
    <span class="n">ssl_ciphers</span> <span class="n">HIGH</span>:!<span class="n">aNULL</span>:!<span class="n">MD5</span>;

    <span class="n">client_max_body_size</span> <span class="m">10</span><span class="n">G</span>;

    <span class="c"># Logging
</span>    <span class="n">access_log</span> /<span class="n">var</span>/<span class="n">log</span>/<span class="n">nginx</span>/<span class="n">jupyter_access</span>.<span class="n">log</span>;
    <span class="n">error_log</span> /<span class="n">var</span>/<span class="n">log</span>/<span class="n">nginx</span>/<span class="n">jupyter_error</span>.<span class="n">log</span>;

    <span class="n">location</span> / {
        <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">localhost</span>:<span class="m">30000</span>;
        <span class="n">proxy_set_header</span> <span class="n">Host</span> $<span class="n">host</span>;
        <span class="n">proxy_set_header</span> <span class="n">X</span>-<span class="n">Real</span>-<span class="n">IP</span> $<span class="n">remote_addr</span>;
        <span class="n">proxy_set_header</span> <span class="n">X</span>-<span class="n">Forwarded</span>-<span class="n">For</span> $<span class="n">proxy_add_x_forwarded_for</span>;
        <span class="n">proxy_set_header</span> <span class="n">X</span>-<span class="n">Forwarded</span>-<span class="n">Proto</span> $<span class="n">scheme</span>;

        <span class="c"># WebSocket support
</span>        <span class="n">proxy_http_version</span> <span class="m">1</span>.<span class="m">1</span>;
        <span class="n">proxy_set_header</span> <span class="n">Upgrade</span> $<span class="n">http_upgrade</span>;
        <span class="n">proxy_set_header</span> <span class="n">Connection</span> <span class="s2">"upgrade"</span>;
    }
}

<span class="c"># Redirect HTTP to HTTPS
</span><span class="n">server</span> {
    <span class="n">listen</span> <span class="m">80</span>;
    <span class="n">server_name</span> <span class="n">jupyter</span>.<span class="n">lisz</span>.<span class="n">me</span>;

    <span class="n">return</span> <span class="m">301</span> <span class="n">https</span>://$<span class="n">host</span>$<span class="n">request_uri</span>;
}
</code></pre></div></div>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  JupyterHub 的 proxy 本身也可以提供对外访问的 HTTPS，详见 <a href="https://z2jh.jupyter.org/en/stable/administrator/security.html#https">JupyterHub for Kubernetes – Administrator Guide/Security/HTTPS</a>。其他反向代理软件也都适用。</p>



 </div> </div>
<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 如果 Nginx 不在控制节点能反向代理 JupyterHub 吗？ </div> </div> <div class="content"> <p>  由于 <code class="language-plaintext highlighter-rouge">proxy</code> 配置使用了 <code class="language-plaintext highlighter-rouge">nodePorts</code> 来创建端口映射，默认是可以在其他节点访问到指定的端口的。如果想要仅允许 Nginx 代理所在主机访问，可以通过 ingress 来支持更精细的访问控制，详见 <a href="https://z2jh.jupyter.org/en/stable/resources/reference.html#ingress">JupyterHub for Kubernetes – Resources/ingress</a>。</p>



 </div> </div>
<h2 id="运维">运维</h2>

<h3 id="基本管理">基本管理</h3>

<p>  部署完成后，我们需要通过 K8S 的 <code class="language-plaintext highlighter-rouge">kubectl</code> 命令来查看、管理 JupyterHub 应用。以下为一些常见的命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">## 假设为 JupyterHub 创建的 namespace 为 jhub</span>

<span class="c"># 查看 JupyterHub 所有 Pod 状态</span>
╰─<span class="nv">$ </span>kubectl get pod <span class="nt">-n</span> jhub
NAME                             READY   STATUS    RESTARTS        AGE
continuous-image-puller-76bkq    1/1     Running   0               5d1h
continuous-image-puller-hntww    1/1     Running   0               5d1h
hub-6867b9b6c7-slg9c             1/1     Running   0               5d1h
proxy-cc45cd6f6-g2t24            1/1     Running   0               5d1h
user-scheduler-7b465896b-bq4l6   1/1     Running   0               5d1h
user-scheduler-7b465896b-rvqgx   1/1     Running   0               5d1h

<span class="c"># 查看节点资源使用情况</span>
╰─<span class="nv">$ </span>kubectl describe node l1

<span class="c"># 查看用户实例状态或启动问题</span>
╰─<span class="nv">$ </span>kubectl descirbe <span class="nt">-n</span> jhub pod jupyter-zhonger

<span class="c"># 查看用户动态存储卷情况</span>
╰─<span class="nv">$ </span>kubectl get <span class="nt">-n</span> jhub pvc
</code></pre></div></div>

<h3 id="备份和恢复存储卷">备份和恢复存储卷</h3>

<p>  由于使用动态存储卷，卷配置显得尤为重要。（毕竟 NFS 存储在远端，独立于 K8S 集群。）可以通过以下命令备份和恢复存储卷。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 备份所有 PV 和 PVC</span>
kubectl get pv <span class="nt">-o</span> yaml <span class="o">&gt;</span> all_pvs.yaml
kubectl get pvc <span class="nt">--all-namespaces</span> <span class="nt">-o</span> yaml <span class="o">&gt;</span> all_pvc_by_namespace.yaml

<span class="c"># 从备份文件中恢复所有 PV 和 PVC</span>
kubectl apply <span class="nt">-f</span> all_pvs.yaml
kubectl apply <span class="nt">-f</span> all_pvc_by_namespace.yaml
</code></pre></div></div>

<h3 id="更改存储卷大小">更改存储卷大小</h3>

<p>  从查阅的资料来看，NFS 存储是无法动态更新存储卷大小的。换句话说，<strong>重新定义存储卷</strong>就可以手动更改存储大小。举个例子，现在想要为用户 zhonger 从默认的存储卷大小 100G 更改到 1T。那么我们先要获得用户 zhonger 的存储卷配置文件 pvc 和 pv。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 保存 PVC 配置到 YAML 文件</span>
kubectl get pvc claim-zhonger <span class="nt">-n</span> jhub <span class="nt">-o</span> yaml <span class="o">&gt;</span> claim-zhonger-pvc.yaml

<span class="c"># 从 claim-zhonger-pvc.yaml 获知 PV_NAME</span>
kubectl get pv &lt;PV_NAM&gt; <span class="nt">-o</span> yaml <span class="o">&gt;</span> claim-zhonger-pv.yaml

<span class="c"># 确保实例已经被销毁后，删除 PVC 和 PV</span>
kubectl delete <span class="nt">-f</span> claim-zhonger-pvc.yaml
kubectl delete <span class="nt">-f</span> claim-zhonger-pv.yaml

<span class="c"># 修改存储卷大小</span>
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s/100Gi/1Ti/"</span> claim-zhonger-<span class="k">*</span>.yaml

<span class="c"># 重新定义存储卷</span>
kubectl apply <span class="nt">-f</span> claim-zhonger-pv.yaml
kubectl apply <span class="nt">-f</span> claim-zhonger-pvc.yaml
</code></pre></div></div>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 注意 </div> </div> <div class="content"> <p>  这里需要注意的是，<strong>PV 和 PVC 之间的依赖关系</strong>。PV 是先定义的，不属于任何命名空间。PVC 是依托于 PV 定义的，必须属于某个命名空间。所以删除的时候要先 PVC 再 PV，定义的时候要先 PV 再 PVC。</p>



 </div> </div>
<h3 id="资源配置方案">资源配置方案</h3>

<p>  对于资源配置方案，我们可以根据<strong>镜像</strong>、<strong>CPU 核数</strong>、<strong>内存大小</strong>、<strong>GPU 块数</strong>的不同来创建出多样化方案。可以参考 Amazon 提供的丰富示例 <a href="https://github.com/awslabs/data-on-eks/blob/main/ai-ml/jupyterhub/helm/jupyterhub/jupyterhub-values-dummy.yaml">jupyterhub-values-dummy.yaml</a> 了解更多。</p>

<h3 id="利用情况监控与统计">利用情况监控与统计</h3>

<p>  目前可以使用 Grafana + Prometheus 的方式来对 K8S 集群中所有的资源利用情况进行监控，也可以自行设计一个 Grafana 面板来展示当前 JupyterHub 应用中启动的用户实例情况。但对于更加进一步详细、细致的监控与统计还有待设计（类似于“单个用户的利用报告”、“全平台的利用报告”等）。</p>

<h2 id="总结">总结</h2>

<p>  JupyterHub 在 K8S 平台上散发出越来越强大的魅力，使得研究团队搭建自己的科学计算平台越来越容易。当然目前依然还是有一些挑战，比如“多节点 GPU 的调用”。类似于“机器学习模型训练任务”通常需要调试后再放在大规模的 GPU 集群上训练，而 JupyterHub 长于调试代码，是否可以调试完成后直接提交给更大规模的 GPU 集群后台计算呢？</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://z2jh.jupyter.org/en/stable/jupyterhub/installation.html">JupyterHub for Kubernetes – Installation</a></li>
  <li><a href="https://github.com/jupyterhub/kubespawner/issues/478">Let pod’s securityContext fsGroupChangePolicy default to OnRootMismatch?</a></li>
  <li><a href="https://aws.amazon.com/cn/blogs/containers/building-multi-tenant-jupyterhub-platforms-on-amazon-eks/">Building multi-tenant JupyterHub Platforms on Amazon EKS</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="k8s" /><category term="Kubernetes" /><category term="K8S" /><category term="Helm" /><category term="JupyterHub" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">《手解量子化学》练习题 1-2</title><link href="https://lisz.me/ac/qc/solve-quantum-chemistry-by-hand-1-2.html" rel="alternate" type="text/html" title="《手解量子化学》练习题 1-2" /><published>2025-05-19T16:16:00+09:00</published><updated>2025-05-19T16:16:00+09:00</updated><id>https://lisz.me/ac/qc/solve-quantum-chemistry-by-hand-1-2</id><content type="html" xml:base="https://lisz.me/ac/qc/solve-quantum-chemistry-by-hand-1-2.html"><![CDATA[<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 练习题1-2 </div> </div> <div class="content"> <p>判断下列算子是否<strong>可交换</strong>？</p>

\[[1]\ [\hat{x},\hat{p}_x] \quad [2]\ [\hat{l}_x, \hat{l_y}] \quad [3]\ [\hat{\boldsymbol{l}}^2, \hat{l}_z]\]



 </div> </div>
<p>解决本题首先要了解<strong>可交换</strong>的定义，对于任意两个算子有：</p>

\[\hat{f}\hat{g}\psi(\boldsymbol{r})=\hat{g}\hat{f}\psi(\boldsymbol{r})\ 或\ (\hat{f}\hat{g}-\hat{g}\hat{f})\psi(\boldsymbol{r})=0\]

<p>那么这两个算子<strong>可交换</strong>，否则<strong>不可交换</strong>。其中下列式子称为交换子：</p>

\[[\hat{f}, \hat{g}] \equiv \hat{f}\hat{g}-\hat{g}\hat{f}\]

<p>除此之外，还需要了解以下观测量在古典力学中的变量和量子力学中的算子对应：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">观测量</th>
      <th style="text-align: center">变量</th>
      <th style="text-align: center">算子</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">位置</td>
      <td style="text-align: center">\(x\ (\boldsymbol{r})\)</td>
      <td style="text-align: center">\(\hat{x}\ (\hat{\boldsymbol{x}})\)</td>
    </tr>
    <tr>
      <td style="text-align: left">动量</td>
      <td style="text-align: center">\(p_x\ (\boldsymbol{p})\)</td>
      <td style="text-align: center">\(\hat{p}_x=-\mathrm{i}\hbar{d \over dx}\ (\hat{\boldsymbol{p}})\)</td>
    </tr>
    <tr>
      <td style="text-align: left">角动量</td>
      <td style="text-align: center">\(\boldsymbol{l}^2=l_x^2+l_y^2+l_z^2\)</td>
      <td style="text-align: center">\(\hat{\boldsymbol{l}}^2=\hat{l}_x^2+\hat{l}_y^2+\hat{l}_z^2\)</td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">\(\hat{l}_x=-\mathrm{i}\hbar\left(y\frac{\partial}{\partial z}-z\frac{\partial}{\partial y}\right)\)</td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">\(\hat{l}_y=-\mathrm{i}\hbar\left(z\frac{\partial}{\partial x}-x\frac{\partial}{\partial z}\right)\)</td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">\(\hat{l}_z=-\mathrm{i}\hbar\left(x\frac{\partial}{\partial y}-y\frac{\partial}{\partial x}\right)\)</td>
    </tr>
  </tbody>
</table>

<h2 id="算子组一">算子组一</h2>

<p>将 \(\hat{p}_x=-\mathrm{i}\hbar{d \over dx}\) 代入可得</p>

\[\begin{align}
[\hat{x}, \hat{p}_x]\psi(x)&amp;=(\hat{x}\hat{p}_x-\hat{p}_x\hat{x})\psi(x) \\\\
&amp;= -\mathrm{i}\hbar x \frac{d}{dx}\psi(x)-(-\mathrm{i}\hbar)\frac{d}{dx}[x\psi(x)]
\end{align}\]

<p>这里需要注意算子 \(\frac{d}{dx}\) 是求导算子，根据链式法则应该对 \([x\psi(x)]\) 分别对 \(x\) 求导，于是：</p>

\[\begin{align}
原式&amp;=-\mathrm{i}\hbar x \frac{d}{dx}\psi(x) + \mathrm{i}\hbar\left[x\frac{d}{dx}\psi(x)+\psi(x)\right] \\\\
&amp;= \mathrm{i}\hbar\psi(x) ≠ 0
\end{align}\]

<p>因此，这两个算子<strong>不可交换</strong>。</p>

<h2 id="算子组二">算子组二</h2>

<p>将 \(\hat{l}_x\) 和 \(\hat{l}_y\) 代入可得 (注意 \(\mathrm{(-i)}^2=-1\))</p>

\[\begin{align}
\hat{l}_x\hat{l}_y&amp;=(-\mathrm{i}\hbar)^2\left(y\frac{\partial}{\partial z}-z\frac{\partial}{\partial y}\right)\left(z\frac{\partial}{\partial x}-x\frac{\partial}{\partial z}\right) \\\\
&amp;=-\hbar^2\left(y\frac{\partial}{\partial z}z\frac{\partial}{\partial x}-z\frac{\partial}{\partial y}z\frac{\partial}{\partial x}-y\frac{\partial}{\partial z}x\frac{\partial}{\partial z}+z\frac{\partial}{\partial y}x\frac{\partial}{\partial z}\right)
\end{align}\]

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 求偏导中的注意点 </div> </div> <div class="content"> <p>  这里需要注意“求偏导的函数中是否包含了偏导的对象”，如果不包含则可以直接将变量左移，如果包含则需要根据链式法则分别求导。</p>



 </div> </div>
<p>接着有</p>

\[\begin{align}
\hat{l}_x\hat{l}_y&amp;=-\hbar^2\left[y\left(z\frac{\partial^2}{\partial z \partial x}+\frac{\partial}{\partial x}\right)-z^2\frac{\partial^2}{\partial y \partial x}-xy\frac{\partial^2}{\partial z^2}+xz\frac{\partial^2}{\partial y \partial z}\right] \\\\
&amp;=-\hbar^2\left[yz\frac{\partial^2}{\partial z \partial x}+y\frac{\partial}{\partial x}-z^2\frac{\partial^2}{\partial y \partial x}-xy\frac{\partial^2}{\partial z^2}+xz\frac{\partial^2}{\partial y \partial z}\right]
\end{align}\]

<p>同理</p>

\[\begin{align}
\hat{l}_y\hat{l}_x&amp;=(-\mathrm{i}\hbar)^2\left(z\frac{\partial}{\partial x}-x\frac{\partial}{\partial z}\right)\left(y\frac{\partial}{\partial z}-z\frac{\partial}{\partial y}\right) \\\\
&amp;=-\hbar^2\left(z\frac{\partial}{\partial x}y\frac{\partial}{\partial z}-x\frac{\partial}{\partial z}y\frac{\partial}{\partial z}-z\frac{\partial}{\partial x}z\frac{\partial}{\partial y}+x\frac{\partial}{\partial z}z\frac{\partial}{\partial y}\right) \\\\
&amp;=-\hbar^2\left[yz\frac{\partial^2}{\partial x \partial z}-xy\frac{\partial^2}{\partial z^2}-z^2\frac{\partial^2}{\partial x \partial y}+x\left(\frac{\partial}{\partial y}+z\frac{\partial^2}{\partial z \partial y}\right)\right] \\\\
&amp;=-\hbar^2\left(yz\frac{\partial^2}{\partial x \partial z}-xy\frac{\partial^2}{\partial z^2}-z^2\frac{\partial^2}{\partial x \partial y}+x\frac{\partial}{\partial y}+xz\frac{\partial^2}{\partial z \partial y}\right)
\end{align}\]

<p>因此交换子为（减法抵消相同项）</p>

\[\begin{align}
[\hat{l}_x, \hat{l}_y]&amp;=\hat{l}_x\hat{l}_y-\hat{l}_y\hat{l}_x \\\\
&amp;=-\hbar^2\left(y\frac{\partial}{\partial x}-x\frac{\partial}{\partial y}\right) \\\\
&amp;=\mathrm{i}^2\hbar^2\left(y\frac{\partial}{\partial x}-x\frac{\partial}{\partial y}\right) \\\\
&amp;=\mathrm{i}\hbar\left[-\mathrm{i}\hbar\left(x\frac{\partial}{\partial y}-y\frac{\partial}{\partial x}\right)\right] \\\\
&amp;=\mathrm{i}\hbar\hat{l}_z≠0
\end{align}\]

<p>因此，这两个算子<strong>不可交换</strong>。</p>

<h2 id="算子组三">算子组三</h2>

<p>通过算子组二可以类似推理得到：</p>

\[[\hat{l}_y, \hat{l}_z]=\mathrm{i}\hbar\hat{l}_x\]

\[[\hat{l}_z, \hat{l}_x]=\mathrm{i}\hbar\hat{l}_y\]

<p>将其代入可得：</p>

\[\begin{align}
[\hat{\boldsymbol{l}}^2, \hat{l}_z]&amp;=\hat{\boldsymbol{l}}^2\hat{l}_z-\hat{\boldsymbol{l}}^2\hat{l}_z \\\\
&amp;=(\hat{l}_x^2+\hat{l}_y^2+\hat{l}_z^2)\hat{l}_z-\hat{l}_z(\hat{l}_x^2+\hat{l}_y^2+\hat{l}_z^2) \\\\
&amp;=\hat{l}_x\hat{l}_x\hat{l}_z+\hat{l}_y\hat{l}_y\hat{l}_z+\hat{l}_z\hat{l}_z\hat{l}_z-\hat{l}_z\hat{l}_x\hat{l}_x-\hat{l}_z\hat{l}_y\hat{l}_y-\hat{l}_z\hat{l}_z\hat{l}_z \\\\
&amp;=\hat{l}_x\hat{l}_x\hat{l}_z+\hat{l}_y\hat{l}_y\hat{l}_z+\bcancel{\hat{l}_z\hat{l}_z\hat{l}_z}-\hat{l}_z\hat{l}_x\hat{l}_x-\hat{l}_z\hat{l}_y\hat{l}_y-\bcancel{\hat{l}_z\hat{l}_z\hat{l}_z} \\\\
&amp;=\hat{l}_x\hat{l}_x\hat{l}_z+\color{red}{\hat{l}_x\hat{l}_z\hat{l}_x-\hat{l}_x\hat{l}_z\hat{l}_x}\color{black}{-\hat{l}_z\hat{l}_x\hat{l}_x}+\hat{l}_y\hat{l}_y\hat{l}_z+\color{red}{\hat{l}_y\hat{l}_z\hat{l}_y-\hat{l}_y\hat{l}_z\hat{l}_y}\color{black}{-\hat{l}_z\hat{l}_y\hat{l}_y} \\\\
&amp;=\hat{l}_x(\hat{l}_x\hat{l}_z-\hat{l}_z\hat{l}_x)+(\hat{l}_x\hat{l}_z-\hat{l}_z\hat{l}_x)\hat{l}_x+\hat{l}_y(\hat{l}_y\hat{l}_z-\hat{l}_z\hat{l}_y)+(\hat{l}_y\hat{l}_z-\hat{l}_z\hat{l}_y)\hat{l}_y \\\\
&amp;=\hat{l}_x(-[\hat{l}_z, \hat{l}_x])+(-[\hat{l}_z, \hat{l}_x])\hat{l}_x+\hat{l}_y[\hat{l}_y, \hat{l}_z]+[\hat{l}_y, \hat{l}_z]\hat{l}_y \\\\
&amp;=-\mathrm{i}\hbar\hat{l}_x\hat{l}_y-\mathrm{i}\hbar\hat{l}_y\hat{l}_x+\mathrm{i}\hbar\hat{l}_y\hat{l}_x+\mathrm{i}\hbar\hat{l}_x\hat{l}_y = 0
\end{align}\]

<p>因此，这两个算子<strong>可交换</strong>。</p>]]></content><author><name>zhonger</name></author><category term="ac" /><category term="qc" /><category term="Quantum Chemistry" /><category term="By hand" /><category term="Solution" /><category term="Exercise" /><summary type="html"><![CDATA[note “练习题1-2” 判断下列算子是否可交换？ \[[1]\ [\hat{x},\hat{p}_x] \quad [2]\ [\hat{l}_x, \hat{l_y}] \quad [3]\ [\hat{\boldsymbol{l}}^2, \hat{l}_z]\]]]></summary></entry><entry><title type="html">《手解量子化学》练习题 1-1</title><link href="https://lisz.me/ac/qc/solve-quantum-chemistry-by-hand-1-1.html" rel="alternate" type="text/html" title="《手解量子化学》练习题 1-1" /><published>2025-05-14T16:52:00+09:00</published><updated>2025-05-14T16:52:00+09:00</updated><id>https://lisz.me/ac/qc/solve-quantum-chemistry-by-hand-1-1</id><content type="html" xml:base="https://lisz.me/ac/qc/solve-quantum-chemistry-by-hand-1-1.html"><![CDATA[<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 练习题1-1 </div> </div> <div class="content"> <p><strong>判断下面的算子是否厄米（Hermitian）或为厄米算子（Hermite Operator）。</strong></p>

\[[1]\ {d \over dx} \quad [2]\ {\mathrm{i}{d \over dx}} \quad [3]\ {d^2 \over dx^2}\]



 </div> </div>
<p>解答本题首先要理解厄米的判断条件：</p>

\[\int\psi_{i}^*(\boldsymbol{r}) \hat{f}\psi_{j}(\boldsymbol{r})d\boldsymbol{r}=\int\psi_{j}(\boldsymbol{r}) \hat{f}^*\psi_{i}^*(\boldsymbol{r})d\boldsymbol{r}\]

<p>其中 \(\hat{f}^*\) 是 \(\hat{f}\) 的复共轭或伴随算子， \(\psi_{i}(\boldsymbol{r})\) 和 \(\psi_{j}(\boldsymbol{r})\) 为基底函数，其对应的复共轭函数为 \(\psi_{i}^*(\boldsymbol{r})\) 和 \(\psi_{j}^*(\boldsymbol{r})\)。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 知识点补充一 </div> </div> <div class="content"> <p>  基底函数符合<strong>正交归一化条件</strong>，即“<strong>任意两个不同基底函数正交</strong>”和“<strong>任意一个基底函数在全空间上的积分为 1</strong>”。形式化可以表示为
\(\int\psi_{i}^*(\boldsymbol{r})\psi_{j}(\boldsymbol{r})d\boldsymbol{r}=0\)
和
\(\int|\psi(\boldsymbol{r})|^2 d\boldsymbol{r}=1\)。</p>



 </div> </div>
<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 知识点补充二 </div> </div> <div class="content"> <p>  求导数时的链式法则：\((uv)'=u'v+uv'\)。转换为积分形式： \(uv=\int{u'v}d\boldsymbol{r}+\int{uv'}d\boldsymbol{r}\)，将右边的第一项移到左边于是有 \(\int{uv'}d\boldsymbol{r}=uv-\int{u'v}d\boldsymbol{r}\)。</p>



 </div> </div>
<h2 id="算子一">算子一</h2>

<p>现在开始考虑第一个算子 \(\hat{f}={d \over dx}\)，显然这个算子就是求导算子（这里是<strong>对后面的函数微分求导</strong>），于是</p>

\[\begin{align}
左边&amp;= \int\psi_{i}^*(x)\left({d \over dx}\psi_{j}(x)\right)dx \\\\
&amp;=[\psi_{i}^*(x)\psi_{j}(x)]_{-\infty}^{+\infty}-\int\left({d \over dx}\psi_{i}^*(x)\right)\psi_{j}(x)dx
\end{align}\]

<p>由于 \(\displaystyle \lim_{x \to \pm\infty} \psi_{i}^*(x)=0\) 和 \(\displaystyle \lim_{x \to \pm\infty }\psi_{j}(x)=0\)（有限，作为波函数的基底函数在无穷处必须快速衰减），所以有</p>

\[[\psi_{i}^*(x)\psi_{j}(x)]_{-\infty}^{+\infty}=0\]

<p>即</p>

\[\begin{align}
左边&amp;=-\int\left({d \over dx}\psi_{i}^*(x)\right)\psi_{j}(x)dx \\\\
&amp;=-\int\psi_{j}(x){d \over dx}\psi_{i}^*(x)dx \\\\
&amp;≠右边
\end{align}\]

<p>因此<strong>第一个算子不是厄米算子</strong>。</p>

<h2 id="算子二">算子二</h2>

<p>类似第一个算子，对于第二个算子 \(\hat{f}=\mathrm{i}{d \over dx}\) 有</p>

\[\begin{align}
左边&amp;=\int\psi_{i}^*(x)\left(\mathrm{i}{d \over dx}\psi_{j}(x)\right)dx \\\\
&amp;=\mathrm{i}[\psi_{i}^*(x)\psi_{j}(x)]_{-\infty}^{+\infty}-\int\left(\mathrm{i}{d \over dx}\psi_{i}^*(x)\right)\psi_{j}(x)dx
\end{align}\]

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 知识点补充三 </div> </div> <div class="content"> 
\[\left(\mathrm{i}{d \over dx}\right)^*=-\mathrm{i}{d \over dx}\]



 </div> </div>
<p>应用<strong>基底函数的有限条件</strong>和上述的<strong>伴随算子</strong>可得</p>

\[\begin{align}
左边&amp;=0-\int\left(-\left(\mathrm{i}{d \over dx}\right)^*\psi_{i}^*(x)\right)\psi_{j}(x)dx \\\\
&amp;=\int\left(\left(\mathrm{i}{d \over dx}\right)^*\psi_{i}^*(x)\right)\psi_{j}(x)dx=右边
\end{align}\]

<p>因此<strong>第二个算子是厄米算子</strong>。</p>

<h2 id="算子三">算子三</h2>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 知识点补充四 </div> </div> <div class="content"> <p><strong>二阶导的伴随算子还是它本身</strong>，于是有</p>

\[\left( {d^2 \over dx^2} \right)^*={d^2 \over dx^2}\]



 </div> </div>
<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 知识点补充四 </div> </div> <div class="content"> <p>根据链式法则，求一阶导有：
\((uv')'=u'v'+uv''\) 和 \((u'v)'=u'v'+u''v\)。
对应的积分形式：\(\int{uv''}=uv'-\int{u'v'}\) 和 \(\int{u'v'}=u'v-\int{u''v}\)。</p>



 </div> </div>
<p>第三个算子是二阶导数，有</p>

\[\begin{align}
左边 &amp;=\int\psi_{i}^*(x){d^2 \over dx^2}\psi_{j}(x)dx \\\\
&amp;=[\psi_{i}^*(x){d \over dx}\psi_{j}(x)]_{-\infty}^{+\infty}-\int\left({d \over dx}\psi_{i}^*(x)\right)\left({d \over dx}\psi_{j}(x)\right)dx \\\\
&amp;=-\int\left({d \over dx}\psi_{i}^*(x)\right)\left({d \over dx}\psi_{j}(x)\right)dx \\\\
&amp;=-\left(\left[\left({d \over dx}\psi_{i}^*(x)\right)\psi_{j}(x)\right]_{-\infty}^{+\infty}-\int\left({d^2 \over dx^2}\psi_{i}^*(x)\right)\psi_{j}(x)dx\right) \\\\
&amp;=0+\int\left({d^2 \over dx^2}\psi_{i}^*(x)\right)\psi_{j}(x)dx \\\\
&amp;=\int\left(\left({d^2 \over dx^2}\right)^*\psi_{i}^*(x)\right)\psi_{j}(x)dx=右边
\end{align}\]

<p>因此，<strong>第三个算子是厄米算子</strong>。</p>]]></content><author><name>zhonger</name></author><category term="ac" /><category term="qc" /><category term="Quantum Chemistry" /><category term="By hand" /><category term="Solution" /><category term="Exercise" /><summary type="html"><![CDATA[note “练习题1-1” 判断下面的算子是否厄米（Hermitian）或为厄米算子（Hermite Operator）。 \[[1]\ {d \over dx} \quad [2]\ {\mathrm{i}{d \over dx}} \quad [3]\ {d^2 \over dx^2}\]]]></summary></entry><entry><title type="html">Kubernetes 不完全入门</title><link href="https://lisz.me/tech/k8s/k8s-introduction.html" rel="alternate" type="text/html" title="Kubernetes 不完全入门" /><published>2024-10-08T16:50:00+09:00</published><updated>2024-10-08T16:50:00+09:00</updated><id>https://lisz.me/tech/k8s/k8s-introduction</id><content type="html" xml:base="https://lisz.me/tech/k8s/k8s-introduction.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  Web 应用的生产环境部署随着技术的发展不断地发生改变，如下图所示，从最早期的单机环境到多机环境，再发展到复杂环境：</p>

<ul>
  <li><strong>单机环境</strong>指的是代码、运行环境、文件存储、数据库服务都在同一台服务器上的应用部署方式。通常来说，个人应用或者早期 Demo 应用大多采用这类方式。单机环境的优点在于不需要太多服务器资源，缺点在于过分依赖本地资源而没有高可用性、高可扩展性以及数据的安全保障。如果是云服务器作为单机环境，可以通过升级配置的方式来提高 CPU、内存和存储资源。至于数据则可以通过异机备份或本地备份的方式来保障数据的可靠性。</li>
  <li><strong>多机环境</strong>指的是同一应用所需的运行环境、数据库服务、文件存储服务分布在不同的节点或集群中的应用部署方式。这类方式的优点自然是具备高可用性、高可扩展性以及完备的数据安全保障，缺点则是需要大量的服务器资源。因此，多机环境通常是对外大量用户提供服务时常用的方式。</li>
  <li><strong>复杂环境</strong>打破了原有的瓶瓶罐罐，是多机环境的一种的超级形态。在复杂环境中，不再拘泥于服务器节点本身，而是利用 Web 应用将已有的云资源联系在一起。说得更直白一点，就是应用开发者不再需要关心应用运行环境、数据库服务、文件存储等基础环境的配置和管理，唯一需要关心的只有应用代码本身。这也是现在大部分 Web 应用的真实部署方式。</li>
</ul>

<p>  自从代码版本跟踪软件 Git 横空出世以来，逐步形成了以 Git 为中心的<strong>持续开发、持续集成和持续部署</strong>的现代应用开发方式。这与复杂环境的部署方式完全契合，由云服务提供商来提供和维护各类运行环境、数据库服务和文件存储，开发团队只需要专注于对代码存储库的管理。</p>

<p>  举个例子，当某个开发成员完成了某个模块的开发并推送到某个分支，该分支创建后会自动触发持续集成进行自动 Review。自动 Review 通过后，开发团队负责人可以对该分支的代码更改进行审核，通过后允许将该分支与其他某个指定分支进行合并（合并操作也是通过持续集成自动进行）。当所有代码开发完毕后，由总负责人审核汇入最终部署的分支。审核通过后持续集成会自动合并代码并通过持续部署将完整的代码部署到真实的运行环境中。如今的 GitHub、GitLab 均能完成持续开发、持续集成和持续部署的全过程。当然，也有一些软件（比如 <a href="https://www.jenkins.io/">Jenkins</a> 等）可以完成持续集成和持续部署两步，而持续开发则可以依托任意的 Git 托管服务。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 友情提醒 </div> </div> <div class="content"> <p>  以上叙述非专业解释，仅为个人看法，不喜勿喷。Kubernetes 官方将部署方式分为<strong>传统部署</strong>、<strong>虚拟化部署</strong>和<strong>容器部署</strong>三类。</p>



 </div> </div>
<p><img src="https://i.lisz.top/blog/79is8s.webp" alt="(a) 单机环境和多机环境。(b) 复杂环境。(c)以 Git 为中心的持续开发、持续集成、持续部署的现代应用开发方式。" /></p>

<h3 id="实例解析">实例解析</h3>

<p>  假设一个 Web 应用同时需要使用：</p>

<ul>
  <li><strong>运行环境</strong>：PHP 运行环境、Python 运行环境、NodeJS 运行环境。</li>
  <li><strong>数据库服务</strong>：关系型数据库（比如 MySQL）、非关系型数据库（比如 MongoDB）、缓存数据库（比如 Redis）。</li>
  <li><strong>文件存储</strong>：用于存储用户头像、上传文件的对象存储（S3）、用于存储运行代码的文件存储（比如 NFS）。</li>
  <li><strong>高可用应用入口</strong>：比如 Nginx、HaProxy 等。</li>
</ul>

<p>  在单机环境中，按照以前我们碰见这种要求可能就要头大了，毕竟同时配置这么多环境难免会有不可预知的问题。不过现在，容器化技术（比如 <a href="https://www.docker.com/">Docker</a>）可以帮助我们将所有的需求都拆分成独立的 container 实例。不但可以让它们之间在内部网络中互通，还可以对外只暴露必要的应用入口所需的 <code class="language-plaintext highlighter-rouge">80</code> 和 <code class="language-plaintext highlighter-rouge">443</code> 端口。这样一来，既将各项服务进行了合理拆分，又能保证应用服务的安全性。即使是需要对某个运行环境或者数据库服务进行版本升级，也可以很容易做到。</p>

<p>  在多机环境中，我们如果还想用容器化技术，那就必须用容器化集群。很久以前，Docker 官方就提供了一种 Swarm 模式来组成容器化集群。这种方式的好处是非常简单配置、轻量易用，对于熟悉使用 Docker 的开发者来说只需要花很少的时间就能搞明白。缺点也很明显，Docker Swarm 依赖于 Docker API。也就是说，Docker 本身不支持的东西还是不支持，比如更加高效安全的网络、花式多样的存储等。为了能够更好跨主机集群地自动部署、扩展以及运行应用程序容器，我们选择使用 <a href="https://kubernetes.io/zh-cn/">Kubernetes</a>（缩写为 <strong>K8S</strong>）。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小知识 </div> </div> <div class="content"> <p>  在 2014 年 Google 开源了 Kubenetes 项目，后来又贡献给了云原生计算基金会 <a href="https://www.cncf.io/">CNCF</a>。很多公司以 Kubernetes 为基础开发了自家的容器化集群平台，比如 RedHat 的 <a href="https://www.redhat.com/en/technologies/cloud-computing/openshift">OpenShift</a>，AWS 的 <a href="https://aws.amazon.com/cn/eks/">Elastic Kubenetes Services, EKS</a>，Azure 的 <a href="https://azure.microsoft.com/zh-cn/products/kubernetes-service">Azure Kubernetes Services, AKS</a>，阿里云的 <a href="https://www.aliyun.com/product/kubernetes">Aliyun Container Service for Kubernetes, ACK</a>，腾讯云的 <a href="https://cloud.tencent.com/product/tke">Tencent Kubernetes Engine, TKE</a> 等。</p>



 </div> </div>
<h2 id="kubernetes-架构">Kubernetes 架构</h2>

<p>  虽然 Kubernetes 官方文档已经将架构图以及相关概念介绍得非常清楚，但还是想说说自己的理解。类似于一般集群平台，K8S 也需要有至少一个控制节点（官方称之为“控制平面”）和一个工作节点。默认来说，K8S <strong>不推荐控制节点同时作为工作节点</strong>，因为这会影响集群调度的可靠性和可用性。从下面的重绘架构图可以看出，K8S 集群会对外提供 API 以供用户从集群外进行调度。在集群内部，工作节点通过 kubelet 服务与控制节点直接连接，控制节点也通过 kubelet 服务向工作节点下达调度指令来管理工作节点上的 pod。</p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> Pod 的概念 </div> </div> <div class="content"> <p>  Pod 可以理解为 K8S 中应用的最小单位，一个 Pod 中可能会包括一个或多个 container (容器)，这些容器间可以互通，但对外只有 Pod 有资格拥有 IP。这有点类似于进程与线程之间的关系，进程是拥有资源的最小单位，线程依赖于进程而存在，同一进程间的线程间可以无障碍通信，而不同进程间的通信则需要通过端口或 socket 来进行。</p>

<p>  同一个工作节点上的 Pod 的 IP 属于同一个子网，不同工作节点的子网又属于同一个大子网 (podSubnet，一般需要在初始化集群时定义)。这样的设计在很大程度上减少了 IP 管理的难度，并且能够最大程度上减少容器暴露的风险。</p>



 </div> </div>
<p><img src="https://i.lisz.top/blog/BV7Jqo.webp" alt="重绘 Kubernetes 官方文档架构图" /></p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> CRI 的概念 </div> </div> <div class="content"> <p>  CRI，全名为 Container Runtime Interface（容器运行时接口），是 K8S 架构中 kubelet和容器运行时通信的主要协议。我们所熟知的 Docker 就是一种容器运行时，但是自从 K8S 1.20 版本弃用 Docker 自带的容器运行时接口 Dockershim 以来，我们只能使用额外的 CRI – <a href="https://github.com/Mirantis/cri-dockerd">cri-dockerd</a> 来调用 Docker。因此推荐使用包含 CRI 的容器运行时 <a href="https://containerd.io/">containerd</a> 或者 <a href="https://cri-o.io/">cri-o</a> 来替代 Docker。</p>



 </div> </div>
<h3 id="组成部分">组成部分</h3>

<p>  由于 K8S 是一款平台无关的容器集群方案，所以官方提供的方案只是一个整体，我们需要自行选择以下各项组件：</p>

<ul>
  <li><strong>容器运行时 (CRI)</strong>：如上所述，推荐使用 containerd 或者 cri-o 来替代 docker。下面实践部分将以 containerd 为例。</li>
  <li><strong>网络组件 (CNI, Container Network Interface)</strong>：K8S 中网络有三种 Node、Pod、Service，其中 Node IP 是节点的 IP，用于连通或者暴露端口。Pod IP 是 Pod 的独立内网 IP，只能在 K8S 集群间访问。Service IP 是多个 Pod 共同组成 Service 后需要互通时使用的，一般仅在 Service 内部可访问，不能被用户访问。K8S 官方文档中 <a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/#networking-and-network-policy">联网和网络策略</a> 列举了很多可用的 CNI，这里我们选用 <a href="https://www.tigera.io/project-calico/">Calico</a> 来进行实践。</li>
  <li><strong>服务发现 (DNS)</strong>：默认为 <a href="https://coredns.io/">CoreDNS</a>，在配置完网络组件后自动创建，为 Pod 提供 DNS 解析服务，包括公网域名解析和 Service 别名解析。</li>
  <li><strong>容器存储接口 (CSI, Container Storage Interface)</strong>：目前 K8S 基本上移除了大部分的第三方软件相关存储插件，转而通过第三方自行维护的 CSI 来扩充存储类的支持。可以通过查看 K8S 官网文档的 <a href="https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#provisioner">存储制备器</a> 和 kubernetes-csi 的 <a href="https://kubernetes-csi.github.io/docs/drivers.html">Drivier</a> 来了解更多。这里我们选用 NFS 的 CSI Driver 作为例子进行实践。</li>
</ul>

<h2 id="搭建-k8s-集群">搭建 K8S 集群</h2>

<p>  在学习环境中，我们可以使用 <a href="https://kind.sigs.k8s.io/">kind</a>、<a href="https://minikube.sigs.k8s.io/">minikube</a> 或者 kubeadm 在本地快速部署 K8S 集群；在生产环境中，我们可以使用 <a href="https://kops.sigs.k8s.io/">kops</a>、<a href="https://kubespray.io/">Kubespray</a> 或者 kubeadm 在多节点上快速部署 K8S 集群。所以这里我们采用了通用的 kubeadm 来搭建 K8S 集群。</p>

<p>  在正式部署之前需要规划实际架构、做一些基本准确以及安装必要的软件和工具 – <code class="language-plaintext highlighter-rouge">kubelet</code>，<code class="language-plaintext highlighter-rouge">kubectl</code> 和 <code class="language-plaintext highlighter-rouge">kubeadm</code>。下图为本实践规划的 NodeSubset、PodSubset 和 ServiceSubset。</p>

<p><img src="https://i.lisz.top/blog/Z0hCRO.webp" alt="K8S 集群实际架构和网络规划" /></p>

<h3 id="基本准备">基本准备</h3>

<h4 id="关闭-swap-交换分区">关闭 SWAP 交换分区</h4>

<p>  K8S 为了性能考虑默认必须关闭 SWAP 交换分区，而通常实体服务器安装后会有 SWAP 交换分区，云服务器或 VPS 没有。通过 <code class="language-plaintext highlighter-rouge">sudo swapoff -a</code> 命令可以临时关闭 SWAP 分区，或者通过注释 <code class="language-plaintext highlighter-rouge">/etc/fstab</code> 文件中的 <code class="language-plaintext highlighter-rouge">swap.img</code> 这一行并重启服务器永久关闭 SWAP 交换分区。</p>

<h4 id="开启-ipv4-转发">开启 IPv4 转发</h4>

<p>  由于 K8S 集群中同一个 Service 的 Pod 可能被分配到不同节点，那么不同节点间的 Pod 通信是非常必要的，即不同 PodSubnet 之间的通信需要通过 Node IP 来进行 IPv4 转发。执行以下命令添加允许 IPv4 转发到 <code class="language-plaintext highlighter-rouge">/etc/sysctl.d/k8s.conf</code> 文件里，并且立即生效：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 添加配置</span>
<span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/sysctl.d/k8s.conf <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
net.ipv4.ip_forward = 1
net.bridge.bridge-nf-call-iptables = 1
net.bridge.bridge-nf-call-ip6tables = 1
</span><span class="no">EOF

</span><span class="c"># 立即生效</span>
<span class="nb">sudo </span>sysctl <span class="nt">--system</span>
</code></pre></div></div>

<h4 id="配置主机名对应">配置主机名对应</h4>

<p>  K8S 集群初始化时会自动搜索主机名的 DNS 解析，目前测试的主机名没有完整的 FQDN 或 PTR 解析，因此有必要设置好主机名和 IP 对应信息到本地静态 DNS 解析文件 <code class="language-plaintext highlighter-rouge">/etc/hosts</code> 中。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 分别在不同节点根据规划设置好主机名</span>
<span class="nb">sudo </span>hostnamectl set-hostname vm01
<span class="nb">sudo </span>hostnamectl set-hostname vm02
<span class="nb">sudo </span>hostnamectl set-hostname vm03

<span class="c"># 修改所有节点的 /etc/hosts</span>
<span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/hosts <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
192.168.120.1  vm01
192.168.120.2  vm02
192.168.120.3  vm03
</span><span class="no">EOF
</span></code></pre></div></div>

<h4 id="同步时间">同步时间</h4>

<p>  K8S 集群的运行必须保证节点的时间是完全同步的，否则容易造成某些未知的 Bug。比如证书的过期时间将会被某些时间不同步的节点错误判断。推荐使用同一时区和同一 NTP 服务器，如下即可完成设置。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 设置相同时区并查看</span>
<span class="nb">sudo </span>timedatectl set-timezone Asia/Shanghai
timedatectl
timedatectl status

<span class="c"># 修改 NTP 服务器</span>
<span class="nb">sudo </span>timedatectl set-ntp <span class="nb">false
sudo sed</span> <span class="nt">-i</span> <span class="s1">'s/#NTP=/NTP=ntp.lisz.top/'</span> /etc/systemd/timesyncd.conf
<span class="nb">sudo sed</span> <span class="nt">-i</span> <span class="s1">'s/#FallbackNTP=ntp.ubuntu.com/FallbackNTP=ntp.aliyun.com/'</span> /etc/systemd/timesyncd.conf
<span class="nb">sudo </span>timedatectl set-ntp <span class="nb">true</span>

<span class="c"># 重启服务使配置生效、同步时间并查看信息</span>
<span class="nb">sudo </span>systemctl restart systemd-timesyncd
timedatectl show-timesync <span class="nt">--all</span>
<span class="nb">date</span>
</code></pre></div></div>

<h3 id="安装必要软件和工具">安装必要软件和工具</h3>

<h4 id="安装-containerd">安装 containerd</h4>

<p>  containerd 虽然是由  containerd 开发团队负责发布，但是 APT 或 YUM 镜像源仍然是由 Docker 官方负责，所以当我们添加 docker-ce 的镜像源后可以直接下载 <code class="language-plaintext highlighter-rouge">containerd.io</code> 来安装 containerd。当然， 我们可以从 <a href="https://github.com/containerd/containerd/releases">containerd/containerd</a> 直接下载二进制可执行文件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 添加镜像源</span>
curl <span class="nt">-fsSL</span> https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu/gpg | <span class="nb">sudo </span>gpg <span class="nt">--dearmor</span> <span class="nt">-o</span> /etc/apt/trusted.gpg.d/docker.gpg
<span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/apt/sources.list.d/docker.list <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
    deb [arch=amd64 signed-by=/etc/apt/trusted.gpg.d/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu/ </span><span class="si">$(</span>lsb_release <span class="nt">-c</span> <span class="nt">--short</span><span class="si">)</span><span class="sh"> stable
</span><span class="no">EOF

</span><span class="c"># 更新软件列表缓存并安装 containerd</span>
<span class="nb">sudo </span>apt update <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>apt upgrade <span class="nt">-y</span> <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> containerd.io
</code></pre></div></div>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小建议 </div> </div> <div class="content"> <p>  个人推荐使用 APT 或 YUM 方式安装 containerd。原因有二：一是国内有 docker-ce 镜像安装比较快，二是想要更新时非常容易。</p>



 </div> </div>
<h4 id="配置-containerd">配置 containerd</h4>

<p>  containerd 安装后默认没有配置文件也不会自动启动后台程序，所以需要准备配置文件并复制到 <code class="language-plaintext highlighter-rouge">/etc/containerd/config.toml</code> 再启动。由于 K8S 集群默认使用 <code class="language-plaintext highlighter-rouge">registry.k8s.io</code> 和 <code class="language-plaintext highlighter-rouge">registry-1.docker.io</code> 源下载容器镜像，为了提升速度建议切换到阿里云和 DaoCloud 的加速器。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>containerd config default <span class="o">&gt;</span> containerd_config.toml
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s#registry.k8s.io#registry.cn-hangzhou.aliyuncs.com/google_containers#g"</span> containerd_config.toml
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"/containerd.runtimes.runc.options/a</span><span class="se">\ \ \ \ \ \ \ \ \ \ \ \ </span><span class="s2">SystemdCgroup = true"</span> containerd_config.toml
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s#https://registry-1.docker.io#https://docker.m.daocloud.io#g"</span> containerd_config.toml

<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/containerd
<span class="nb">cp </span>containerd_config.toml /etc/containerd/config.toml

<span class="nb">sudo </span>systemctl daemon-reload
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>containerd
<span class="nb">sudo </span>systemctl restart containerd

<span class="nb">sudo </span>systemctl status containerd.service <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>ctr <span class="nt">--version</span>
</code></pre></div></div>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  由于 <code class="language-plaintext highlighter-rouge">ctr</code> 命令连接的 containerd 的 socket 文件只有 root 用户组有权限访问，所以目前只能使用 <code class="language-plaintext highlighter-rouge">sudo ctr</code>。如果想要直接使用 <code class="language-plaintext highlighter-rouge">ctr</code> 命令，可以使用 <code class="language-plaintext highlighter-rouge">sudo usermod -aG root ubuntu</code> 来将当前用户添加到 root 用户组。赋权之后需退出登录后再次登录才能生效。</p>



 </div> </div>
<h4 id="安装-kubeadm-等">安装 kubeadm 等</h4>

<p>  国内清华大学 TUNA 镜像源、阿里云镜像源等都提供了 <code class="language-plaintext highlighter-rouge">kubeadm</code> 等三件套工具的 APT 或 YUM 源，通过以下命令可以很容易完全安装。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 友情提醒 </div> </div> <div class="content"> <p>  由于 kubernetes 不同版本可能会存在较大差异，并且为了避免节点 kubernetes 版本在不自觉的时候升级造成兼容性问题，这里推荐固定 kubeadm 等三件套版本号，即不启用 <code class="language-plaintext highlighter-rouge">apt upgrade</code> 自动升级。管理员关闭 K8S 集群手动升级版本时不受影响。</p>



 </div> </div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 添加镜像源</span>
curl <span class="nt">-fsSL</span> https://mirrors.tuna.tsinghua.edu.cn/kubernetes/core:/stable:/v1.30/deb/Release.key | <span class="nb">sudo </span>gpg <span class="nt">--dearmor</span> <span class="nt">-o</span> /etc/apt/keyrings/kubernetes-apt-keyring.gpg 
<span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/apt/sources.list.d/kubernetes.list <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://mirrors.tuna.tsinghua.edu.cn/kubernetes/core:/stable:/v1.30/deb/ / 
# deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://mirrors.tuna.tsinghua.edu.cn/kubernetes/addons:/cri-o:/stable:/v1.30/deb/ / 
</span><span class="no">EOF

</span><span class="c"># 更新软件列表缓存并安装 kubeadm 三件套</span>
<span class="nb">sudo </span>apt update <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> kubeadm kubelet kubectl 

<span class="c"># 固定 kubeadm 等三件套版本</span>
<span class="nb">sudo </span>apt-mark hold kubeadm 
<span class="nb">sudo </span>apt-mark hold kubelet 
<span class="nb">sudo </span>apt-mark hold kubectl
</code></pre></div></div>

<h3 id="初始化集群">初始化集群</h3>

<h4 id="预下载镜像">预下载镜像</h4>

<p>  在所有节点上使用以下命令提前下载好 K8S 集群所需的基本镜像，避免初始化时一直在等待各个节点下载镜像。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubeadm config images list | <span class="nb">sed</span> <span class="nt">-e</span> <span class="s1">'s/^/sudo ctr image pull /g'</span> <span class="nt">-e</span> <span class="s1">'s#registry.k8s.io#registry.cn-hangzhou.aliyuncs.com/google_containers#g'</span> | sh <span class="nt">-x</span>
</code></pre></div></div>

<h4 id="初始化控制节点">初始化控制节点</h4>

<p>  下载完所需的容器镜像后，在控制节点上使用 <code class="language-plaintext highlighter-rouge">sudo kubeadm init --config=kubeadm_config.yaml</code> 命令初始化控制节点。<code class="language-plaintext highlighter-rouge">kubeadm_config.yaml</code> 的内容如下所示：（建议将配置文件放置在 <code class="language-plaintext highlighter-rouge">~/k8s</code> 目录下，<code class="language-plaintext highlighter-rouge">cd ~/k8s</code> 目录后执行初始化命令。）</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kubeadm.k8s.io/v1beta3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">InitConfiguration</span>
<span class="na">localAPIEndpoint</span><span class="pi">:</span>
  <span class="na">advertiseAddress</span><span class="pi">:</span> <span class="s">192.168.120.1</span>
  <span class="na">bindPort</span><span class="pi">:</span> <span class="m">6443</span>
<span class="na">nodeRegistration</span><span class="pi">:</span>
  <span class="na">criSocket</span><span class="pi">:</span> <span class="s2">"</span><span class="s">unix:///run/containerd/containerd.sock"</span>
<span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kubeadm.k8s.io/v1beta3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ClusterConfiguration</span>
<span class="na">kubernetesVersion</span><span class="pi">:</span> <span class="s">stable</span>
<span class="na">imageRepository</span><span class="pi">:</span> <span class="s2">"</span><span class="s">registry.cn-hangzhou.aliyuncs.com/google_containers"</span>
<span class="na">networking</span><span class="pi">:</span>
  <span class="na">podSubnet</span><span class="pi">:</span> <span class="s">192.168.144.0/20</span>
  <span class="na">serviceSubnet</span><span class="pi">:</span> <span class="s">192.168.244.0/24</span>
</code></pre></div></div>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 友情提醒 </div> </div> <div class="content"> <p>  如果没有配置主机名对应的话，这里初始化会一直卡在 API Health 检测的步骤，实际上是因为没有主机名和 IP 对应而无法启动 API Server。</p>



 </div> </div>
<p>  kubeadm 初始化成功后需要复制验证文件才能在控制节点管理 K8S 集群，如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 复制验证文件</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$HOME</span>/.kube
<span class="nb">sudo cp</span> <span class="nt">-i</span> /etc/kubernetes/admin.conf <span class="nv">$HOME</span>/.kube/config
<span class="nb">sudo chown</span> <span class="si">$(</span><span class="nb">id</span> <span class="nt">-u</span><span class="si">)</span>:<span class="si">$(</span><span class="nb">id</span> <span class="nt">-g</span><span class="si">)</span> <span class="nv">$HOME</span>/.kube/config

<span class="c"># 查询节点状态</span>
kubectl get nodes <span class="nt">-o</span> wide
</code></pre></div></div>

<h4 id="工作节点加入集群">工作节点加入集群</h4>

<p>  刚才初始化集群后会出现工作节点加入集群的命令，形如：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubeadm <span class="nb">join </span>192.168.120.1:6443 <span class="nt">--token</span> z9sdsdi.tdeu74psxqi8rhdt <span class="se">\</span>
    <span class="nt">--discovery-token-ca-cert-hash</span> sha256:87c4f8dd9dabaf2e5e793c0404c74dd8f9f56153000dad3c1a3238a3e8b0beff
</code></pre></div></div>

<p>  注意这里需要加上 <code class="language-plaintext highlighter-rouge">sudo</code> 之后再在工作节点上执行加入集群操作。加入完成后可以在控制节点上使用 <code class="language-plaintext highlighter-rouge">kubectl get nodes -o wide</code> 查看是否有了刚加入的工作节点的信息。由于目前还没有配置网络组件，除了控制节点外，其他工作节点应该均为 <code class="language-plaintext highlighter-rouge">NotReady</code> 状态。如果使用 <code class="language-plaintext highlighter-rouge">kubectl get pods --all-namespaces</code> 命令查看所有启动的 Pod，应该看到除两个 CordDNS 的 Pod (比如 <code class="language-plaintext highlighter-rouge">0/1</code>) 以外的所有 Pod 的状态都是完成启动 (比如 <code class="language-plaintext highlighter-rouge">1/1</code>)。</p>

<p>  工作节点加入后可以配置不同的标签，比如如下是配置为工作节点和添加 <code class="language-plaintext highlighter-rouge">gputype</code> 字段标签：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl label node vm02 node-role.kubernetes.io/worker<span class="o">=</span>
kubectl label node vm03 node-role.kubernetes.io/worker<span class="o">=</span>
kubectl label node vm02 <span class="nv">gputype</span><span class="o">=</span>P100
kubectl label node vm03 <span class="nv">gputype</span><span class="o">=</span>A100
</code></pre></div></div>

<h3 id="添加组件">添加组件</h3>

<h4 id="配置-calico-网络">配置 Calico 网络</h4>

<p>  Calico 支持一套灵活的网络选项，可以根据情况选择最有效的选项，包括非覆盖和覆盖网络，带或不带 BGP。Calico 使用相同的引擎为主机、Pod 和应用程序在服务网格层执行网络策略。如下所示可以很简单地为 K8S 集群启用 Calico 网络：</p>

<ol>
  <li>创建 Calico 所需的 operator（需要镜像 <code class="language-plaintext highlighter-rouge">quay.io/tigera/operator:v1.34.5</code>，可提前下载），仅在控制节点创建 Pod；</li>
  <li>创建和初始化 K8S 集群时对应的网络规划，主要是 PodSubset 配置，如下面修改过的 yaml 配置文件。这里为了加速创建过程，还添加了 <code class="language-plaintext highlighter-rouge">registry</code> 字段来使用 DaoCloud 加速器。</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> ~/k8s/calico &amp; <span class="nb">cd</span> ~/k8s/calico
wget <span class="nt">-c</span> https://raw.githubusercontent.com/projectcalico/calico/v3.28.1/manifests/tigera-operator.yaml
wget <span class="nt">-c</span> https://raw.githubusercontent.com/projectcalico/calico/v3.28.1/manifests/custom-resources.yaml 
kubectl create <span class="nt">-f</span> tigera-operator.yaml 
kubectl create <span class="nt">-f</span> custom-resources.yaml
</code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This section includes base Calico installation configuration.</span>
<span class="c1"># For more information, see: https://docs.tigera.io/calico/latest/reference/installation/api#operator.tigera.io/v1.Installation</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">operator.tigera.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Installation</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="c1"># Configures Calico networking.</span>
  <span class="na">calicoNetwork</span><span class="pi">:</span>
    <span class="na">ipPools</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">default-ipv4-ippool</span>
      <span class="na">blockSize</span><span class="pi">:</span> <span class="m">26</span>
      <span class="na">cidr</span><span class="pi">:</span> <span class="s">192.168.144.0/20</span>
      <span class="na">encapsulation</span><span class="pi">:</span> <span class="s">VXLANCrossSubnet</span>
      <span class="na">natOutgoing</span><span class="pi">:</span> <span class="s">Enabled</span>
      <span class="na">nodeSelector</span><span class="pi">:</span> <span class="s">all()</span>
  <span class="na">registry</span><span class="pi">:</span> <span class="s">m.daocloud.io</span>
<span class="nn">---</span>

<span class="c1"># This section configures the Calico API server.</span>
<span class="c1"># For more information, see: https://docs.tigera.io/calico/latest/reference/installation/api#operator.tigera.io/v1.APIServer</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">operator.tigera.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">APIServer</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span> <span class="pi">{}</span>
</code></pre></div></div>

<p>  如果通过 <code class="language-plaintext highlighter-rouge">kubectl get pod --all-namespaces</code> 发现哪个相关 Pod 卡在了拉取镜像的步骤，可以手动镜像。一般来说，使用修改的 DaoCloud 加速器下载应该没什么太大问题。创建 Calico 网络完成后会多出来 3 个命名空间: <code class="language-plaintext highlighter-rouge">tigera-operator</code>、 <code class="language-plaintext highlighter-rouge">calico-system</code> 和 <code class="language-plaintext highlighter-rouge">calico-apiserver</code>。新增的 Pod 应该如下所示：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">节点主机名</th>
      <th style="text-align: left">新增 Pod</th>
      <th style="text-align: left">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">vm01</td>
      <td style="text-align: left">tigera-operator</td>
      <td style="text-align: left">Calico 网络所需的描述子</td>
    </tr>
    <tr>
      <td style="text-align: center">vm01</td>
      <td style="text-align: left">calico-kube-controller</td>
      <td style="text-align: left">Calico 网络控制器</td>
    </tr>
    <tr>
      <td style="text-align: center">vm01</td>
      <td style="text-align: left">calico-apiserver</td>
      <td style="text-align: left">Calico 网络 API，一般有两个 Pod</td>
    </tr>
    <tr>
      <td style="text-align: center">vm01</td>
      <td style="text-align: left">calico-typha</td>
      <td style="text-align: left">优化和减少 Calico 对 K8S API 服务器的负载</td>
    </tr>
    <tr>
      <td style="text-align: center">vm01</td>
      <td style="text-align: left">calico-node</td>
      <td style="text-align: left">Calico 网络节点客户端</td>
    </tr>
    <tr>
      <td style="text-align: center">vm01</td>
      <td style="text-align: left">csi-node-driver</td>
      <td style="text-align: left">CSI 驱动</td>
    </tr>
    <tr>
      <td style="text-align: center">vm02</td>
      <td style="text-align: left">calico-typha</td>
      <td style="text-align: left">优化和减少 Calico 对 K8S API 服务器的负载</td>
    </tr>
    <tr>
      <td style="text-align: center">vm02</td>
      <td style="text-align: left">calico-node</td>
      <td style="text-align: left">Calico 网络节点客户端</td>
    </tr>
    <tr>
      <td style="text-align: center">vm02</td>
      <td style="text-align: left">csi-node-driver</td>
      <td style="text-align: left">CSI 驱动</td>
    </tr>
    <tr>
      <td style="text-align: center">vm03</td>
      <td style="text-align: left">calico-node</td>
      <td style="text-align: left">Calico 网络节点客户端</td>
    </tr>
    <tr>
      <td style="text-align: center">vm03</td>
      <td style="text-align: left">csi-node-driver</td>
      <td style="text-align: left">CSI 驱动</td>
    </tr>
  </tbody>
</table>

<h4 id="配置-nfs-csi-驱动和存储类">配置 NFS CSI 驱动和存储类</h4>

<p>  NFS CSI 驱动由 <a href="https://github.com/kubernetes-csi/csi-driver-nfs">kubernetes-csi/csi-driver-nfs</a> 项目提供支持。不过在正式安装驱动之前需要先安装 NFS 客户端，否则 NFS CSI 驱动也无法正常启用。为了加速下载容器镜像，这里推荐将配置中的 <code class="language-plaintext highlighter-rouge">registry.k8s.io</code> 源切换到 <code class="language-plaintext highlighter-rouge">k8s.m.daocloud.io</code> 加速器。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 在所有节点安装 NFS 客户端支持</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> nfs-common

<span class="c"># 下载 NFS CSI Driver 配置文件</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> ~/k8s/csi <span class="o">&amp;&amp;</span> <span class="nb">cd</span> ~/k8s/csi
git clone https://github.com/kubernetes-csi/csi-driver-nfs.git 

<span class="c"># 修改容器镜像为 DaoCloud 加速器</span>
<span class="nb">cd </span>csi-driver-nfs/deploy/v4.9.0
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s/registry.k8s.io/k8s.m.daocloud.io/"</span> ./<span class="k">*</span>

<span class="c"># 返回上上层目录，并安装 NFS CSI 驱动</span>
<span class="nb">cd</span> ../../
./deploy/install-driver.sh v4.9.0 <span class="nb">local</span> 
</code></pre></div></div>

<p>  安装 NFS CSI 驱动后会在 <code class="language-plaintext highlighter-rouge">kube-system</code> 命名空间中多出四个 Pod，其中一个 Pod 为 <code class="language-plaintext highlighter-rouge">csi-nfs-controller</code>，其他每个节点一个 <code class="language-plaintext highlighter-rouge">csi-nfs-node</code> 的 Pod。然后需要使用 <code class="language-plaintext highlighter-rouge">kubectl apply -f nfs.yaml</code> 命令创建一个 NFS 的存储类用于提供给应用程序，配置文件 <code class="language-plaintext highlighter-rouge">nfs.yaml</code> 内容如下所示：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">storage.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">StorageClass</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nfs-csi</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="na">storageclass.kubernetes.io/is-default-class</span><span class="pi">:</span> <span class="s2">"</span><span class="s">true"</span>
<span class="na">provisioner</span><span class="pi">:</span> <span class="s">nfs.csi.k8s.io</span>
<span class="na">parameters</span><span class="pi">:</span>
  <span class="na">server</span><span class="pi">:</span> <span class="s">nfs_server_ip</span>
  <span class="na">share</span><span class="pi">:</span> <span class="s">/home/data</span>
<span class="na">reclaimPolicy</span><span class="pi">:</span> <span class="s">Retain</span>
<span class="na">volumeBindingMode</span><span class="pi">:</span> <span class="s">Immediate</span>
<span class="na">allowVolumeExpansion</span><span class="pi">:</span> <span class="kc">true</span>
<span class="na">mountOptions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">async</span>
  <span class="pi">-</span> <span class="s">rsize=32768</span>
  <span class="pi">-</span> <span class="s">wsize=32768</span>
  <span class="pi">-</span> <span class="s">nconnect=8</span>
  <span class="pi">-</span> <span class="s">nfsvers=4.1</span>
  <span class="pi">-</span> <span class="s">hard</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看新增的存储类</span>
╰─<span class="nv">$ </span>kubectl get sc
NAME                PROVISIONER      RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
nfs-csi <span class="o">(</span>default<span class="o">)</span>   nfs.csi.k8s.io   Retain          Immediate           <span class="nb">true                   </span>4d1h
</code></pre></div></div>

<h4 id="gpu-支持">GPU 支持</h4>

<p>  K8S 的 GPU 支持是由 NVIDIA 提供的，需要工作节点先安装 NVIDIA 驱动和容器驱动，再在控制节点上部署 nvidia-device 插件支持。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看可安装 NVIDIA 驱动</span>
╰─<span class="nv">$ </span>ubuntu-drivers devices
modalias : pci:v000010DEd000026BAsv000010DEsd00001957bc03sc02i00
vendor   : NVIDIA Corporation
driver   : nvidia-driver-550-open - distro non-free
driver   : nvidia-driver-550 - distro non-free recommended
driver   : nvidia-driver-535-server - distro non-free
driver   : nvidia-driver-535-server-open - distro non-free
driver   : nvidia-driver-535-open - distro non-free
driver   : nvidia-driver-535 - distro non-free
driver   : xserver-xorg-video-nouveau - distro free <span class="nb">builtin</span>

<span class="c"># 安装 NVIDIA 驱动，并重启生效</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> nvidia-driver-535
<span class="nb">sudo </span>apt-mark hold nvidia-driver-535

<span class="c"># 添加 NVIDIA Container Toolkit 源</span>
curl <span class="nt">-fsSL</span> https://mirrors.ustc.edu.cn/libnvidia-container/gpgkey | <span class="nb">sudo </span>gpg <span class="nt">--dearmor</span> <span class="nt">-o</span> /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg <span class="se">\</span>
<span class="o">&amp;&amp;</span> curl <span class="nt">-s</span> <span class="nt">-L</span> https://mirrors.ustc.edu.cn/libnvidia-container/stable/deb/nvidia-container-toolkit.list | <span class="se">\</span>
    <span class="nb">sed</span> <span class="s1">'s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g'</span> | <span class="se">\</span>
    <span class="nb">sudo tee</span> /etc/apt/sources.list.d/nvidia-container-toolkit.list

<span class="c"># 更新软件列表缓存，安装 nvidia-container-toolkit</span>
<span class="nb">sudo </span>apt-get update <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> nvidia-container-toolkit

<span class="c"># 为 containerd 容器运行时增加 NVIDIA 选项</span>
<span class="nb">sudo </span>nvidia-ctk runtime configure <span class="nt">--runtime</span><span class="o">=</span>containerd

<span class="c"># 修改 /etc/containerd/config.toml 配置文件中默认运行时为 NVIDIA</span>
<span class="c"># 原来的默认运行时是 runc</span>
<span class="o">[</span>plugins.<span class="s2">"io.containerd.grpc.v1.cri"</span>.containerd]
      default_runtime_name <span class="o">=</span> <span class="s2">"nvidia"</span>

<span class="c"># 重新加载 containerd 配置文件并重启服务生效</span>
<span class="nb">sudo </span>systemctl daemon-reload
<span class="nb">sudo </span>systemctl restart containerd

<span class="c"># 在控制节点为 K8S 集群创建 NVIDIA device 插件支持</span>
<span class="nb">cd</span> ~/k8s
wget <span class="nt">-c</span> https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/v0.16.2/deployments/static/nvidia-device-plugin.yml

<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s/nvcr.io/nvcr.m.daocloud.io/"</span> nvidia-device-plugin.yml
kubectl create <span class="nt">-f</span> nvidia-device-plugin.yml

<span class="c"># 验证 GPU 是否被 K8S 识别</span>
kubectl describe node vm02 | <span class="nb">grep </span>nvidia.com/gpu:
</code></pre></div></div>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  NVIDIA GPU 驱动和容器驱动只需在有 NVIDIA GPU 的工作节点上配置，并且<strong>一定要修改默认运行时为 NVIDIA</strong>，否则无法被 K8S 识别。NVIDIA device 插件支持在控制节点上提交安装请求但会在每一个工作节点上安装，即使没有 NVIDIA GPU 存在。</p>



 </div> </div>
<h2 id="可能遇到的问题和解答">可能遇到的问题和解答</h2>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 如果各节点本身没有任何网络，需要使用内部 HTTP 代理上网怎么办？ </div> </div> <div class="content"> <p>  这种情况下需要为 kubelet 和 containerd 的 service 设置代理。kubelet 的配置文件为 <code class="language-plaintext highlighter-rouge">/usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</code>，containerd 的配置文件为 <code class="language-plaintext highlighter-rouge">/usr/lib/systemd/system/containerd.service</code>。配置内容如下所示。配置完后需要使用 <code class="language-plaintext highlighter-rouge">sudo systemctl daemon-reload</code> 来应用配置更改，并且使用 <code class="language-plaintext highlighter-rouge">sudo systemctl restart kubelet</code> 和 <code class="language-plaintext highlighter-rouge">sudo systemctl restart containerd</code> 重启服务。</p>



 </div> </div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># sudo vim /usr/lib/systemd/system/containerd.service</span>
<span class="c"># sudo vim /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</span>

<span class="o">[</span>Service]
...
<span class="nv">Environment</span><span class="o">=</span><span class="s2">"HTTP_PROXY=http://proxy.ip:3128"</span>
<span class="nv">Environment</span><span class="o">=</span><span class="s2">"HTTPS_PROXY=http://proxy.ip:3128"</span>
<span class="nv">Environment</span><span class="o">=</span><span class="s2">"NO_PROXY=localhost,127.0.0.1"</span>
</code></pre></div></div>

<h2 id="结语">结语</h2>

<p>  K8S 集群的搭建并非一件十分复杂的事情，比较复杂的是根据实际的需求和自己对于 K8S 的理解来搭建出更合适的 K8S 集群。虽然 K8S 集群已经逐步开始取代一般的 Docker 单机应用服务部署方案，但是就个人实际的应用规模或者应用本身而言，K8S 集群本身的维护和调整的代价要远高于 Docker 单机应用服务部署。如果是有高可用性、高可靠性等的需求，那么 K8S 可能是目前最好的需求。</p>

<p>  正如在前言中所述，有了 K8S 持续开发、持续集成和持续部署成为了现实，开发者可以把更多的注意力都放在应用代码开发。同时，类似于 JupyterHub 这类会有动态扩展和分配资源需求的应用，最佳的部署方式可能就是 K8S 了。当然，听说现在的大模型 ChatGPT 等也都是在 K8S 上训练出来的。</p>

<p>  K8S 的确是大有可为！</p>

<h2 id="参考资料">参考资料</h2>

<ol>
  <li><a href="https://www.blackduck.com/en-us/glossary/what-is-continuous-development.html">Continuous Development</a></li>
  <li><a href="https://aws.amazon.com/cn/devops/continuous-integration/">AWS – 什么是持续集成？</a></li>
  <li><a href="https://www.ibm.com/topics/continuous-deployment">IBM – What is continuous deployment?</a></li>
  <li><a href="https://circleci.com/blog/docker-swarm-vs-kubernetes/">Docker Swarm vs Kubernetes: how to choose a container orchestration tool</a></li>
  <li><a href="https://zh.wikipedia.org/zh-cn/Kubernetes">维基百科 – Kubernetes</a></li>
  <li><a href="https://www.ibm.com/blogs/solutions/jp-ja/container-cocreation-center-05/">IBM – 第5回 『Red Hat OpenShift と Kubernetes の違い』</a></li>
  <li><a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/">Kubernetes 文档 - 概念 - Kubernetes 架构</a></li>
  <li><a href="https://cloud.tencent.com/developer/article/1852347">基于 Containerd 运行时搭建 Kubernetes 集群实践</a></li>
</ol>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="k8s" /><category term="Kubernetes" /><category term="K8S" /><category term="kubeadm" /><category term="calico" /><category term="flannel" /><category term="csi-driver" /><category term="NFS" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">生活中的小问题——公交计费问题</title><link href="https://lisz.me/tech/algorithm/bus-ticket.html" rel="alternate" type="text/html" title="生活中的小问题——公交计费问题" /><published>2024-07-02T15:15:00+09:00</published><updated>2024-07-02T15:15:00+09:00</updated><id>https://lisz.me/tech/algorithm/bus-ticket</id><content type="html" xml:base="https://lisz.me/tech/algorithm/bus-ticket.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  谈到生活中经常坐的公交车，比较常见的算法问题可能是寻找“耗时最少公交路线”、“最少换乘公交路线”、“最便宜公交路线”、“综合最优公交路线”等。这些算法由于在地图软件中经常被使用，已经被大家研究得非常透彻，比如 Dijkstra 算法就可以用来计算“最短距离公交路线”。如想了解更多，可以阅读参考资料 2 给出的中文文献。</p>

<p>  相比这些常见的算法问题，不如让我们来一起看看不大被人提及的“公交计费问题”。笔者经常在下雨的时候乘坐公交车，每次上车前会先取一张票，然后下车前可以看屏幕显示来知道票价。于是笔者就有了一个小问题：票价是如何正确显示的，是否可以对其建模并写个小程序模拟一下。</p>

<h2 id="问题描述">问题描述</h2>

<p>  如图 1 所示为公交计费问题描述。</p>

<ul>
  <li><strong>(a) 公交路线图</strong>（图中为右循环路线，但对应的左循环路线也存在），0~20 为站点编号，且 1~3 与 20~18 分别对应相同。公交从站点 0 出发，按照箭头所指的方向依次行进，最终回到站点 0 并停止运行。</li>
  <li><strong>(b) 相邻站点间距离</strong>，以 km 为距离计算单位，给出的数值为公交在站点间实际行进距离。</li>
  <li><strong>(c) 公交票价计算方式</strong>，距离不足 2 km 为基本票价 190 日元，超过 2 km 的话每超过 1 km 加收 50 日元，如不足 1 km 按照 1 km 计算。注意，此处的距离为循环线路中上车站点与下车站点的<strong>有效距离</strong>，即站点间在循环线路上的最短距离而非实际运行距离。比如，即使从站点 0 上车，经过一圈循环后再从站点 0 下车，也只能收取基本票价 190 日元，因为有效距离为 0 km。（以上计算方式参考自资料 3）</li>
  <li><strong>(d) 公交最后返回起始站点时计费状态</strong>，灰底色为站点编号，白底色为票价。</li>
</ul>

<p><img src="https://i.lisz.top/blog/GTgvbN.webp" alt="图 1. 公交计费问题描述。 The description of bus ticket problem." /></p>

<h3 id="问题目标">问题目标</h3>

<ol>
  <li>打印欢迎消息，提示是否从站点 0 发车；</li>
  <li>发车后，通过回车或其他操作在下一站点停车，打印当前票价状态，尚未抵达站点票价为空；</li>
  <li>经过循环后回到站点 0，通过回车或其他操作停车，打印当前票价状态，如图 1(d) 所示。</li>
</ol>

<h2 id="解决方案">解决方案</h2>

<h3 id="问题分析">问题分析</h3>

<p>  解决公交计费问题，首先要将图 1 中给出的信息进行集成，可得如下图 2。其中，站点间的橙色数字为相邻站点间距离，红色数字为几个关键（0~2 km，2~3 km 和 3~4 km 的阈值站点）站点与出发站点 0 之间的<strong>有效距离</strong>。</p>

<p><img src="https://i.lisz.top/blog/DD2KNn.webp" alt="图 2. 信息集成后的公交路线图。 The route including the distances and some importance valid distances." /></p>

<p>  其实整个问题的核心就在于对<strong>有效距离</strong>的理解。从题干可知，有效距离并非是实际行进距离。这主要是因为给出的公交路线是环线而非直线，即出发站点与结束站点为同一站点。除此之外，刚开始的 1~3 与最后的 20~18 三个站点是重合的。根据给出的例子解释，我们可以将这里的“<strong>有效距离</strong>”粗略定义为“<strong>上车站点与下车站点在公交路线上正反距离的最小值</strong>”。我们不妨从以下示例中进一步加深对于“<strong>有效距离</strong>”的理解：（~ 表示“大约”）</p>

<ul>
  <li><strong>例 1</strong>：上车站点为站点 3，下车站点为站点 17。因为站点 3 与站点 18 重合，所以有效距离等同于站点 17 和 18 之间的距离 0.45 km。</li>
  <li><strong>例 2</strong>：上车站点为站点 5，下车站点为站点 18。如例 1 方式计算可得有效距离为 0.85 km。</li>
  <li><strong>例 3</strong>：上车站点为站点 4，下车站点为站点 17。虽然按照路线实际行进距离很远，但是实际两站之间路线上最短距离大约为 0.45 km，即有效距离为 ~0.45 km。</li>
  <li><strong>例 4</strong>：上车站点为站点 5，下车站点为站点 15。如例 2 方式计算可得有效距离为 ~1.6 km。</li>
  <li><strong>例 5</strong>：上车站点为站点 6，下车站点为站点 14。按照图中方向实际行进距离计算，可知正向距离为 2.75 km，按照路线上最短反向距离为 ~2.25 km，因此有效距离为 ~2.25 km。</li>
</ul>

<p>得出总结：</p>

<ul>
  <li>从例 1、2 可以看出，当上车站点和下车站点分别在重合直线和循环圈上时，位于重合直线上的站点需要注意切换到对应站点进行双重计算正反向距离，从而得到正确的有效距离。</li>
  <li>从例 3~5 可以看出，当上车站点和下车站点均在循环圈上时，计算反向距离不涉及直线站点（即跨过出发站点 0）。即使站点 17 到站点 4 的实际行进路线不存在，也需以站点 17 到站点 4 闭合的循环圈来进行计算反向距离。</li>
</ul>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 为何不跨过出发站点 0 计算反向距离？ </div> </div> <div class="content"> <p>  题干中给出信息“<strong>公交从站点 0 出发最终回到站点 0 并停止运行</strong>”，鉴于任何跨过出发站点 0 计算的距离实际上只可能由两辆公交车完成，不可能出现在一辆公交的票价计算方式中，当只在循环圈上的站点上下车时应该不考虑直线上的站点（0~3、18~20）。</p>

<p>  说句题外话，如例 3~5 所示，可能直接走过去还更快更方便，而非坐这趟公交。</p>



 </div> </div>
<h3 id="算法描述">算法描述</h3>

<h4 id="变量声明">变量声明</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: center">变量名</th>
      <th style="text-align: center">变量类型</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">distances</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">站点列表，[0, 0.2, 0.3, …]</td>
    </tr>
    <tr>
      <td style="text-align: center">currentStop</td>
      <td style="text-align: center">int</td>
      <td style="text-align: left">当前站点编号，0</td>
    </tr>
    <tr>
      <td style="text-align: center">lineStops</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">直线站点，[1, 2, 3, 18, 19, 20]</td>
    </tr>
    <tr>
      <td style="text-align: center">circleStops</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">循环圈站点，[4, 5, …, 17]</td>
    </tr>
    <tr>
      <td style="text-align: center">ticketBase</td>
      <td style="text-align: center">float</td>
      <td style="text-align: left">基础票价，190.00</td>
    </tr>
    <tr>
      <td style="text-align: center">ticketStep</td>
      <td style="text-align: center">float</td>
      <td style="text-align: left">票价梯度，50.00</td>
    </tr>
    <tr>
      <td style="text-align: center">ticketUnit</td>
      <td style="text-align: center">str</td>
      <td style="text-align: left">票价单位，JPY</td>
    </tr>
    <tr>
      <td style="text-align: center">baseDistance</td>
      <td style="text-align: center">float</td>
      <td style="text-align: left">基础距离，2.00</td>
    </tr>
    <tr>
      <td style="text-align: center">stepDistance</td>
      <td style="text-align: center">float</td>
      <td style="text-align: left">基础距离，1.00</td>
    </tr>
    <tr>
      <td style="text-align: center">distanceUnit</td>
      <td style="text-align: center">str</td>
      <td style="text-align: left">距离单位，km</td>
    </tr>
    <tr>
      <td style="text-align: center">validDistances</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">有效距离，长度为 21，默认值为 None</td>
    </tr>
    <tr>
      <td style="text-align: center">prices</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">票价，长度为 21，默认值为 None</td>
    </tr>
    <tr>
      <td style="text-align: center">validStops</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">有效站点，经过站点时将编号添加到列表里，默认为 [0]</td>
    </tr>
  </tbody>
</table>

<h4 id="步骤描述">步骤描述</h4>

<p>  程序整体步骤：</p>

<ol>
  <li>初始化变量，当前站点编号为 0，询问是否启动；接受到启动指令（回车）后开始行进（提示）。</li>
  <li>遇到停车指令（回车）后，切换站点编号为下一站点（+1），添加站点编号到 validStops。</li>
  <li>循环计算 validStops 中各站点的有效距离 validDistances（具体见下）。</li>
  <li>循环计算各站点的票价同时更新 prices。</li>
  <li>打印计费矩阵。</li>
  <li>接受到启动指令（回车）后继续行进（提示），重复 2~5 步骤直至重新回到站点 0。</li>
  <li>打印到达终点站提示信息，结束程序。</li>
</ol>

<p>  计算任意两个上下车站点间的有效距离的步骤：</p>

<ol>
  <li>已知上车站点 a 和下车站点 b，当两站点相同时有效距离为 0，如不同进入下一步骤。</li>
  <li>利用 lineStops 和 circleStops 两个变量判断 a 和 b 位于直线部分或循环圈部分。</li>
  <li>如果两站点都是直线部分，利用对称方式标准化为 1~3 的站点编号，直接计算之间距离为有效距离。</li>
  <li>如果两站点都是循环圈部分，利用 circleStops 进行循环遍历叠加计算正反距离，取较小的值为有效距离。</li>
  <li>如果一站点在直线部分、一站点在循环圈部分，对直线部分的站点（标准化后的 1~3 站点）计算正反距离，取较小的值为有效距离。</li>
  <li>返回有效距离。</li>
</ol>

<h3 id="程序模拟">程序模拟</h3>

<p>  根据以上思路，笔者采用 Python 实现了解决方案。源代码请见 <a href="https://gist.github.com/zhonger/3546f08c0fe5b3e4ea360288a6b15d42">Github Gist</a>。以下为程序模拟运行效果：</p>

<script src="https://asciinema.org/a/666775.js" id="asciicast-666775" async="true"></script>

<h2 id="结语">结语</h2>

<p>  虽然现有的公交线路大部分还是很规则的，不同时存在循环圈和直线的情况，计费也较为简单，但是思考特殊公交线路的计费方式也不失为一件有趣的事情。上面给出的分析和算法描述，也可以用其他编程语言实现，比如用前端编程语言就可以直接可视化整个公交计费过程。</p>

<h2 id="参考资料">参考资料</h2>

<ol>
  <li><a href="https://www.freecodecamp.org/chinese/news/dijkstras-shortest-path-algorithm-visual-introduction/">图文详解 Dijkstra 最短路径算法</a></li>
  <li><a href="https://zhangroup.aporc.org/images/files/1.pdf">周文峰等，《运筹与管理》，<strong>最优公交线路选择问题的数学模型及算法</strong>，2018</a></li>
  <li><a href="https://www.kantetsu.co.jp/cms/wp-content/uploads/2024/02/801e8420390b8e91fa42443e742d6c27.pdf">筑波大学循环线票价表</a></li>
</ol>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="algorithm" /><category term="algorithm" /><category term="算法" /><category term="program" /><category term="代码实现" /><category term="python" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">命令行工具开发指南——入门篇</title><link href="https://lisz.me/tech/cli/introduction.html" rel="alternate" type="text/html" title="命令行工具开发指南——入门篇" /><published>2024-05-29T17:15:00+09:00</published><updated>2024-05-29T17:15:00+09:00</updated><id>https://lisz.me/tech/cli/introduction</id><content type="html" xml:base="https://lisz.me/tech/cli/introduction.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  <strong>命令行工具</strong>（Command Line，Cli）作为我们日常开发常用的辅助性工具，几乎遍布于各种操作中。根据<strong>使用目的</strong>的不同大致可以分为以下几类：</p>

<ul>
  <li><strong>从模板中生成项目</strong>：比如使用 <code class="language-plaintext highlighter-rouge">npm init</code> 从空模版创建一个新的 NodeJS 项目，使用 <code class="language-plaintext highlighter-rouge">composer create-project laravel/laravel example-app</code> 创建一个全新的 Laravel 项目（PHP 项目）等。</li>
  <li><strong>启用开发者服务模式</strong>：比如使用 <code class="language-plaintext highlighter-rouge">python -m http.server 8000</code> 在 8000 端口开启一个临时 HTTP 服务器，使用 <code class="language-plaintext highlighter-rouge">bundle exec jekyll s</code> 在 4000 端口开启一个临时 Jekyll 服务器等。</li>
  <li><strong>特定功能交互</strong>：比如流行的 IP 信息查询工具 <a href="https://github.com/zu1k/nali">nali</a>、磁盘空间利用率和空余空间查询工具 <a href="https://github.com/muesli/duf">duf</a>、快速磁盘使用分析工具 <a href="https://github.com/dundee/gdu">gdu</a> 等。</li>
</ul>

<p>  其实任何编程语言都可以用来开发命令行工具，无论是常见的 Golang、Python、NodeJS、PHP、Java，还是 Rust、Ruby、C++、C 或者是古老的 Fortran 等。只是取决于所要实现的功能和具体的使用场景，开发者会采用合适的编程语言开发命令行工具。比如说，Linux 系统中包含了大量的命令行工具，基本上都是用 C 语言编写的，主要是因为 C 语言在 Linux 系统中的执行效率相对更高。对于一般高级编程语言，自带的包管理工具也是由自身高级编程语言编写的命令行工具。类似 Rust、Fortran 等编译型语言则需要通过编译生成<strong>二进制可执行文件</strong>后才能执行相应的任务。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 二进制可执行文件与源文件有何不同？ </div> </div> <div class="content"> <p>   二进制可执行文件是指源代码通过编译器编译成计算机可以直接识别的二进制码文件。二进制码文件是无法使用任何源码编辑器打开的，只能由操作系统调用执行或特别的二进制码查看器打开。一般来说，二进制可执行文件是很难跨越操作系统的，即针对不同的操作系统需要分别编译生成对应的二进制可执行文件。<u>尤其是当有其他静态库或者动态链接库依赖时，二进制可执行文件甚至无法跨主机运行</u>。 而源文件是可以在任何操作系统用源码编辑器打开的。大多时候商业公司为了保证源代码的商业版权，只会为用户提供应用的二进制可执行文件。（当然一般可能是包含图形用户界面的。）</p>



 </div> </div>
<h2 id="为何命令行而非图形界面">为何命令行而非图形界面</h2>

<p>  命令行可以说是操作系统应用和编程语言编写应用最基本的形式，图形（用户）界面（Graphic User Interface，GUI）则是在源代码的基础上提供可视化的交互方式、通过键鼠操作来降低用户使用的门槛。这也是为什么 Windows 操作系统比 Linux 操作系统更加流行的原因之一。<strong>但是有的时候，界面也有可能会成为用户学习和使用的累赘。</strong></p>

<h3 id="简单界面-vs-复杂界面">简单界面 vs 复杂界面</h3>

<p>  就拿代码编辑器来说，我们所熟知的“宇宙第一编辑器” Visual Studio 几乎支持所有编程语言，尤其是对于构建 C# 项目来说可以<strong>半代码半可视化修改</strong>。尽管这在很大程度上降低了开发者使用成本，但是学习 Visual Studio 编辑器本身的成本却很高。（说句老实话，笔者从大学本科开始接触 Visual Studio 到现在都没怎么学会使用，😂只会最基本的功能而已。）而且，在普通笔记本电脑上使用 Visual Studio 编辑器运行大型项目时，CPU 和内存资源极大可能会被大量占用，打开一个浏览器页面可能也很艰难。</p>

<p>  相比而言，同样由微软推出的 Visual Studio Code 则是简单界面的优秀代表。化繁为简，Visual Studio Code 本身仅支持最简单的功能：文件目录区、编辑区、终端区三部分布局，基本的代码高亮功能，插件功能，主题功能等。无论是 Python 开发者，还是 Golang 开发者，都能一打开直接上手，只是需要根据编程语言不同安装一些插件来提升开发效率而已。在系统占用资源方面，Visual Studio Code 比 Visual Studio 显著降低，尽管可能也会受安装插件的少量影响。当然有得也有舍，Visual Studio Code 中支持更多文件定义配置或命令行配置，对于没有学过 Linux 的用户可能会有点学习难度。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> Linux 哲学 </div> </div> <div class="content"> <p>  “一切皆文件”。任何系统、项目、工具都是由一系列的文件组成的，通过配置文件可以实现直接管理。</p>

<p>  虽然这是 Linux 系统设计的哲学思想，但其实是所有操作系统设计的哲学思想，只是顶层封装的程度有所不同。Windows 系统也是“一切皆文件”的，不然那些编辑器的配置都存在哪里了呢。相比 Linux 和 MacOS 系统而言，Windows 系统的顶层封装程度最高，用户对于底层文件的直接管理非常少，尤其是对系统级别的配置管理只能通过图形界面交互完成。MacOS 系统则是介于两者之间，顶层封装程度虽然高但也提供对大部分系统级别配置的直接管理，即可以通过修改文件来实现管理。尽管依旧存在有些系统级别配置难以直接修改，比如说操作系统启动项。</p>



 </div> </div>
<h3 id="更简单的命令行">更简单的命令行</h3>

<p>  界面在执行系列任务时一般需要多步操作，一顿点点点之后才能完成。当然如果图形界面和功能设计的比较合理的话，可能也只需要一步操作。当我们需要进行批量操作时，即使图形界面只需要一步操作，依旧需要一顿点点点。命令行则没有这种问题，只需要简单写个有循环的脚本即可循环调用命令行工具批量执行。</p>

<p>  另外，命令行工具仅在执行时会占用系统资源，一旦完成即可完全释放。图形界面应用一般需要常驻后台，虽然优化得好的时候所占用的系统资源也可忽略不计，但是还是会有后台进程的。</p>

<p>  尽管命令行工具极少会有显式的界面交互，但是也可以在终端提供非常丰富的命令行交互、功能解释、自动补全、自动建议等。用户使用起来一般没有太大问题，只需要调用子命令和参数即可实现操作。</p>

<h2 id="命令行工具开发">命令行工具开发</h2>

<h3 id="设计标准和规范">设计标准和规范</h3>

<p>  命令行工具开发通常依据两个标准和规范进行：POSIX (Protable Operating System Interface，可移植操作系统接口) 标准和 GNU (GNU’s Not Unix) 项目。POSIX 标准是 IEEE 为维护操作系统间适配性而制定的一系列标准，其中一个标准定义了命令行程序的语法和语义。GNU 旨在创建与 Unix 兼容的自由软件，其中一个子项目 <a href="https://www.gnu.org/software/coreutils/">GNU Coreutils</a> 提供了很多常用的命令行程序，比如 <code class="language-plaintext highlighter-rouge">ls</code>、<code class="language-plaintext highlighter-rouge">cp</code> 和 <code class="language-plaintext highlighter-rouge">mv</code> 等。据此为命令行程序建立了以下的设计标准和规范：</p>

<ul>
  <li>单字母标志 (single-letter flag) 以一个短横线 <code class="language-plaintext highlighter-rouge">-</code> 开始，且可以合并使用：比如 <code class="language-plaintext highlighter-rouge">-d</code> (全称 <code class="language-plaintext highlighter-rouge">--debug</code>) 和 <code class="language-plaintext highlighter-rouge">-v</code> (全称 <code class="language-plaintext highlighter-rouge">--version</code>) 合并使用 <code class="language-plaintext highlighter-rouge">-dv</code> 来以调试模式输出命令行版本号。</li>
  <li>长标志 (long flag) 以两个短横线 <code class="language-plaintext highlighter-rouge">--</code> 开始，但无法合并使用：比如 <code class="language-plaintext highlighter-rouge">--debug</code> 或 <code class="language-plaintext highlighter-rouge">--version</code> 可以被命令行正常解析，但 <code class="language-plaintext highlighter-rouge">--debugversion</code> 无法被正常解析。</li>
  <li>选项 (Options) 跟在单字母标志后没有分隔符，但跟在长标志后使用等号 <code class="language-plaintext highlighter-rouge">=</code> 来分隔标志和选项值：比如 <code class="language-plaintext highlighter-rouge">-n example</code> 和 <code class="language-plaintext highlighter-rouge">--name=example</code> 分别为单字母标志和长标志的选项用法，二者完全等价。</li>
  <li>参数 (Args) 跟在标志或选项之后时没有任何分隔符，仅有空格：比如 <code class="language-plaintext highlighter-rouge">curl -o out.html https://www.google.com</code> 中的 <code class="language-plaintext highlighter-rouge">https://www.google.com</code> 是参数，一般用法类似 <code class="language-plaintext highlighter-rouge">curl [Options] &lt;Arg&gt;</code>。</li>
  <li>子命令 (Sub command) 与主命令之间没有分隔符，仅有空格：比如 <code class="language-plaintext highlighter-rouge">git commit</code> 中 <code class="language-plaintext highlighter-rouge">git</code> 是主命令、<code class="language-plaintext highlighter-rouge">commit</code> 是子命令。</li>
  <li>单独的两个短横线 <code class="language-plaintext highlighter-rouge">--</code>（后不接标志）表示标志或选项的结束和参数的开始：比如 <code class="language-plaintext highlighter-rouge">rm -- -f</code> 中的 <code class="language-plaintext highlighter-rouge">-f</code> 表示的是要删除的文件 <code class="language-plaintext highlighter-rouge">-f</code>，而不是强制删除文件的选项。</li>
</ul>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 提示 </div> </div> <div class="content"> <p>  按照以上设计标准和规范开发的命令行工具使用体验会与常用的命令保持一致，对于用户来说非常容易上手，这也是制定设计标准和规范的主要原因。</p>



 </div> </div>
<h3 id="功能设计">功能设计</h3>

<p>  核心功能设计主要是指命令行工具所支持的子命令、参数、选项设计。其中，子命令表示功能集合，参数表示输入输出变量，选项表示功能的微调。如下所示为笔者开发的命令行工具 <a href="../../../tech/project/pictl.html">pictl</a> （基于 Python 语言开发）的帮助信息。目前提供四个子命令：<code class="language-plaintext highlighter-rouge">config</code>（配置基本信息），<code class="language-plaintext highlighter-rouge">compress</code>（压缩任意图片为 <code class="language-plaintext highlighter-rouge">webp</code> 格式）,<code class="language-plaintext highlighter-rouge">upload</code>（上传图片）和 <code class="language-plaintext highlighter-rouge">cup</code>（压缩并上传图片）。全局只支持 <code class="language-plaintext highlighter-rouge">-h</code>（<code class="language-plaintext highlighter-rouge">--help</code>）打印帮助信息和 <code class="language-plaintext highlighter-rouge">-V</code>（<code class="language-plaintext highlighter-rouge">--version</code>）打印版本信息两个选项。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl
Usage: pictl <span class="o">[</span>OPTIONS] COMMAND <span class="o">[</span>ARGS]...

  A <span class="nb">command </span>line tool <span class="k">for </span>image processing and uploading <span class="o">(</span>ex. S3-type<span class="o">)</span><span class="nb">.</span>

  Now it supports:
    - transformation from other image types to <span class="sb">`</span>webp<span class="sb">`</span> image as well as
      image compression.
    - image file uploading to AWS S3 or Cloudflare R2.

Options:
  <span class="nt">-V</span>, <span class="nt">--version</span>  Show the pictl version.
  <span class="nt">-h</span>, <span class="nt">--help</span>     Show this message and exit.

Commands:
  compress  Compress any image into <span class="sb">`</span>webp<span class="sb">`</span> image.
  config    Operations <span class="k">for </span>the config file <span class="sb">`</span>~/.pictlrc<span class="sb">`</span><span class="nb">.</span>
  cup       Compress image and upload to remote storage <span class="o">(</span>compress and...
  upload    Upload the file to remote storage.
</code></pre></div></div>

<h4 id="子命令">子命令</h4>

<p>  <strong>子命令是否越少越好或者越多越好？亦或是不多不少比较好？</strong>其实，根据实际功能需求的不同子命令的数量会有很大的差异。比如上面提到的 pictl 目前所支持的子命令只有 4 个，curl 不支持子命令但支持选项超过 20 个，git 支持的常用子命令多达 22 个（如下所示，实际子命令可能接近 100 个），docker 支持的子命令超过 30 个。子命令实际上是可以多层迭代调用的，即可以存在多层级。但是在功能设计时，一般将对同一对象操作的功能归类到同一子命令下面，形成多层级子命令。当然为了简化子命令的层级调用，最多的实践方式就是类似于 git 中的<strong>用选项来代替多层的子命令</strong>。比如 <code class="language-plaintext highlighter-rouge">git branch</code> 子命令是对分支（branch）的列举（<code class="language-plaintext highlighter-rouge">git branch -l</code>）、创建（<code class="language-plaintext highlighter-rouge">git branch &lt;name&gt;</code>）和删除（<code class="language-plaintext highlighter-rouge">git branch -d &lt;name&gt;</code>）的功能集合。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>git <span class="nt">-h</span>
usage: git <span class="o">[</span><span class="nt">-v</span> | <span class="nt">--version</span><span class="o">]</span> <span class="o">[</span><span class="nt">-h</span> | <span class="nt">--help</span><span class="o">]</span> <span class="o">[</span><span class="nt">-C</span> &lt;path&gt;] <span class="o">[</span><span class="nt">-c</span> &lt;name&gt;<span class="o">=</span>&lt;value&gt;]
           <span class="o">[</span><span class="nt">--exec-path</span><span class="o">[=</span>&lt;path&gt;]] <span class="o">[</span><span class="nt">--html-path</span><span class="o">]</span> <span class="o">[</span><span class="nt">--man-path</span><span class="o">]</span> <span class="o">[</span><span class="nt">--info-path</span><span class="o">]</span>
           <span class="o">[</span><span class="nt">-p</span> | <span class="nt">--paginate</span> | <span class="nt">-P</span> | <span class="nt">--no-pager</span><span class="o">]</span> <span class="o">[</span><span class="nt">--no-replace-objects</span><span class="o">]</span> <span class="o">[</span><span class="nt">--bare</span><span class="o">]</span>
           <span class="o">[</span><span class="nt">--git-dir</span><span class="o">=</span>&lt;path&gt;] <span class="o">[</span><span class="nt">--work-tree</span><span class="o">=</span>&lt;path&gt;] <span class="o">[</span><span class="nt">--namespace</span><span class="o">=</span>&lt;name&gt;]
           <span class="o">[</span><span class="nt">--super-prefix</span><span class="o">=</span>&lt;path&gt;] <span class="o">[</span><span class="nt">--config-env</span><span class="o">=</span>&lt;name&gt;<span class="o">=</span>&lt;envvar&gt;]
           &lt;<span class="nb">command</span><span class="o">&gt;</span> <span class="o">[</span>&lt;args&gt;]

These are common Git commands used <span class="k">in </span>various situations:

start a working area <span class="o">(</span>see also: git <span class="nb">help </span>tutorial<span class="o">)</span>
   clone     Clone a repository into a new directory
   init      Create an empty Git repository or reinitialize an existing one

work on the current change <span class="o">(</span>see also: git <span class="nb">help </span>everyday<span class="o">)</span>
   add       Add file contents to the index
   <span class="nb">mv        </span>Move or rename a file, a directory, or a symlink
   restore   Restore working tree files
   <span class="nb">rm        </span>Remove files from the working tree and from the index

examine the <span class="nb">history </span>and state <span class="o">(</span>see also: git <span class="nb">help </span>revisions<span class="o">)</span>
   bisect    Use binary search to find the commit that introduced a bug
   diff      Show changes between commits, commit and working tree, etc
   <span class="nb">grep      </span>Print lines matching a pattern
   log       Show commit logs
   show      Show various types of objects
   status    Show the working tree status

grow, mark and tweak your common <span class="nb">history
   </span>branch    List, create, or delete branches
   commit    Record changes to the repository
   merge     Join two or more development histories together
   rebase    Reapply commits on top of another base tip
   reset     Reset current HEAD to the specified state
   switch    Switch branches
   tag       Create, list, delete or verify a tag object signed with GPG

collaborate <span class="o">(</span>see also: git <span class="nb">help </span>workflows<span class="o">)</span>
   fetch     Download objects and refs from another repository
   pull      Fetch from and integrate with another repository or a <span class="nb">local </span>branch
   push      Update remote refs along with associated objects

<span class="s1">'git help -a'</span> and <span class="s1">'git help -g'</span> list available subcommands and some
concept guides. See <span class="s1">'git help &lt;command&gt;'</span> or <span class="s1">'git help &lt;concept&gt;'</span>
to <span class="nb">read </span>about a specific subcommand or concept.
See <span class="s1">'git help git'</span> <span class="k">for </span>an overview of the system.
</code></pre></div></div>

<p>  功能设计中对子命令的设计是由核心功能驱动的。在条件允许的情况下，尽可能压缩子命令列表是有利于用户上手使用的。为了命令行工具使用时命令不会过长，建议提供比较常用的默认选项值从而减少用户自定义的可能性。当然，对全部选项的单字母标志支持也是有效缩短命令长度的方法之一。除此之外，提供配置文件也是非常可取的方法。<code class="language-plaintext highlighter-rouge">git</code>、<code class="language-plaintext highlighter-rouge">curl</code>、<code class="language-plaintext highlighter-rouge">wget</code>、<code class="language-plaintext highlighter-rouge">docker</code> 等都提供对应的配置文件 <code class="language-plaintext highlighter-rouge">.gitconfig</code>、<code class="language-plaintext highlighter-rouge">.curlrc</code>、<code class="language-plaintext highlighter-rouge">.wgetrc</code> 和 <code class="language-plaintext highlighter-rouge">.dockerrc</code> 进行全局配置定义，当然 <code class="language-plaintext highlighter-rouge">pictl</code> 也提供 <code class="language-plaintext highlighter-rouge">.pictlrc</code> 配置文件。</p>

<h4 id="代码架构">代码架构</h4>

<p>  尽管不同编程语言因为自身原因（编译型或解析型语言，面向对象或面向过程等），可能会有不同的代码架构偏好，我们可能依然可以采用一个宽泛且可行的通用代码架构思路——<strong>面向功能开发</strong>。这里的功能可以是一个操作或者一个对象，比如说压缩图片这样一个功能，主要是将输入图片转换成想要的图片格式输出。除此之外，可能还可以提供压缩质量控制、尺寸控制、自动重命名、自动加水印等微调功能。这些微调功能虽然实际上可以完全独立，但由于是压缩图片功能的附属功能，最好采用选项调用的方式来实现。代码架构上，子命令调用对应的函数会成为<strong>顶级函数</strong>。其他微调功能虽然是独立函数或对象，<u>但仅在子命令函数中被调用</u>。实际开发过程中，微调功能并非一开始就包括所有，大部分会作为一些特性逐步增加到主代码中。这意味着，对用户来说新增一个微调功能仅仅多了一个子命令下的选项支持，不需要重新学习和适应。</p>

<p>  如果压缩图片功能的基础（图片转换）需要自行编写代码，那么可能需要考虑到很多种图片格式的相互转换，这在具体代码实践中是非常麻烦的。比较可行的方法之一是，可以采用一种图片格式作为中间标准格式，每次新增一种图片格式的支持只需要增加与中间标准格式的相互转换即可。当然这里采用的中间标准格式可能是需要高保真的（或者高分辨率的），避免在用了中间标准格式转换之后图片质量自动下降。</p>

<h3 id="错误处理和自动建议">错误处理和自动建议</h3>

<p>  当我们打算开发一款命令行工具时，除了核心功能是必不可少的，错误处理和自动建议也是需要考虑在内的。了解这点最简单的办法就是从实例中学习。如下所示，是将 git 提交修改（commit）的命令 <code class="language-plaintext highlighter-rouge">git commit</code> 故意打成为 <code class="language-plaintext highlighter-rouge">git commi</code> 的输出结果。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>git commi
git: <span class="s1">'commi'</span> is not a git command. See <span class="s1">'git --help'</span><span class="nb">.</span>

The most similar commands are
 commit
 column
 config
</code></pre></div></div>

<p>  当命令行工具接收到用户输入时，首先需要做的就是对输入的合法性进行验证：一方面，是否存在不可用的子命令或非法使用（比如错误迭代调用）；另一方面，尝试解析参数并验证完整性。这两部分的验证会尽可能地将错误的原因和可能有用的建议提示给用户。类似上面，命令行工具会提示用户使用的子命令不存在，请使用 <code class="language-plaintext highlighter-rouge">git --help</code> 了解更多。另外，会将输入的子命令字符串与所有合法的子命令字符串进行对比，根据相似性大小排列向用户自动建议。至于对选项的解析相对来说可以比较宽容一点，即直接忽略不合法的选项声明、仅读取合法的选项声明，因此可以不返回相关错误提醒及帮助。</p>

<p>  当子命令、参数、选项均通过验证之后，命令行工具的功能代码执行时也会发生错误。如下所示，在一个非 git 项目文件夹内执行 <code class="language-plaintext highlighter-rouge">git commit</code> 时，命令行工具会将具体的错误直接提示：当前目录或任何父目录不是一个 git 项目，不存在 <code class="language-plaintext highlighter-rouge">.git</code> 文件夹。这里需要注意的是，通常我们可能对错误或异常的处理会直接使用编程语言本身提供的方式，比如 Python 语言中的 <code class="language-plaintext highlighter-rouge">raise ValueError("'element' parameter is not defined.")</code>。当然这种错误处理本身没有任何问题，只不过同时还会输出错误发生的代码位置等其他与用户使用无关的信息，尽管这种信息在开发过程中有利于开发者调试代码。出于为用户考虑，错误处理信息默认应该以简单可读的方式打印出来、且仅限于提示关键信息。如果用户或者开发者想要了解更多，可以通过 <code class="language-plaintext highlighter-rouge">-v</code> 或者 <code class="language-plaintext highlighter-rouge">--verbose</code> 选项来打印更多调试信息。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>git commit
fatal: not a git repository <span class="o">(</span>or any of the parent directories<span class="o">)</span>: .git
</code></pre></div></div>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> -v 和 -V </div> </div> <div class="content"> <p>  通常来说，<code class="language-plaintext highlighter-rouge">-v</code>（<code class="language-plaintext highlighter-rouge">--verbose</code>）和<code class="language-plaintext highlighter-rouge">-V</code>（<code class="language-plaintext highlighter-rouge">--version</code>）会被认为是不同的选项，分别用于开启调试模式和打印版本信息。当用户发现命令行工具使用出现不可预知的问题（错误提示与实际原因不符或其他不在开发者知晓范围内的问题）时，需要开启调试模式来排除本地环境的问题，同时也可能在向开发者反馈问题时提供足够的信息来帮助定位问题的原因。版本信息通常也是提交反馈问题时所需的必要信息。</p>



 </div> </div>
<h3 id="技术选型">技术选型</h3>

<p>  技术选型指的是<strong>用哪种编程语言以及哪种框架来实现命令行工具</strong>。<strong>第一种</strong>是从开发者自身熟悉和掌握的编程语言出发，尽可能降低编程语言上的学习成本。不过对于已经掌握一门或多门编程语言的开发者来说，学习新编程语言可能也不是件难事。<strong>第二种</strong>是从应用场景出发：如果是开发为机器学习应用的前置或后置步骤的数据准备、数据处理、可视化等功能的命令行工具，采用 Python 语言可能会更加方便有效；如果是开发包含与操作系统交互的网络分析、磁盘分析等功能的命令行工具，采用 Rust 或者 Golang 语言可能会比较得心应手；如果是开发与平台接口交互（如 Web API 调用）的命令行工具，采用 NodeJS 语言可能适配性更佳。详细请查看参考资料 [1-5]。</p>

<h2 id="结语">结语</h2>

<p>  诚然，命令行工具并非是所有用户的喜爱，但的确是最小化操作步骤、提升效率的方式之一。以上所述的命令行工具开发指南入门篇大部分是在理论层面上的，至于在不同编程语言上的实践后续也计划展开：</p>

<ul>
  <li>《命令行工具开发指南 —— Python 实践篇》</li>
  <li>《命令行工具开发指南 —— Rust 实践篇》</li>
  <li>《命令行工具开发指南 —— Golang 实践篇》</li>
  <li>《命令行工具开发指南 —— NodeJS 实践篇》</li>
</ul>

<p>  有关于命令行工具开发进阶的依赖管理、编译构建、信号和日志处理、用户输入验证、自动补全（Auto Completion）、文档、测试和发布等也将在实践篇中分别具体阐述。</p>

<h2 id="参考资料">参考资料</h2>

<ol>
  <li><a href="https://juejin.cn/post/7178666619135066170">快手数平前端团队 – 掌握 Node CLI 工具开发，为团队研发提效！</a></li>
  <li><a href="https://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html">阮一峰的网络日志 – Node.js 命令行程序开发教程</a></li>
  <li><a href="https://suibianxiedianer.github.io/rust-cli-book-zh_CN/README_zh.html">Rust 中的命令行应用</a></li>
  <li><a href="https://pythonguidecn.readthedocs.io/zh/latest/scenarios/cli.html">命令行应用 - Python 最佳实践指南</a></li>
  <li><a href="https://tonybai.com/2023/03/25/the-guide-of-developing-cli-program-in-go/">Tony Bai – Go 开发命令行程序指南</a></li>
  <li><a href="https://en.wikipedia.org/wiki/POSIX">Wikipedia – POSIX</a></li>
</ol>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="cli" /><category term="command line" /><category term="命令行" /><category term="develop" /><category term="开发" /><category term="tool" /><category term="工具" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">图片处理及上传命令行工具 —— PICTL</title><link href="https://lisz.me/tech/project/pictl.html" rel="alternate" type="text/html" title="图片处理及上传命令行工具 —— PICTL" /><published>2023-06-13T13:41:01+09:00</published><updated>2023-06-13T13:41:01+09:00</updated><id>https://lisz.me/tech/project/pictl</id><content type="html" xml:base="https://lisz.me/tech/project/pictl.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  自从博客从 WordPress 转到静态博客（先 Hexo 后 Jekyll）之后，文章的图片处理、图片上传就成了一个不大顺畅的事情。最先是使用了 <a href="https://vgy.me">vgy.me</a> 提供的免费图床，支持直接从剪切板上传，操作上相对比较简单，也不需要任何本地存储。不过后来 vgy.me 进行了升级改版，原先的剪切板上传功能也不再支持了，偶尔还出现图片像素被降低、丢失的问题。同时，考虑到 WebP 格式可能会适合博客使用，而 vgy.me 还不支持该格式。于是开始切换到 “对象存储 + CDN” 的方案。本地准备好的 PNG 格式图片，先通过 <a href="https://developers.google.com/speed/webp/">cwebp</a> 命令行转成 WebP 格式图片，再通过 <a href="https://github.com/gee1k/uPic">uPic</a> 工具修改文件名后上传到对象存储。由于此前采用的是腾讯云的 COS 对象存储和 CDN，经常面临着 SSL 证书更新等琐碎的事情。这样一来，整体的效率实际上并不高，只能说勉强接受。</p>

<h3 id="现有工具及存储考察">现有工具及存储考察</h3>

<p>  为此，也对其他工具和对象存储进行了考察。</p>

<p>  <a href="https://github.com/Molunerfinn/PicGo">PicGo</a> 是一款集客户端 UI 和命令行于一体的图片上传工具，虽然可以利用命令串联的方式简单将图片格式转换和上传两步变成一步，但还是有那么点不舒服的地方，比如 PicGo 不提供文件名修改（为固定长度随机字符串）的特性。而 uPic 本身关注于客户端桌面交互，不提供命令行接口。</p>

<p>  至于对象存储，国内各家云服务厂商提供的都需要自行手动更新 SSL 证书，且收费。尽管腾讯云 CDN 目前老用户可以每月领券免费使用，但一旦忘记就开始被收费了。实际上也有逐步转向收费的趋势。国外各家云服务厂商基本上都需要收费使用对象存储或者 CDN，大差不差。</p>

<p>  当然，网上一直有一种 “Backblaze B2 + Cloudflare” 的解决方案。由于 B2 本身存储和读写操作都有免费额度，流量需要收费，且无法自定义域名，而 B2 和 Cloudflare 同属于宽带联盟（内部流量免费），Cloudflare 还提供 URL 重写功能，这种解决方案一时成为了潮流。不过，B2 的访问链接是中间带着一串参数，重写之后仍然还是有部分参数，最终的 URL 并不是那么朴素。总的来说，还是有那么点别扭。</p>

<h3 id="r2-的出现">R2 的出现</h3>

<p>  因此观望了许久，直到 Cloudflare 推出了 R2。R2 是一款对标 AWS S3 的产品，基于 Cloudflare 对宽带联盟的承诺而构建，为存储对象提供零成本出口，实际上就是免费 CDN。由于 Cloudflare 本身就是一家 CDN 服务商，自定义对象存储访问域名、自动生成部署 SSL 证书这些事情就变得轻而易举了。R2 提供 10GB 的免费存储，读操作每月免费 1000 万次，写、更新和删除操作每月免费 100 万次。这对于一般的静态博客来说，应该完全足够了，即使超出了免费额度，超出部分收费也相较其他云服务厂商便宜一些。</p>

<p>  对笔者而言，R2 产品将对象存储和 CDN 两款产品有机地结合起来，解决了静态博客图片对外访问前的“最后一公里”。于是想从 COS 迁移到 R2，无奈 uPic 这个时候卖了个“破绽”。uPic 似乎在开始转向商业收费，Github 上不再发布新版本，而仅在 Appstore 上继续更新对 R2 的支持。当然，Appstore 上的 uPic 是收费的（4.99 美元，其实也不贵）。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  R2 虽然说是对标 AWS S3，但是并没有完整实现所有 API 接口，所以目前 Github 上发布的 uPic 版本无法兼容。尽管可以自行通过修改 uPic 的开源代码来实现兼容，但毕竟修改别人的代码的成本还是有一点高的。</p>



 </div> </div>
<h2 id="开个新项目">开个新项目</h2>

<p>  在充分梳理个人使用需求之后，还是决定开个新项目——开发一款简单易用的命令行工具 PICTL（全称 <strong>Pi</strong>cture <strong>C</strong>on<strong>t</strong>ro<strong>l</strong>）。该工具须具备以下特性：</p>

<ul>
  <li>考虑图片的存储空间大小和网页加载时长，所有图片应被压缩并转成 WebP 格式；</li>
  <li>所有图片的名称应被修改成一个固定长度随机字符串，并支持上传到类 S3 的对象存储；</li>
  <li>简单易用，命令行优先，无网页或桌面交互界面；</li>
  <li>（可选）自动添加水印；</li>
  <li>（可选）根据设定自动调整图片尺寸；</li>
  <li>（可选）可以直接从剪切板读取图片。</li>
</ul>

<h2 id="架构设计">架构设计</h2>

<p>  根据所列出的特性，这款命令行工具主要的模块就是：<strong>图片处理模块</strong>和<strong>上传模块</strong>，架构如下图所示。</p>

<p><img src="https://i.lisz.top/blog/Gl8qhI.webp" alt="PICTL 架构图 The architecture of PICTL" /></p>

<p>  图片处理模块包括图片压缩、图片格式转换、图片水印、尺寸调整等功能，可以进行无缝横向扩展。上传模块主要包括对于三种存储方式的支持：<strong>第一类</strong>是最为广泛的类 S3 对象存储，如 R2、AWS S3 及国内外云服务厂商各种对象存储等，<strong>第二类</strong>是目前仍然在博客中广泛流行的第三方图床，如 <a href="https://sm.ms">SM.MS</a>、<a href="https://vgy.me">vgy.me</a>、<a href="https://github.com/chevereto/chevereto">chevereto</a> 类型图床等，<strong>第三类</strong>是自托管 Git 平台和 FTP 平台。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 特此声明 </div> </div> <div class="content"> <p>  鉴于 Github、Gitlab、Gitee 等公共代码托管平台均禁止把 Git 仓库作为图床的做法，本工具仅支持自建 Git 平台，如自建 Gitlab 和 Gitlab Pages。如试图上传到公共代码托管平台，本工具会自行中断上传。</p>



 </div> </div>
<p>  本工具由于仅支持命令行，所以计划用 Python 和 <a href="https://click.palletsprojects.com/">Click</a> 进行开发。虽然借助 <a href="https://google.github.io/python-fire/">Google Fire</a> 也可以快速开发命令行工具，但其使用方式上与原生 *nix 的命令行工具有所不同。相比之下，用 Click 开发可能会麻烦一点，但能够开发出更类原生的 Python 命令行工具。当然，目前开发上还是比较喜欢使用 Rust 或者 Go 语言来开发高性能的命令行工具。不过，本工具只是做一些非常简单的工作，没有性能上的瓶颈，用 Python 开发也足够了。</p>

<h2 id="开发计划">开发计划</h2>

<p>  请移步 <a href="https://github.com/users/zhonger/projects/5">Github Project</a> 了解更多。</p>

<h2 id="使用方法">使用方法</h2>

<p>  目前，PICTL 已经在 <a href="https://github.com/zhonger/pictl/releases">Github</a> 和 <a href="https://pypi.org/project/pictl/">PyPI</a> 同步发布了 v0.1.0 版本。该版本实现了以上架构图中的基本功能，即特性中的前三点必要项。接下来介绍一下如何安装和使用本工具。</p>

<h3 id="安装">安装</h3>

<p>  目前支持两种安装方式：<strong>源码安装</strong>和 <strong>PIP 安装</strong>，后续将增加对于 brew 的支持。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  安装前，请务必确保已满足 Python 版本高于 3.10 的条件。</p>



 </div> </div>
<h4 id="源码安装">源码安装</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/zhonger/pictl
<span class="nb">cd </span>pictl
pip3 <span class="nb">install</span> <span class="nb">.</span>
</code></pre></div></div>

<h4 id="pip-安装">PIP 安装</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install </span>pictl
</code></pre></div></div>

<h3 id="使用">使用</h3>

<h4 id="显示版本">显示版本</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl <span class="nt">-V</span>
PICTL 0.1.0
</code></pre></div></div>

<h4 id="列举所有支持命令">列举所有支持命令</h4>

<p>  目前 v0.1.0 版本包含四个子命令：config（配置管理），compress（图片处理），upload（上传文件）和 cup（一键式压缩、转换、上传）。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl
Usage: pictl <span class="o">[</span>OPTIONS] COMMAND <span class="o">[</span>ARGS]...

  A <span class="nb">command </span>line tool <span class="k">for </span>image processing and uploading <span class="o">(</span>ex. S3-type<span class="o">)</span><span class="nb">.</span>

  Now it supports:
    - transformation from other image types to <span class="sb">`</span>webp<span class="sb">`</span> image as well as
      image compression.
    - image file uploading to AWS S3 or Cloudflare R2.

Options:
  <span class="nt">-V</span>, <span class="nt">--version</span>  Show the pictl version.
  <span class="nt">-h</span>, <span class="nt">--help</span>     Show this message and exit.

Commands:
  compress  Compress any image into <span class="sb">`</span>webp<span class="sb">`</span> image.
  config    Operations <span class="k">for </span>the config file <span class="sb">`</span>~/.pictlrc<span class="sb">`</span><span class="nb">.</span>
  cup       Compress image and upload to remote storage <span class="o">(</span>compress and...
  upload    Upload the file to remote storage
</code></pre></div></div>

<h4 id="config-子命令">config 子命令</h4>

<p>  config 子命令包含 add（添加配置）、delete（删除配置）、info（查看所有配置）和 init（初始化配置）四种操作。使用本工具需要先执行初始行配置操作，再执行其他配置操作。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config
Usage: pictl config <span class="o">[</span>OPTIONS] COMMAND <span class="o">[</span>ARGS]...

  Operations <span class="k">for </span>the config file <span class="sb">`</span>~/.pictlrc<span class="sb">`</span><span class="nb">.</span>

Options:
  <span class="nt">-h</span>, <span class="nt">--help</span>  Show this message and exit.

Commands:
  add     Add configs to the config file.
  delete  Delete config group from the config file.
  info    Check the configs.
  init    Initialize config file with default configs.
</code></pre></div></div>

<p>  如下所示，使用 <code class="language-plaintext highlighter-rouge">pictl config init</code> 命令初始化配置。第二次执行时，由于已存在配置文件，会提示已经初始化过了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config init
The settings has been initilized <span class="k">in</span> /home/ubuntu/.pictlrc.

╰─<span class="nv">$ </span>pictl config init
/home/ubuntu/.pictlrc already exists.
Please add settings or change it manaully.
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">pictl config info</code> 以 JSON 格式打印所有配置信息。配置文件默认采用 TOML 格式。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config info
<span class="o">{</span>
    <span class="s1">'basic'</span>: <span class="o">{</span><span class="s1">'length'</span>: 6, <span class="s1">'ntype'</span>: <span class="s1">'random'</span>, <span class="s1">'algorithm'</span>: <span class="s1">'sha1'</span><span class="o">}</span>,
<span class="o">}</span>

╰─<span class="nv">$ </span><span class="nb">cat</span> ~/.pictlrc
<span class="o">[</span>basic]
length <span class="o">=</span> 6
ntype <span class="o">=</span> <span class="s2">"random"</span>
algorithm <span class="o">=</span> <span class="s2">"sha1"</span>
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">pictl config add</code> 以命令行交互方式添加配置（以下是 R2 的例子）。添加完成后可以再次查看新增后的所有配置。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config add
<span class="k">******</span> Please input these information <span class="k">******</span>
Group Name <span class="o">(</span>default <span class="s1">'blog'</span><span class="o">)</span>: <span class="nb">test</span>
<span class="o">[</span>?] Type: : R2
   S3
 <span class="o">&gt;</span> R2

Account ID: testid
Bucket Name: <span class="nb">test
</span>Key: testkey
Secret: testsecret
Prefix <span class="o">(</span>Default is None<span class="o">)</span>:
Access Url <span class="o">(</span>like <span class="sb">`</span>https://i.example.com<span class="sb">`</span><span class="o">)</span>: https://i.example.com
New group <span class="s1">'test'</span> has been saved <span class="k">in</span> /Users/zhonger/.pictlrc.

╰─<span class="nv">$ </span>pictl config info
<span class="o">{</span>
    <span class="s1">'basic'</span>: <span class="o">{</span><span class="s1">'length'</span>: 6, <span class="s1">'ntype'</span>: <span class="s1">'random'</span>, <span class="s1">'algorithm'</span>: <span class="s1">'sha1'</span><span class="o">}</span>,
    <span class="s1">'test'</span>: <span class="o">{</span>
        <span class="s1">'endpoint'</span>: <span class="s1">'https://testid.r2.cloudflarestorage.com/test'</span>,
        <span class="s1">'bucket'</span>: <span class="s1">'test'</span>,
        <span class="s1">'prefix'</span>: <span class="s1">''</span>,
        <span class="s1">'key'</span>: <span class="s1">'testkey'</span>,
        <span class="s1">'secret'</span>: <span class="s1">'testsecret'</span>,
        <span class="s1">'url'</span>: <span class="s1">'https://i.example.com'</span>,
        <span class="s1">'type'</span>: <span class="s1">'R2'</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">pictl config delete</code> 命令可以选择删除远程配置组（此处为了展示，除 test 外还添加了其他配置组）。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config delete
<span class="o">[</span>?] Please <span class="k">select </span>one group: : <span class="nb">test
   </span>blog
   cover
 <span class="o">&gt;</span> <span class="nb">test

test </span>has been deleted.
</code></pre></div></div>

<h4 id="compress-子命令">compress 子命令</h4>

<p>  本子命令输入参数为<strong>图片文件名</strong>，可以带路径。输出图片会被保存在命令执行位置，<strong>而非原图片所在目录</strong>。执行该操作后，图片还不会被上传，需要继续使用 upload 命令完成上传。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl compress <span class="nt">-h</span>
Usage: pictl compress <span class="o">[</span>OPTIONS] FILENAME

  Compress any image into <span class="sb">`</span>webp<span class="sb">`</span> image.

  FILENAME is the name of the file to compress.

Options:
  <span class="nt">-h</span>, <span class="nt">--help</span>  Show this message and exit.

╰─<span class="nv">$ </span>pictl compress ../../pictl/fig01.png
The output file is EVyP2J.webp
</code></pre></div></div>

<h4 id="upload-子命令">upload 子命令</h4>

<p>  如下所示，使用 <code class="language-plaintext highlighter-rouge">pictl upload</code> 命令加上指定上传文件名和远程配置组即可完成上传。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl upload <span class="nt">-h</span>
Usage: pictl upload <span class="o">[</span>OPTIONS] FILENAME GROUP

  Upload the file to remote storage.

  FILENAME is the name of the file to upload.
  GROUP is the group <span class="k">in </span>the config file you want to use.

Options:
  <span class="nt">-h</span>, <span class="nt">--help</span>  Show this message and exit.

╰─<span class="nv">$ </span>pictl upload EVyP2J.webp <span class="nb">test
</span>Direct URL: https://i.example.com/EVyP2J.webp
Markdown: <span class="o">![</span>EVyP2J.webp]<span class="o">(</span>https://i.example.com/EVyP2J.webp<span class="o">)</span>
HTML Code: &lt;img <span class="nv">src</span><span class="o">=</span><span class="s2">"https://i.example.com/EVyP2J.webp"</span> <span class="nv">alt</span><span class="o">=</span><span class="s2">"EVyP2J.webp"</span> /&gt;
</code></pre></div></div>

<h4 id="cup-子命令">cup 子命令</h4>

<p>  cup 子命令 = compress 子命令 + upload 子命令，仅需要指定初始图片文件和远程配置组，即可一步完成图片压缩、格式转换、修改名称、上传。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl cup <span class="nt">-h</span>
Usage: pictl cup <span class="o">[</span>OPTIONS] FILENAME GROUP

  Compress image and upload to remote storage <span class="o">(</span>compress and upload<span class="o">)</span><span class="nb">.</span>

  FILENAME is the name of the file to compress.
  GROUP is the group <span class="k">in </span>the config file you want to use.

Options:
  <span class="nt">-h</span>, <span class="nt">--help</span>  Show this message and exit.

╰─<span class="nv">$ </span>pictl cup ../../pictl/fig01.png <span class="nb">test
</span>The output file is Gl8qhI.webp
Direct URL: https://i.example.com/Gl8qhI.webp
Markdown: <span class="o">![</span>Gl8qhI.webp]<span class="o">(</span>https://i.example.com/Gl8qhI.webp<span class="o">)</span>
HTML Code: &lt;img <span class="nv">src</span><span class="o">=</span><span class="s2">"https://i.example.com/Gl8qhI.webp"</span> <span class="nv">alt</span><span class="o">=</span><span class="s2">"Gl8qhI.webp"</span> /&gt;
</code></pre></div></div>

<h2 id="todo">TODO</h2>

<p>  目前的 v0.1.0 版本还比较简陋，不过已经能满足笔者的必要需求，有效提升效率。后续将继续完善、新增功能：</p>

<ul>
  <li>自动补全（shell completion），增强命令行使用体验。</li>
  <li>增加对各云服务厂商提供对象存储的支持。</li>
  <li>增加对各流行图床的支持。</li>
  <li>增加对自托管 Git 的支持。</li>
  <li>增加对 FTP 的支持。</li>
  <li>增加包括水印、调整大小等在内的图片处理的支持。</li>
  <li>增加与 Unplash 等公共图库的连接，更加便于博客封面的操作。</li>
</ul>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://blog.cloudflare.com/introducing-r2-object-storage-zh-cn/">隆重推出 Cloudflare R2 Storage —— 快速、可靠的对象存储，减免出口费用</a></li>
  <li><a href="https://developers.cloudflare.com/r2/">R2 文档</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="project" /><category term="pictl" /><category term="命令行" /><category term="工具" /><category term="cli" /><category term="tool" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">通用运行环境版本管理神器 ASDF</title><link href="https://lisz.me/tech/webmaster/asdf.html" rel="alternate" type="text/html" title="通用运行环境版本管理神器 ASDF" /><published>2023-03-20T15:50:00+09:00</published><updated>2023-03-20T15:50:00+09:00</updated><id>https://lisz.me/tech/webmaster/asdf</id><content type="html" xml:base="https://lisz.me/tech/webmaster/asdf.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  之前介绍了高性能集群中常用的运行环境和软件版本管理工具 Modules，今天打算介绍一款适合个人或团队开发使用的通用运行环境版本管理神器 <a href="https://asdf-vm.com/zh-hans/">ASDF</a>。与高性能计算任务不同，个人或团队开发项目一般来说都是使用独立的设备或环境，然后通过代码版本跟踪 git 等来进行异步协作。所以说，在每个人的单个或多个设备上都安装配置 Modules 显得有点不太现实和高效。但是项目开发所需的代码环境确实有的时候可能比较复杂，比如说同时需要 Ruby、NodeJS、Java、Python 四种环境，而且可能对于每种环境还有版本的限制。这样一来，光配置这一堆环境就要花上大半天时间了。</p>

<h3 id="asdf-简介">ASDF 简介</h3>

<p>  ASDF 提供了全平台通用的环境配置方案，使用单个命令行工具和交互界面就可以管理超复杂的运行环境。以往针对不同运行环境，需要使用不同的配置文件来进行版本的声明。对于 ASDF，只需要一个可共享的 <code class="language-plaintext highlighter-rouge">.tool-versions</code> 配置文件即可。ASDF 涵盖了包括 Ruby、NodeJS、Java、PHP、.Net 在内的几百种运行环境，具体可以查看 <a href="https://github.com/asdf-vm/asdf-plugins">ASDF 插件列表</a> 了解更多。</p>

<p>  另外，ASDF 完全支持包括 Bash、Zsh、Fish 和 Elvish 在内的常用 shell 类型，并提供补全功能。在类似 Github Actions 等的 CI/CD 工作流中，也可以轻松使用 ASDF。值得一提的是，笔者翻译了 ASDF 文档的中文版本并被官方采纳，现在 ASDF 官网支持英语、巴西语和中文三种语言。</p>

<h3 id="为何不选其他方案">为何不选其他方案</h3>

<h4 id="docker">Docker</h4>

<p>  很显然，如果大家的设备上都有 Docker 环境且 CPU 架构相同的话，Docker 无疑是最省心的方案。Docker 镜像的确可以轻松涵盖所有开发环境和实际运行环境（Apache 等 HTTP 服务器、数据库以及其他）。相比笨重的 VMware 或 Virtualbox 虚拟机镜像而言，Docker 镜像也更加小巧、便捷。而且团队可以通过在内部搭建自己的 Docker 镜像仓库，来分享这些镜像给所有参与项目的开发者。唯一可能会有问题的是，设备 CPU 架构和操作系统的多样性可能会给实际操作带来了不小的问题。实际上可能会有 Windows 系统、Linux 系统、MacOS 系统以及 Intel 架构、AMD 架构、ARM 架构（如 M1、M2 等）。可行的解决方法是，尽可能地构建更多架构的镜像。</p>

<h4 id="anaconda">Anaconda</h4>

<p>  Anaconda 现在可能已经完全超出了一个 Python 环境管理工具，有的时候也可以当成通用软件或环境管理器来用。但是毕竟还是以科学计算为主要目的，如果项目仅仅是 Python、R 语言可能还是比较合适的，对于实际编程所需的其他运行环境来说可能还是支持不够的。</p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  据笔者所知，在 <code class="language-plaintext highlighter-rouge">conda-forge</code> 频道里的确有 PHP 等编程语言的支持。除此之外，也有一些热心开发者在个人频道提供了 java-jdk、golang 等编程环境支持。</p>



 </div> </div>
<h4 id="云开发">云开发</h4>

<p>  云开发主要是指基于云基础设施的在线代码开发环境，主要的代表有：</p>

<ul>
  <li><a href="https://aws.amazon.com/cn/cloud9/">Cloud9</a>：笔者最早接触过的云开发，目前已被 AWS 收购，更名为 AWS Cloud9。</li>
  <li><a href="https://github.com/features/codespaces">Codespaces</a>：由 Azure 提供云服务、Github 负责运营的一站式云开发环境。</li>
  <li><a href="https://www.gitpod.io/">Gitpod</a>：基于 VS Code 研发的优秀云开发环境，早期以“便捷、快速”著称，较先于 Codespaces 出现。</li>
  <li><a href="https://cloud.tencent.com/product/cloudstudio">Cloud Studio</a>：由腾讯云提供云服务、基于 VS Code 的国产云开发环境，能够很好地支持个人开发、招聘笔试、课堂教学、应用快捷部署等各种场景。</li>
  <li><a href="https://www.huaweicloud.com/product/cloudide.html">CodeArts IDE Online</a>：由华为云提供云服务、基于 VS Code 的国产云开发环境。除了一般云开发所具备的特点，还支持华为鲲鹏原生环境，能够很好地满足跨架构应用开发的需求。</li>
  <li><a href="https://cn.aliyun.com/product/yunxiao/devstudio">DevStudio</a>：由阿里云提供云服务、基于 VS Code 的国产云开发环境。支持应用开发全流程管理，与阿里云各项基础服务紧密结合，适合大规模团队使用。</li>
</ul>

<p>除了以上列举的云开发之外，也有一些比较传统的小型云开发实践，比如说知名的 <a href="https://jsfiddle.net/">JSFiddle</a>、<a href="https://codepen.io/">CodePen</a>、<a href="https://replit.com/">Replit</a> 等。虽然说这些云开发主要是适合较小代码库，但在实际学习过程中用处也是很大的。</p>

<p>  云开发不仅兼顾了传统开发过程中的协同与流程，又将资源与环境整合在云里面，自然而然是最好的解决方案。随着 VS Code 在开发者之间的流行和云服务提供商的努力，基于 VS Code 的云开发环境层出不穷。即使云开发环境本身免费，云也还是要按量按时计费的。对于还没有足够支持上云的团队或个人来说，ASDF 依然是个不错的选择。</p>

<h2 id="实践">实践</h2>

<h3 id="环境需求">环境需求</h3>

<ul>
  <li>Linux/Unix 环境（Linux、MacOS、Windows WSL）</li>
  <li>git</li>
  <li>bash 等（此处以 zsh 为例）</li>
</ul>

<h3 id="环境配置">环境配置</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 下载源码到 ~/.asdf 目录</span>
git clone https://github.com/asdf-vm/asdf.git ~/.asdf <span class="nt">--branch</span> v0.11.3

<span class="c"># 在 ~/.zshrc 文件中加入内容</span>
<span class="nb">tee</span> <span class="nt">-a</span> ~/.zshrc <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
. "</span><span class="nv">$HOME</span><span class="sh">/.asdf/asdf.sh"
</span><span class="no">EOF

</span><span class="c"># 激活配置</span>
<span class="nb">source</span> ~/.zshrc

<span class="c"># 验证</span>
╰─<span class="nv">$ </span>asdf version
v0.11.3-0adc6c1
</code></pre></div></div>

<h3 id="安装插件">安装插件</h3>

<p>  由于 ASDF 支持插件较多，这里以 Python 环境为例介绍 ASDF 安装插件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 添加插件</span>
asdf plugin add python

<span class="c"># 查看已安装插件</span>
╰─<span class="nv">$ </span>asdf plugin list
python

<span class="c"># 查看最新 Python 版本</span>
╰─<span class="nv">$ </span>asdf latest python
3.11.2

<span class="c"># ASDF 安装 Python 3.11.2 (latest)</span>
╰─<span class="nv">$ </span>asdf <span class="nb">install </span>python latest
python-build 3.11.2 /home/ubuntu/.asdf/installs/python/3.11.2
Downloading Python-3.11.2.tar.xz...
-&gt; https://www.python.org/ftp/python/3.11.2/Python-3.11.2.tar.xz
Installing Python-3.11.2...
Installed Python-3.11.2 to /home/ubuntu/.asdf/installs/python/3.11.2

<span class="c"># 查看已安装 Python 版本列表</span>
╰─<span class="nv">$ </span>asdf list
python
  3.11.2
</code></pre></div></div>

<h3 id="使用">使用</h3>

<p>  ASDF 提供全局版本（Global）和本地版本（Local）两种方式定义运行环境版本。全局版本是系统级别的，类似于 PATH 变量中定义的；本地版本则是为了某个代码库或者部分代码准备的，通常在目录中的 <code class="language-plaintext highlighter-rouge">.tool-versions</code> 文件里定义。为了区分全局和本地的效果差别，这里再安装一个指定 Python 版本。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查询 Python 插件支持的所有版本</span>
╰─<span class="nv">$ </span>asdf list all python
2.1.3
2.2.3
......
stackless-3.7.5

<span class="c"># 安装 Python 3.9.0</span>
╰─<span class="nv">$ </span>asdf <span class="nb">install </span>python 3.9.0
python-build 3.9.0 /home/zhonger/.asdf/installs/python/3.9.0
Downloading Python-3.9.0.tar.xz...
-&gt; https://www.python.org/ftp/python/3.9.0/Python-3.9.0.tar.xz
Installing Python-3.9.0...
patching file Misc/NEWS.d/next/Build/2021-10-11-16-27-38.bpo-45405.iSfdW5.rst
patching file configure
patching file configure.ac
Installed Python-3.9.0 to /home/zhonger/.asdf/installs/python/3.9.0

<span class="c"># 查看已安装 Python 版本列表</span>
╰─<span class="nv">$ </span>asdf list
python
  3.11.2
  3.9.0

<span class="c"># 查看当前系统 Python 及 Python3 版本</span>
╰─<span class="nv">$ </span>python <span class="nt">-V</span>
No python executable found <span class="k">for </span>python system

╰─<span class="nv">$ </span>python3 <span class="nt">-V</span>
Python 3.10.6

<span class="c"># 更改全局版本为 3.11.2 并查看</span>
╰─<span class="nv">$ </span>asdf list
python
 <span class="k">*</span>3.11.2
  3.9.0

╰─<span class="nv">$ </span>python <span class="nt">-V</span>
Python 3.11.2

<span class="c"># 创建子目录指定本地版本并查看</span>
<span class="nb">mkdir </span>py <span class="o">&amp;&amp;</span> <span class="nb">cd </span>py
asdf <span class="nb">local </span>python 3.9.0

╰─<span class="nv">$ </span>python <span class="nt">-V</span>
Python 3.9.0

<span class="c"># 返回父目录查看 Python 版本</span>
╰─<span class="nv">$ </span><span class="nb">cd</span> .. <span class="o">&amp;&amp;</span> python <span class="nt">-V</span>
Python 3.11.2

<span class="c"># 查看当前系统 Python3 版本</span>
╰─<span class="nv">$ </span>python3 <span class="nt">-V</span>
Python 3.10.6
</code></pre></div></div>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  这里有一点比较有趣的是：由于 ASDF 接管的 <code class="language-plaintext highlighter-rouge">python</code> 命令而非 <code class="language-plaintext highlighter-rouge">python3</code> 命令，所以 <code class="language-plaintext highlighter-rouge">python3</code> 命令输出的版本依然还是系统安装版本。</p>



 </div> </div>
<h3 id="其他相关">其他相关</h3>

<p>  如果想要恢复到系统指定版本，可以很容易使用 <code class="language-plaintext highlighter-rouge">asdf global python system</code> 命令。当然，对于本地版本，可以使用 <code class="language-plaintext highlighter-rouge">asdf local python system</code> 来实现。除此之外，还有一些常规操作如下。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看 Python 指定版本安装位置</span>
╰─<span class="nv">$ </span>asdf where python 3.11.2
/home/zhonger/.asdf/installs/python/3.11.2

<span class="c"># 查看命令所在位置</span>
╰─<span class="nv">$ </span>asdf which python
/home/zhonger/.asdf/installs/python/3.11.2/bin/python

<span class="c"># 查看当前 ASDF 管理的运行环境</span>
╰─<span class="nv">$ </span>asdf current
python          3.11.2          /home/ubuntu/.tool-versions

<span class="c"># 查看全局和本地版本配置文件</span>
╰─<span class="nv">$ </span><span class="nb">cat</span> ~/.tool-versions
python 3.11.2

╰─<span class="nv">$ </span><span class="nb">cat</span> ~/py/.tool-versions
python 3.9.0
</code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://asdf-vm.com/zh-hans/guide/getting-started.html">ASDF 官网 - 快速入门</a></li>
  <li><a href="https://asdf-vm.com/zh-hans/manage/versions.html">ASDF 官网 - 版本</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Linux" /><category term="Environment" /><category term="Manage" /><category term="Dev Runtime" /><category term="软件环境" /><category term="多版本" /><category term="管理" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">Modules 配置之 Python</title><link href="https://lisz.me/tech/webmaster/modules-python.html" rel="alternate" type="text/html" title="Modules 配置之 Python" /><published>2023-03-20T12:48:00+09:00</published><updated>2023-03-20T12:48:00+09:00</updated><id>https://lisz.me/tech/webmaster/modules-python</id><content type="html" xml:base="https://lisz.me/tech/webmaster/modules-python.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  近年来得益于其轻量、易学易用、第三方支持依赖库多的特点，Python 语言大量被用于机器学习相关的研究、项目开发。在学术界，有以 <a href="https://scikit-learn.org">Scikit-Learn</a> 为代表的全能机器学习库；在产业界，有以 <a href="https://www.tensorflow.org">TensorFlow</a>、<a href="https://pytorch.org">PyTorch</a> 为代表的生产级机器学习模型计算框架。（当然，学术界实际上构建大规模深度学习模型时也会用到 PyTorch 等计算框架。）但对于大多数人来说，学习这些库、框架或者借助它们从事某些研究、项目开发时，可能还是在用自己的笔记本、台式机。哪怕是在高校的实验室里，这种事情也是屡见不鲜。因此，有交互界面、相对容易上手的 <a href="https://www.anaconda.com">Anaconda</a> 可能会作为大家管理 Python 环境的首选。</p>

<p>  当我们在用 Python 编写一些代码，而代码一次运行不可能在短短几秒、几分钟内得到结果时，将任务提交给高性能工作站或者集群作业系统就显得格外有效。尤其是当应用规模较大、计算迭代次数较多时，非交互式的作业提交方式会变得更加有利。毕竟如果是用自己的笔记本运行着这么大的计算，资源基本上都被计算占用了，根本没办法用笔记本去干点别的事情。甚至说，计算还会使得 CPU 等核心部件温度上升，从而影响计算性能。这样比较下来，不得不说提交任务给高性能工作站或者集群作业系统是多么明智的选择。</p>

<p>  其实，Anaconda 在没有交互界面的服务器操作系统上也还是可以使用的，我们可以使用其免费的精简版 —— <a href="https://conda.io/miniconda">miniconda</a>。虽然 miniconda 已经是精简版了，但和原生 Python 环境比起来还是要多不少东西的。从高性能计算环境的角度来看，使用 Modules 直接管理 Python 环境实际上更加贴近原生，也更加有利于用户与其他环境搭配使用。比如说安装  Python 的 MPI 支持库 —— MPI4PY，仅需要通过 Modules 管理工具加载 Python 和 MPI 两个基础环境，使用 <code class="language-plaintext highlighter-rouge">pip3 install mpi4py</code> 命令即可安装。</p>

<h2 id="实践">实践</h2>

<p>  将 Python 环境纳入 Modules 管理的步骤就是两步：第一步，编译源代码及安装；第二步，添加 Modules 配置文件。当然，最开始还是需要确认一下编译环境是否完备以及文件夹是否准备好。</p>

<h3 id="环境及文件夹准备">环境及文件夹准备</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 安装编译环境</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> build-essential libbz2-dev libdb-dev <span class="se">\</span>
  libreadline-dev libffi-dev libgdbm-dev liblzma-dev <span class="se">\</span>
  libncursesw5-dev libsqlite3-dev libssl-dev <span class="se">\</span>
  zlib1g-dev uuid-dev tk-dev wget
  
<span class="c"># 准备文件夹</span>
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /opt/python/3.10.6
</code></pre></div></div>

<h3 id="编译及安装">编译及安装</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 下载源代码</span>
<span class="nb">cd</span> /tmp
wget <span class="nt">-c</span> https://www.python.org/ftp/python/3.10.6/Python-3.10.6.tar.xz

<span class="c"># 解压源代码</span>
<span class="nb">tar </span>xf Python-3.10.6.tar.xz

<span class="c"># 配置安装路径及编译选项</span>
<span class="nb">cd </span>Python-3.10.6
./configure <span class="nt">--prefix</span><span class="o">=</span>/opt/python/3.10.6 <span class="nt">--enable-optimizations</span> <span class="nt">--with-lto</span> 

<span class="c"># 编译及安装</span>
make <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<h3 id="配置-modules">配置 Modules</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /opt/modules/modulefiles/py
<span class="nb">sudo </span>vim /opt/modules/modulefiles/py/3.10.6
</code></pre></div></div>

<p>  首先如上命令准备文件夹，并新建 module 配置文件，内容如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#%Module</span>
proc ModulesHelp <span class="o">{</span> <span class="o">}</span> <span class="o">{</span>
    puts stderr <span class="se">\t</span>This module file will load Python 3.10.6<span class="s2">"
}

module-whatis  "</span>Enable Python 3.10.6<span class="s2">"

eval set  [ array get env HOME ]
set basedir /opt/python/3.10.6
prepend-path PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/bin<span class="s2">"
prepend-path LIBRARY_PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/lib<span class="s2">"
prepend-path LD_LIBRARY_PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/lib<span class="s2">"
prepend-path INCLUDE_PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/include<span class="s2">"
prepend-path LD_INCLUDE_PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/include<span class="s2">"
</span></code></pre></div></div>

<h3 id="验证">验证</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看所有可用模块</span>
╰─<span class="nv">$ </span>module ava
<span class="nt">--------------------------</span> /opt/modules/modulefiles <span class="nt">---------------------------</span>
dot  module-git  module-info  modules  null  py/3.10.6  use.own

Key:
modulepath
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 加载 python 3.10.6 环境，并确认已加载模块</span>
╰─<span class="nv">$ </span>module load py/3.10.6
╰─<span class="nv">$ </span>module list
Currently Loaded Modulefiles:
 1<span class="o">)</span> py/3.10.6
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 确认目前 python 版本</span>
╰─<span class="nv">$ </span>python3 <span class="nt">-V</span>
Python 3.10.6
</code></pre></div></div>

<h3 id="使用">使用</h3>

<p>  由于以上操作将 Python 3.10.6 安装到了一个系统文件夹中，编译完成后会出现如下警告提示。不过无须担心，普通用户可以通过 venv 虚拟环境工具正常使用。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Installing collected packages: setuptools, pip
  WARNING: The scripts pip3 and pip3.10 are installed <span class="k">in</span> <span class="s1">'/opt/python/3.10.6/bin'</span> which is not on PATH.
  Consider adding this directory to PATH or, <span class="k">if </span>you prefer to suppress this warning, use <span class="nt">--no-warn-script-location</span><span class="nb">.</span>
Successfully installed pip-22.2.1 setuptools-63.2.0
WARNING: Running pip as the <span class="s1">'root'</span> user can result <span class="k">in </span>broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv
</code></pre></div></div>

<p>  如下所示，当已经如<strong>验证</strong>部分加载好 python 3.10.6 模块后，使用以下命令新建虚拟环境、激活后即可使用。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>   新建虚拟环境时最后的参数 env 是指虚拟环境的名字，我们可以取任意符合 python 规则的字符串作为虚拟环境名字。值得注意的是，python 虚拟环境有关的文件将会被安装在命令执行的当前目录下的同名文件夹中。为了便于管理和使用，建议将所有的 python 虚拟环境都放置在同一目录下。</p>



 </div> </div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 新建 env 虚拟环境</span>
╰─<span class="nv">$ </span>python3 <span class="nt">-m</span> venv <span class="nb">env</span>

<span class="c"># 激活 env 虚拟环境</span>
╰─<span class="nv">$ </span><span class="nb">source env</span>/bin/activate

<span class="c"># 可以看到 &lt;env&gt; 的环境提示</span>
<span class="c"># 尝试升级 pip，可以看到成功升级 </span>
╭─zhonger@lep-u ~ ‹env›
╰─<span class="nv">$ </span>pip3 <span class="nb">install</span> <span class="nt">-U</span> pip
Requirement already satisfied: pip <span class="k">in</span> ./env/lib/python3.10/site-packages <span class="o">(</span>22.2.1<span class="o">)</span>
Collecting pip
  Using cached pip-23.0.1-py3-none-any.whl <span class="o">(</span>2.1 MB<span class="o">)</span>
Installing collected packages: pip
  Attempting uninstall: pip
    Found existing installation: pip 22.2.1
    Uninstalling pip-22.2.1:
      Successfully uninstalled pip-22.2.1
Successfully installed pip-23.0.1

<span class="c"># 取消激活 env 虚拟环境</span>
╰─<span class="nv">$ </span>deactivate
</code></pre></div></div>

<h2 id="有趣的问题">有趣的问题</h2>

<p>  如果使用 module 提供的 python 模块创建了虚拟环境后，实际运行虚拟环境时还需要使用 module 加载 python 模块吗？答案是<strong>不需要</strong>。虚拟环境的本质是拷贝运行相同命令所需的必要文件，如下对比查看一下 python 模块和 env 虚拟环境的顶级目录。可以发现，两者的差别不是很大。env 虚拟环境少了 share 目录，多了 pyvenv.cfg 文件。查看该文件可知，存在与 python 模块之间的关系的声明。再查看 bin 目录，可以看到 python 可执行命令用了链接的方式，pip 命令则是直接从原来的 python 模块复制过来的。于是，这就能允许普通用户自行管理  pip 命令和 python 库了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span><span class="nb">ls</span> /opt/python/3.10.6
bin  include  lib  share

╰─<span class="nv">$ </span><span class="nb">ls env
</span>bin  include  lib  lib64  pyvenv.cfg

╰─<span class="nv">$ </span><span class="nb">cat env</span>/pyvenv.cfg
home <span class="o">=</span> /opt/python/3.10.6/bin
include-system-site-packages <span class="o">=</span> <span class="nb">false
</span>version <span class="o">=</span> 3.10.6

╰─<span class="nv">$ </span>ll <span class="nb">env</span>/bin
total 36K
<span class="nt">-rw-r--r--</span> 1 zhonger zhonger 8.9K Mar 20 15:20 Activate.ps1
<span class="nt">-rw-r--r--</span> 1 zhonger zhonger 2.0K Mar 20 15:20 activate
<span class="nt">-rw-r--r--</span> 1 zhonger zhonger  908 Mar 20 15:20 activate.csh
<span class="nt">-rw-r--r--</span> 1 zhonger zhonger 2.1K Mar 20 15:20 activate.fish
<span class="nt">-rwxrwxr-x</span> 1 zhonger zhonger  234 Mar 20 15:20 pip
<span class="nt">-rwxrwxr-x</span> 1 zhonger zhonger  234 Mar 20 15:20 pip3
<span class="nt">-rwxrwxr-x</span> 1 zhonger zhonger  234 Mar 20 15:20 pip3.10
lrwxrwxrwx 1 zhonger zhonger    7 Mar 20 15:20 python -&gt; python3
lrwxrwxrwx 1 zhonger zhonger   30 Mar 20 15:20 python3 -&gt; /opt/python/3.10.6/bin/python3
lrwxrwxrwx 1 zhonger zhonger    7 Mar 20 15:20 python3.10 -&gt; python3
</code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://docs.python.org/zh-cn/3/using/unix.html#building-python">Python 官方文档 - 构建 Python</a></li>
  <li><a href="https://docs.python.org/zh-cn/3/using/configure.html#configure-options">Python 官方文档 - 性能选项</a></li>
  <li><a href="https://docs.python.org/zh-cn/3/tutorial/venv.html">Python 官方文档 - 虚拟环境和包</a></li>
  <li><a href="https://www.python.jp/install/ubuntu/index.html">Ubuntu 環境の Python</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Linux" /><category term="Modules" /><category term="Python" /><category term="软件环境" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">集群动态环境管理神器 Modules</title><link href="https://lisz.me/tech/webmaster/modules.html" rel="alternate" type="text/html" title="集群动态环境管理神器 Modules" /><published>2022-10-26T15:48:00+09:00</published><updated>2022-10-26T15:48:00+09:00</updated><id>https://lisz.me/tech/webmaster/modules</id><content type="html" xml:base="https://lisz.me/tech/webmaster/modules.html"><![CDATA[<h2 id="前言">前言</h2>

<div class="premonition citation"> <div class="header"> <svg class="icon citation" aria-hidden="true"> <use xlink:href="#icon-citation"></use> </svg> </div> <div class="content"> <p>  Modules 包是一款简化 shell 初始化的工具，允许用户在会话期间使用模块文件轻松切换环境。</p>



 </div> <div class="ref"> ------ Environment Modules 官网 </div> </div>
<p>  在高性能集群或者超算中，我们可以经常看到 Modules 的身影。它可以帮助我们轻松加载运行程序所需的各类环境，比如说笔者之前写过的第一性原理计算软件 CONQUEST 的运行，就需要包括 Intel OneAPI HPCKit、FFTW3、LibXC 在内的多种环境；又比如说运行大规模的机器学习模型时，可能需要 Python、GPU 环境和 PyTorch 等依赖库。</p>

<p>  由于集群往往是面向很多人服务的，如果管理员将软件安装到全局环境，则只能安装某个软件的某个特定版本，而不能同时为不同的用户提供所需的同款软件的不同版本。举个例子，笔者编写的代码只能在 Python 3.10 环境下运行，而其他用户编写的代码所支持的 Python 版本是 3.0，那么可能最简单的解决方法是笔者自行编译一个 Python 3.10 的环境，然后利用 PATH 等变量的配置来提升优先级。或许之后有一天，另外一个用户也要使用 Python 3.10 环境，那么是不是让他再自行编译配置一遍呢？哈哈哈，听起来有点无奈，但是<strong>千万不要高估集群的使用用户</strong>，可能自行编译并配置 Python 3.10 对他们来说也有点困难。因此，Modules 成为了集群动态管理软件环境的最佳选择。集群管理员可以预先编译和配置好各种环境的各种版本，用户使用时只需要执行类似 <code class="language-plaintext highlighter-rouge">module load py/3.10.6</code> 的命令就可以轻松加载 Python 3.10.6 环境。</p>

<p>  Modules 所支持的模块不仅仅可以是编程语言的多版本，还可以是其他任意的基础环境，比如说 gcc、openmpi 等编译环境。这样一来，不仅可以为用户提供足够的编程环境直接使用，还可以为一些想要自行编译运行环境的用户提供了便利。</p>

<h2 id="实践">实践</h2>

<h3 id="源码编译安装-modules">源码编译安装 Modules</h3>

<p>  Modules 可以在 Linux、Windows、MacOS 任一操作系统上安装运行，这里仅介绍类 Unix 操作系统下的编译安装过程。由于 Modules 需要使用 tcl 工具来解析 modulefiles，所以系统必须预先安装 tcl 及其开发者库。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 根据实际情况三者选其一</span>
<span class="c"># Debian/Ubuntu 等 APT 系列操作系统上安装 tcl</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> tcl tcl-dev
<span class="c"># CentOS 等 YUM 系列操作系统上安装 tcl</span>
<span class="nb">sudo </span>yum <span class="nb">install</span> <span class="nt">-y</span> tcl tcl-devel
<span class="c"># MacOS 操作系统上安装 tcl （需有 brew 工具）</span>
brew <span class="nb">install </span>tcl-tk

<span class="c"># 下载源代码并解压</span>
wget <span class="nt">-c</span> https://github.com/cea-hpc/modules/releases/download/v5.1.1/modules-5.1.1.tar.gz
<span class="nb">tar </span>xfz modules-5.1.1.tar.gz

<span class="c"># 创建安装目录</span>
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /opt/modules

<span class="c"># 进入目录并配置安装目录</span>
<span class="nb">cd </span>modules-5.1.1
./configure <span class="nt">--prefix</span><span class="o">=</span>/opt/modules
<span class="c"># MacOS 可能需要如下另外指定 tclConfig.sh 文件所在的位置</span>
./configure <span class="nt">--prefix</span><span class="o">=</span>/opt/modules <span class="nt">--with-tcl</span><span class="o">=</span>/opt/homebrew/opt/tcl-tk/lib

<span class="c"># 编译并安装到 /opt/modules 目录</span>
make <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<h3 id="使-modules-生效">使 Modules 生效</h3>

<p>  并非是编译完了之后就可以直接使用 Modules，还有至关重要的一步–<strong>添加生效命令</strong>。首先需要确认当前使用的 Shell 是什么，一般来说默认是 Bash，当然也有 Zsh 等等。然后，在对应的 Shell 配置文件中增加一行生效命令。操作如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 确认当前使用的 Shell</span>
╰─<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$SHELL</span>
/bin/zsh

<span class="c"># 查看 Modules 支持的 Shell</span>
╰─<span class="nv">$ </span><span class="nb">ls</span> /opt/modules/init
bash            cmake           fish            ksh             lisp            profile.csh     python.py       ruby.rb         tcl             tcsh_completion zsh-functions
bash_completion csh             fish_completion ksh-functions   perl.pm         profile.sh      r.R             sh              tcsh            zsh
<span class="c"># 如上所示，大部分流行的 Shell 都在支持列表中</span>

<span class="c"># 使 Modules 生效</span>
vim ~/.zshrc
<span class="c"># 添加以下内容</span>
<span class="nb">source</span> /opt/modules/init/zsh
</code></pre></div></div>

<h3 id="源码编译安装-tcl">源码编译安装 tcl</h3>

<p>  Modules 的编译安装是不是很简单？不过如果 tcl 工具无法使用命令安装的话，就只能从源码编译安装，也比较方便，如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 下载源码并解压</span>
wget <span class="nt">-c</span> https://prdownloads.sourceforge.net/tcl/tcl8.6.12-src.tar.gz
<span class="nb">tar </span>xfz tcl8.6.12-src.tar.gz

<span class="c"># 创建安装目录</span>
<span class="nb">sudo mkdir</span> /opt/tcl

<span class="c"># 进入目录并配置安装目录</span>
<span class="nb">cd </span>tcl8.6.12/unix
./configure <span class="nt">--prefix</span><span class="o">=</span>/opt/tcl

<span class="c"># 编译并安装</span>
make <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<h3 id="modules-相关命令">Modules 相关命令</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看所有可用模块</span>
module avail / module ava

<span class="c"># 加载指定模块（支持同时加载多个模块）</span>
module load py/3.10.6 mpi

<span class="c"># 查看已加载模块</span>
module list

<span class="c"># 查看指定模块</span>
module show py/3.10.6

<span class="c"># 添加自定义模块配置目录</span>
module use <span class="nt">--apend</span> ~/opt/modulefiles
</code></pre></div></div>

<h2 id="添加软件环境">添加软件环境</h2>

<h3 id="modulefiles-库">Modulefiles 库</h3>

<p>  Modules 编译安装后默认会有一些环境，它们的配置文件都被存储在安装目录的 modulefiles 文件夹中，如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>module ava
<span class="nt">---------------------------</span> /opt/modules/modulefiles <span class="nt">---------------------------</span>
dot  module-git  module-info  modules  null  use.own

Key:
modulepath

╰─<span class="nv">$ </span><span class="nb">ls</span> /opt/modules/modulefiles
dot         module-git  module-info modules     null        use.own
</code></pre></div></div>

<p>  一般来说，打算提供给所有用户的环境配置都可以放在这个目录里，这样任何用户都可以查看到。</p>

<h3 id="modulefiles-模板">Modulefiles 模板</h3>

<p>  这里我们可以把 <code class="language-plaintext highlighter-rouge">use.own</code> 文件作为模板来学习一下如何编写 Modulefiles 文件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#%Module1.0#####################################################################</span>
<span class="c">##</span>
<span class="c">## use.own modulefile</span>
<span class="c">##</span>
proc ModulesHelp <span class="o">{</span> <span class="o">}</span> <span class="o">{</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">This module file will add </span><span class="se">\$</span><span class="s2">HOME/privatemodules to the"</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">list of directories that the module command will search"</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">for modules.  Place your own module files here."</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">This module, when loaded, will create this directory"</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">if necessary."</span>
<span class="o">}</span>

module-whatis   <span class="s2">"adds your own modulefiles directory to MODULEPATH"</span>

<span class="nb">eval set</span>  <span class="o">[</span> array get <span class="nb">env </span>HOME <span class="o">]</span>
<span class="nb">set </span>ownmoddir   <span class="nv">$HOME</span>/privatemodules

<span class="c"># create directory if necessary</span>
<span class="k">if</span> <span class="o">[</span> module-info mode load <span class="o">]</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">{</span> <span class="o">!</span> <span class="o">[</span> file exists <span class="nv">$ownmoddir</span> <span class="o">]</span> <span class="o">}</span> <span class="o">{</span>
        file <span class="nb">mkdir</span> <span class="nv">$ownmoddir</span>
        <span class="nb">set </span>null <span class="o">[</span>open <span class="nv">$ownmoddir</span>/null w]
        puts <span class="nv">$null</span> <span class="s2">"#%Module########################################################################"</span>
        puts <span class="nv">$null</span> <span class="s2">"##"</span>
        puts <span class="nv">$null</span> <span class="s2">"## null modulefile"</span>
        puts <span class="nv">$null</span> <span class="s2">"##"</span>
        puts <span class="nv">$null</span> <span class="s2">"proc ModulesHelp { } {"</span>
        puts <span class="nv">$null</span> <span class="s2">"    puts stderr </span><span class="se">\"\t</span><span class="s2">This module does absolutely nothing.</span><span class="se">\"</span><span class="s2">"</span>
        puts <span class="nv">$null</span> <span class="s2">"    puts stderr </span><span class="se">\"\t</span><span class="s2">It's meant simply as a place holder in your</span><span class="se">\"</span><span class="s2">"</span>
        puts <span class="nv">$null</span> <span class="s2">"    puts stderr </span><span class="se">\"\t</span><span class="s2">dot file initialization.</span><span class="se">\"</span><span class="s2">"</span>
        puts <span class="nv">$null</span> <span class="s2">"}"</span>
        puts <span class="nv">$null</span> <span class="s2">""</span>
        puts <span class="nv">$null</span> <span class="s2">"module-whatis   </span><span class="se">\"</span><span class="s2">does absolutely nothing</span><span class="se">\"</span><span class="s2">"</span>
    <span class="o">}</span>
<span class="o">}</span>

module use <span class="nt">--append</span> <span class="nv">$ownmoddir</span>
</code></pre></div></div>

<p>  Modulefiles 文件一般符合以下规则：</p>

<ul>
  <li>Modulefiles 文件必须以 <code class="language-plaintext highlighter-rouge">#%Module1.0</code> 开头；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">proc ModulesHelp {}</code> 函数来添加模块详细描述；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">module-whatis</code> 字段来添加一句话简短描述；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">eval set [ array get env HOME]</code> 来获取系统变量 <code class="language-plaintext highlighter-rouge">$HOME</code>；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">set ownmoddir</code> 来定义变量 <code class="language-plaintext highlighter-rouge">ownmoddir</code>；</li>
  <li>后续脚本可以根据需求进行添加内容。</li>
</ul>

<p>  这里先开个坑，后续打算补充 Modules 配置系列文章：</p>

<ul>
  <li><a href="modules-python.html">《Modules 配置之 Python》</a></li>
  <li><a href="modules-conda.html">《Modules 配置之 Anaconda》</a></li>
  <li><a href="modules-intel.html">《Modules 配置之 Intel OneAPI》</a></li>
</ul>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://modules.readthedocs.io/en/latest/index.html">Environment Modules 官方文档</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Linux" /><category term="集群" /><category term="Cluster" /><category term="Modules" /><category term="软件环境" /><summary type="html"><![CDATA[前言]]></summary></entry></feed>