<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://lisz.me/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lisz.me/" rel="alternate" type="text/html" /><updated>2024-10-29T15:45:10+09:00</updated><id>https://lisz.me/feed.xml</id><title type="html">仲儿的自留地</title><subtitle>个人的一个技术博客站点，主要用于记录个人在学习过程中遇到的技术问题及解决方法、技术实验，以及一些比较有趣的事情。</subtitle><author><name>zhonger</name></author><entry><title type="html">Kubernetes 不完全入门</title><link href="https://lisz.me/tech/k8s/k8s-introduction.html" rel="alternate" type="text/html" title="Kubernetes 不完全入门" /><published>2024-10-08T16:50:00+09:00</published><updated>2024-10-08T16:50:00+09:00</updated><id>https://lisz.me/tech/k8s/k8s-introduction</id><content type="html" xml:base="https://lisz.me/tech/k8s/k8s-introduction.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  Web 应用的生产环境部署随着技术的发展不断地发生改变，如下图所示，从最早期的单机环境到多机环境，再发展到复杂环境：</p>

<ul>
  <li><strong>单机环境</strong>指的是代码、运行环境、文件存储、数据库服务都在同一台服务器上的应用部署方式。通常来说，个人应用或者早期 Demo 应用大多采用这类方式。单机环境的优点在于不需要太多服务器资源，缺点在于过分依赖本地资源而没有高可用性、高可扩展性以及数据的安全保障。如果是云服务器作为单机环境，可以通过升级配置的方式来提高 CPU、内存和存储资源。至于数据则可以通过异机备份或本地备份的方式来保障数据的可靠性。</li>
  <li><strong>多机环境</strong>指的是同一应用所需的运行环境、数据库服务、文件存储服务分布在不同的节点或集群中的应用部署方式。这类方式的优点自然是具备高可用性、高可扩展性以及完备的数据安全保障，缺点则是需要大量的服务器资源。因此，多机环境通常是对外大量用户提供服务时常用的方式。</li>
  <li><strong>复杂环境</strong>打破了原有的瓶瓶罐罐，是多机环境的一种的超级形态。在复杂环境中，不再拘泥于服务器节点本身，而是利用 Web 应用将已有的云资源联系在一起。说得更直白一点，就是应用开发者不再需要关心应用运行环境、数据库服务、文件存储等基础环境的配置和管理，唯一需要关心的只有应用代码本身。这也是现在大部分 Web 应用的真实部署方式。</li>
</ul>

<p>  自从代码版本跟踪软件 Git 横空出世以来，逐步形成了以 Git 为中心的<strong>持续开发、持续集成和持续部署</strong>的现代应用开发方式。这与复杂环境的部署方式完全契合，由云服务提供商来提供和维护各类运行环境、数据库服务和文件存储，开发团队只需要专注于对代码存储库的管理。</p>

<p>  举个例子，当某个开发成员完成了某个模块的开发并推送到某个分支，该分支创建后会自动触发持续集成进行自动 Review。自动 Review 通过后，开发团队负责人可以对该分支的代码更改进行审核，通过后允许将该分支与其他某个指定分支进行合并（合并操作也是通过持续集成自动进行）。当所有代码开发完毕后，由总负责人审核汇入最终部署的分支。审核通过后持续集成会自动合并代码并通过持续部署将完整的代码部署到真实的运行环境中。如今的 GitHub、GitLab 均能完成持续开发、持续集成和持续部署的全过程。当然，也有一些软件（比如 <a href="https://www.jenkins.io/">Jenkins</a> 等）可以完成持续集成和持续部署两步，而持续开发则可以依托任意的 Git 托管服务。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 友情提醒 </div> </div> <div class="content"> <p>  以上叙述非专业解释，仅为个人看法，不喜勿喷。Kubernetes 官方将部署方式分为<strong>传统部署</strong>、<strong>虚拟化部署</strong>和<strong>容器部署</strong>三类。</p>



 </div> </div>
<p><img src="https://i.lisz.top/blog/79is8s.webp" alt="(a) 单机环境和多机环境。(b) 复杂环境。(c)以 Git 为中心的持续开发、持续集成、持续部署的现代应用开发方式。" /></p>

<h3 id="实例解析">实例解析</h3>

<p>  假设一个 Web 应用同时需要使用：</p>

<ul>
  <li><strong>运行环境</strong>：PHP 运行环境、Python 运行环境、NodeJS 运行环境。</li>
  <li><strong>数据库服务</strong>：关系型数据库（比如 MySQL）、非关系型数据库（比如 MongoDB）、缓存数据库（比如 Redis）。</li>
  <li><strong>文件存储</strong>：用于存储用户头像、上传文件的对象存储（S3）、用于存储运行代码的文件存储（比如 NFS）。</li>
  <li><strong>高可用应用入口</strong>：比如 Nginx、HaProxy 等。</li>
</ul>

<p>  在单机环境中，按照以前我们碰见这种要求可能就要头大了，毕竟同时配置这么多环境难免会有不可预知的问题。不过现在，容器化技术（比如 <a href="https://www.docker.com/">Docker</a>）可以帮助我们将所有的需求都拆分成独立的 container 实例。不但可以让它们之间在内部网络中互通，还可以对外只暴露必要的应用入口所需的 <code class="language-plaintext highlighter-rouge">80</code> 和 <code class="language-plaintext highlighter-rouge">443</code> 端口。这样一来，既将各项服务进行了合理拆分，又能保证应用服务的安全性。即使是需要对某个运行环境或者数据库服务进行版本升级，也可以很容易做到。</p>

<p>  在多机环境中，我们如果还想用容器化技术，那就必须用容器化集群。很久以前，Docker 官方就提供了一种 Swarm 模式来组成容器化集群。这种方式的好处是非常简单配置、轻量易用，对于熟悉使用 Docker 的开发者来说只需要花很少的时间就能搞明白。缺点也很明显，Docker Swarm 依赖于 Docker API。也就是说，Docker 本身不支持的东西还是不支持，比如更加高效安全的网络、花式多样的存储等。为了能够更好跨主机集群地自动部署、扩展以及运行应用程序容器，我们选择使用 <a href="https://kubernetes.io/zh-cn/">Kubernetes</a>（缩写为 <strong>K8S</strong>）。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小知识 </div> </div> <div class="content"> <p>  在 2014 年 Google 开源了 Kubenetes 项目，后来又贡献给了云原生计算基金会 <a href="https://www.cncf.io/">CNCF</a>。很多公司以 Kubernetes 为基础开发了自家的容器化集群平台，比如 RedHat 的 <a href="https://www.redhat.com/en/technologies/cloud-computing/openshift">OpenShift</a>，AWS 的 <a href="https://aws.amazon.com/cn/eks/">Elastic Kubenetes Services, EKS</a>，Azure 的 <a href="https://azure.microsoft.com/zh-cn/products/kubernetes-service">Azure Kubernetes Services, AKS</a>，阿里云的 <a href="https://www.aliyun.com/product/kubernetes">Aliyun Container Service for Kubernetes, ACK</a>，腾讯云的 <a href="https://cloud.tencent.com/product/tke">Tencent Kubernetes Engine, TKE</a> 等。</p>



 </div> </div>
<h2 id="kubernetes-架构">Kubernetes 架构</h2>

<p>  虽然 Kubernetes 官方文档已经将架构图以及相关概念介绍得非常清楚，但还是想说说自己的理解。类似于一般集群平台，K8S 也需要有至少一个控制节点（官方称之为“控制平面”）和一个工作节点。默认来说，K8S <strong>不推荐控制节点同时作为工作节点</strong>，因为这会影响集群调度的可靠性和可用性。从下面的重绘架构图可以看出，K8S 集群会对外提供 API 以供用户从集群外进行调度。在集群内部，工作节点通过 kubelet 服务与控制节点直接连接，控制节点也通过 kubelet 服务向工作节点下达调度指令来管理工作节点上的 pod。</p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> Pod 的概念 </div> </div> <div class="content"> <p>  Pod 可以理解为 K8S 中应用的最小单位，一个 Pod 中可能会包括一个或多个 container (容器)，这些容器间可以互通，但对外只有 Pod 有资格拥有 IP。这有点类似于进程与线程之间的关系，进程是拥有资源的最小单位，线程依赖于进程而存在，同一进程间的线程间可以无障碍通信，而不同进程间的通信则需要通过端口或 socket 来进行。</p>

<p>  同一个工作节点上的 Pod 的 IP 属于同一个子网，不同工作节点的子网又属于同一个大子网 (podSubnet，一般需要在初始化集群时定义)。这样的设计在很大程度上减少了 IP 管理的难度，并且能够最大程度上减少容器暴露的风险。</p>



 </div> </div>
<p><img src="https://i.lisz.top/blog/BV7Jqo.webp" alt="重绘 Kubernetes 官方文档架构图" /></p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> CRI 的概念 </div> </div> <div class="content"> <p>  CRI，全名为 Container Runtime Interface（容器运行时接口），是 K8S 架构中 kubelet和容器运行时通信的主要协议。我们所熟知的 Docker 就是一种容器运行时，但是自从 K8S 1.20 版本弃用 Docker 自带的容器运行时接口 Dockershim 以来，我们只能使用额外的 CRI – <a href="https://github.com/Mirantis/cri-dockerd">cri-dockerd</a> 来调用 Docker。因此推荐使用包含 CRI 的容器运行时 <a href="https://containerd.io/">containerd</a> 或者 <a href="https://cri-o.io/">cri-o</a> 来替代 Docker。</p>



 </div> </div>
<h3 id="组成部分">组成部分</h3>

<p>  由于 K8S 是一款平台无关的容器集群方案，所以官方提供的方案只是一个整体，我们需要自行选择以下各项组件：</p>

<ul>
  <li><strong>容器运行时 (CRI)</strong>：如上所述，推荐使用 containerd 或者 cri-o 来替代 docker。下面实践部分将以 containerd 为例。</li>
  <li><strong>网络组件 (CNI, Container Network Interface)</strong>：K8S 中网络有三种 Node、Pod、Service，其中 Node IP 是节点的 IP，用于连通或者暴露端口。Pod IP 是 Pod 的独立内网 IP，只能在 K8S 集群间访问。Service IP 是多个 Pod 共同组成 Service 后需要互通时使用的，一般仅在 Service 内部可访问，不能被用户访问。K8S 官方文档中 <a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/#networking-and-network-policy">联网和网络策略</a> 列举了很多可用的 CNI，这里我们选用 <a href="https://www.tigera.io/project-calico/">Calico</a> 来进行实践。</li>
  <li><strong>服务发现 (DNS)</strong>：默认为 <a href="https://coredns.io/">CoreDNS</a>，在配置完网络组件后自动创建，为 Pod 提供 DNS 解析服务，包括公网域名解析和 Service 别名解析。</li>
  <li><strong>容器存储接口 (CSI, Container Storage Interface)</strong>：目前 K8S 基本上移除了大部分的第三方软件相关存储插件，转而通过第三方自行维护的 CSI 来扩充存储类的支持。可以通过查看 K8S 官网文档的 <a href="https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#provisioner">存储制备器</a> 和 kubernetes-csi 的 <a href="https://kubernetes-csi.github.io/docs/drivers.html">Drivier</a> 来了解更多。这里我们选用 NFS 的 CSI Driver 作为例子进行实践。</li>
</ul>

<h2 id="搭建-k8s-集群">搭建 K8S 集群</h2>

<p>  在学习环境中，我们可以使用 <a href="https://kind.sigs.k8s.io/">kind</a>、<a href="https://minikube.sigs.k8s.io/">minikube</a> 或者 kubeadm 在本地快速部署 K8S 集群；在生产环境中，我们可以使用 <a href="https://kops.sigs.k8s.io/">kops</a>、<a href="https://kubespray.io/">Kubespray</a> 或者 kubeadm 在多节点上快速部署 K8S 集群。所以这里我们采用了通用的 kubeadm 来搭建 K8S 集群。</p>

<p>  在正式部署之前需要规划实际架构、做一些基本准确以及安装必要的软件和工具 – <code class="language-plaintext highlighter-rouge">kubelet</code>，<code class="language-plaintext highlighter-rouge">kubectl</code> 和 <code class="language-plaintext highlighter-rouge">kubeadm</code>。下图为本实践规划的 NodeSubset、PodSubset 和 ServiceSubset。</p>

<p><img src="https://i.lisz.top/blog/Z0hCRO.webp" alt="K8S 集群实际架构和网络规划" /></p>

<h3 id="基本准备">基本准备</h3>

<h4 id="关闭-swap-交换分区">关闭 SWAP 交换分区</h4>

<p>  K8S 为了性能考虑默认必须关闭 SWAP 交换分区，而通常实体服务器安装后会有 SWAP 交换分区，云服务器或 VPS 没有。通过 <code class="language-plaintext highlighter-rouge">sudo swapoff -a</code> 命令可以临时关闭 SWAP 分区，或者通过注释 <code class="language-plaintext highlighter-rouge">/etc/fstab</code> 文件中的 <code class="language-plaintext highlighter-rouge">swap.img</code> 这一行并重启服务器永久关闭 SWAP 交换分区。</p>

<h4 id="开启-ipv4-转发">开启 IPv4 转发</h4>

<p>  由于 K8S 集群中同一个 Service 的 Pod 可能被分配到不同节点，那么不同节点间的 Pod 通信是非常必要的，即不同 PodSubnet 之间的通信需要通过 Node IP 来进行 IPv4 转发。执行以下命令添加允许 IPv4 转发到 <code class="language-plaintext highlighter-rouge">/etc/sysctl.d/k8s.conf</code> 文件里，并且立即生效：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 添加配置</span>
<span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/sysctl.d/k8s.conf <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
net.ipv4.ip_forward = 1
net.bridge.bridge-nf-call-iptables = 1
net.bridge.bridge-nf-call-ip6tables = 1
</span><span class="no">EOF

</span><span class="c"># 立即生效</span>
<span class="nb">sudo </span>sysctl <span class="nt">--system</span>
</code></pre></div></div>

<h4 id="配置主机名对应">配置主机名对应</h4>

<p>  K8S 集群初始化时会自动搜索主机名的 DNS 解析，目前测试的主机名没有完整的 FQDN 或 PTR 解析，因此有必要设置好主机名和 IP 对应信息到本地静态 DNS 解析文件 <code class="language-plaintext highlighter-rouge">/etc/hosts</code> 中。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 分别在不同节点根据规划设置好主机名</span>
<span class="nb">sudo </span>hostnamectl set-hostname vm01
<span class="nb">sudo </span>hostnamectl set-hostname vm02
<span class="nb">sudo </span>hostnamectl set-hostname vm03

<span class="c"># 修改所有节点的 /etc/hosts</span>
<span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/hosts <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
192.168.120.1  vm01
192.168.120.2  vm02
192.168.120.3  vm03
</span><span class="no">EOF
</span></code></pre></div></div>

<h4 id="同步时间">同步时间</h4>

<p>  K8S 集群的运行必须保证节点的时间是完全同步的，否则容易造成某些未知的 Bug。比如证书的过期时间将会被某些时间不同步的节点错误判断。推荐使用同一时区和同一 NTP 服务器，如下即可完成设置。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 设置相同时区并查看</span>
<span class="nb">sudo </span>timedatectl set-timezone Asia/Shanghai
timedatectl
timedatectl status

<span class="c"># 修改 NTP 服务器</span>
<span class="nb">sudo </span>timedatectl set-ntp <span class="nb">false
sudo sed</span> <span class="nt">-i</span> <span class="s1">'s/#NTP=/NTP=ntp.lisz.top/'</span> /etc/systemd/timesyncd.conf
<span class="nb">sudo sed</span> <span class="nt">-i</span> <span class="s1">'s/#FallbackNTP=ntp.ubuntu.com/FallbackNTP=ntp.aliyun.com/'</span> /etc/systemd/timesyncd.conf
<span class="nb">sudo </span>timedatectl set-ntp <span class="nb">true</span>

<span class="c"># 重启服务使配置生效、同步时间并查看信息</span>
<span class="nb">sudo </span>systemctl restart systemd-timesyncd
timedatectl show-timesync <span class="nt">--all</span>
<span class="nb">date</span>
</code></pre></div></div>

<h3 id="安装必要软件和工具">安装必要软件和工具</h3>

<h4 id="安装-containerd">安装 containerd</h4>

<p>  containerd 虽然是由  containerd 开发团队负责发布，但是 APT 或 YUM 镜像源仍然是由 Docker 官方负责，所以当我们添加 docker-ce 的镜像源后可以直接下载 <code class="language-plaintext highlighter-rouge">containerd.io</code> 来安装 containerd。当然， 我们可以从 <a href="https://github.com/containerd/containerd/releases">containerd/containerd</a> 直接下载二进制可执行文件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 添加镜像源</span>
curl <span class="nt">-fsSL</span> https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu/gpg | <span class="nb">sudo </span>gpg <span class="nt">--dearmor</span> <span class="nt">-o</span> /etc/apt/trusted.gpg.d/docker.gpg
<span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/apt/sources.list.d/docker.list <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
    deb [arch=amd64 signed-by=/etc/apt/trusted.gpg.d/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu/ </span><span class="si">$(</span>lsb_release <span class="nt">-c</span> <span class="nt">--short</span><span class="si">)</span><span class="sh"> stable
</span><span class="no">EOF

</span><span class="c"># 更新软件列表缓存并安装 containerd</span>
<span class="nb">sudo </span>apt update <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>apt upgrade <span class="nt">-y</span> <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> containerd.io
</code></pre></div></div>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小建议 </div> </div> <div class="content"> <p>  个人推荐使用 APT 或 YUM 方式安装 containerd。原因有二：一是国内有 docker-ce 镜像安装比较快，二是想要更新时非常容易。</p>



 </div> </div>
<h4 id="配置-containerd">配置 containerd</h4>

<p>  containerd 安装后默认没有配置文件也不会自动启动后台程序，所以需要准备配置文件并复制到 <code class="language-plaintext highlighter-rouge">/etc/containerd/config.toml</code> 再启动。由于 K8S 集群默认使用 <code class="language-plaintext highlighter-rouge">registry.k8s.io</code> 和 <code class="language-plaintext highlighter-rouge">registry-1.docker.io</code> 源下载容器镜像，为了提升速度建议切换到阿里云和 DaoCloud 的加速器。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>containerd config default <span class="o">&gt;</span> containerd_config.toml
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s#registry.k8s.io#registry.cn-hangzhou.aliyuncs.com/google_containers#g"</span> containerd_config.toml
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"/containerd.runtimes.runc.options/a</span><span class="se">\ \ \ \ \ \ \ \ \ \ \ \ </span><span class="s2">SystemdCgroup = true"</span> containerd_config.toml
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s#https://registry-1.docker.io#https://docker.m.daocloud.io#g"</span> containerd_config.toml

<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/containerd
<span class="nb">cp </span>containerd_config.toml /etc/containerd/config.toml

<span class="nb">sudo </span>systemctl daemon-reload
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>containerd
<span class="nb">sudo </span>systemctl restart containerd

<span class="nb">sudo </span>systemctl status containerd.service <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>ctr <span class="nt">--version</span>
</code></pre></div></div>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  由于 <code class="language-plaintext highlighter-rouge">ctr</code> 命令连接的 containerd 的 socket 文件只有 root 用户组有权限访问，所以目前只能使用 <code class="language-plaintext highlighter-rouge">sudo ctr</code>。如果想要直接使用 <code class="language-plaintext highlighter-rouge">ctr</code> 命令，可以使用 <code class="language-plaintext highlighter-rouge">sudo usermod -aG root ubuntu</code> 来将当前用户添加到 root 用户组。赋权之后需退出登录后再次登录才能生效。</p>



 </div> </div>
<h4 id="安装-kubeadm-等">安装 kubeadm 等</h4>

<p>  国内清华大学 TUNA 镜像源、阿里云镜像源等都提供了 <code class="language-plaintext highlighter-rouge">kubeadm</code> 等三件套工具的 APT 或 YUM 源，通过以下命令可以很容易完全安装。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 友情提醒 </div> </div> <div class="content"> <p>  由于 kubernetes 不同版本可能会存在较大差异，并且为了避免节点 kubernetes 版本在不自觉的时候升级造成兼容性问题，这里推荐固定 kubeadm 等三件套版本号，即不启用 <code class="language-plaintext highlighter-rouge">apt upgrade</code> 自动升级。管理员关闭 K8S 集群手动升级版本时不受影响。</p>



 </div> </div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 添加镜像源</span>
curl <span class="nt">-fsSL</span> https://mirrors.tuna.tsinghua.edu.cn/kubernetes/core:/stable:/v1.30/deb/Release.key | <span class="nb">sudo </span>gpg <span class="nt">--dearmor</span> <span class="nt">-o</span> /etc/apt/keyrings/kubernetes-apt-keyring.gpg 
<span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/apt/sources.list.d/kubernetes.list <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://mirrors.tuna.tsinghua.edu.cn/kubernetes/core:/stable:/v1.30/deb/ / 
# deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://mirrors.tuna.tsinghua.edu.cn/kubernetes/addons:/cri-o:/stable:/v1.30/deb/ / 
</span><span class="no">EOF

</span><span class="c"># 更新软件列表缓存并安装 kubeadm 三件套</span>
<span class="nb">sudo </span>apt update <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> kubeadm kubelet kubectl 

<span class="c"># 固定 kubeadm 等三件套版本</span>
<span class="nb">sudo </span>apt-mark hold kubeadm 
<span class="nb">sudo </span>apt-mark hold kubelet 
<span class="nb">sudo </span>apt-mark hold kubectl
</code></pre></div></div>

<h3 id="初始化集群">初始化集群</h3>

<h4 id="预下载镜像">预下载镜像</h4>

<p>  在所有节点上使用以下命令提前下载好 K8S 集群所需的基本镜像，避免初始化时一直在等待各个节点下载镜像。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubeadm config images list | <span class="nb">sed</span> <span class="nt">-e</span> <span class="s1">'s/^/sudo ctr image pull /g'</span> <span class="nt">-e</span> <span class="s1">'s#registry.k8s.io#registry.cn-hangzhou.aliyuncs.com/google_containers#g'</span> | sh <span class="nt">-x</span>
</code></pre></div></div>

<h4 id="初始化控制节点">初始化控制节点</h4>

<p>  下载完所需的容器镜像后，在控制节点上使用 <code class="language-plaintext highlighter-rouge">sudo kubeadm init --config=kubeadm_config.yaml</code> 命令初始化控制节点。<code class="language-plaintext highlighter-rouge">kubeadm_config.yaml</code> 的内容如下所示：（建议将配置文件放置在 <code class="language-plaintext highlighter-rouge">~/k8s</code> 目录下，<code class="language-plaintext highlighter-rouge">cd ~/k8s</code> 目录后执行初始化命令。）</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kubeadm.k8s.io/v1beta3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">InitConfiguration</span>
<span class="na">localAPIEndpoint</span><span class="pi">:</span>
  <span class="na">advertiseAddress</span><span class="pi">:</span> <span class="s">192.168.120.1</span>
  <span class="na">bindPort</span><span class="pi">:</span> <span class="m">6443</span>
<span class="na">nodeRegistration</span><span class="pi">:</span>
  <span class="na">criSocket</span><span class="pi">:</span> <span class="s2">"</span><span class="s">unix:///run/containerd/containerd.sock"</span>
<span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kubeadm.k8s.io/v1beta3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ClusterConfiguration</span>
<span class="na">kubernetesVersion</span><span class="pi">:</span> <span class="s">stable</span>
<span class="na">imageRepository</span><span class="pi">:</span> <span class="s2">"</span><span class="s">registry.cn-hangzhou.aliyuncs.com/google_containers"</span>
<span class="na">networking</span><span class="pi">:</span>
  <span class="na">podSubnet</span><span class="pi">:</span> <span class="s">192.168.144.0/20</span>
  <span class="na">serviceSubnet</span><span class="pi">:</span> <span class="s">192.168.244.0/24</span>
</code></pre></div></div>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 友情提醒 </div> </div> <div class="content"> <p>  如果没有配置主机名对应的话，这里初始化会一直卡在 API Health 检测的步骤，实际上是因为没有主机名和 IP 对应而无法启动 API Server。</p>



 </div> </div>
<p>  kubeadm 初始化成功后需要复制验证文件才能在控制节点管理 K8S 集群，如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 复制验证文件</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$HOME</span>/.kube
<span class="nb">sudo cp</span> <span class="nt">-i</span> /etc/kubernetes/admin.conf <span class="nv">$HOME</span>/.kube/config
<span class="nb">sudo chown</span> <span class="si">$(</span><span class="nb">id</span> <span class="nt">-u</span><span class="si">)</span>:<span class="si">$(</span><span class="nb">id</span> <span class="nt">-g</span><span class="si">)</span> <span class="nv">$HOME</span>/.kube/config

<span class="c"># 查询节点状态</span>
kubectl get nodes <span class="nt">-o</span> wide
</code></pre></div></div>

<h4 id="工作节点加入集群">工作节点加入集群</h4>

<p>  刚才初始化集群后会出现工作节点加入集群的命令，形如：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubeadm <span class="nb">join </span>192.168.120.1:6443 <span class="nt">--token</span> z9sdsdi.tdeu74psxqi8rhdt <span class="se">\</span>
    <span class="nt">--discovery-token-ca-cert-hash</span> sha256:87c4f8dd9dabaf2e5e793c0404c74dd8f9f56153000dad3c1a3238a3e8b0beff
</code></pre></div></div>

<p>  注意这里需要加上 <code class="language-plaintext highlighter-rouge">sudo</code> 之后再在工作节点上执行加入集群操作。加入完成后可以在控制节点上使用 <code class="language-plaintext highlighter-rouge">kubectl get nodes -o wide</code> 查看是否有了刚加入的工作节点的信息。由于目前还没有配置网络组件，除了控制节点外，其他工作节点应该均为 <code class="language-plaintext highlighter-rouge">NotReady</code> 状态。如果使用 <code class="language-plaintext highlighter-rouge">kubectl get pods --all-namespaces</code> 命令查看所有启动的 Pod，应该看到除两个 CordDNS 的 Pod (比如 <code class="language-plaintext highlighter-rouge">0/1</code>) 以外的所有 Pod 的状态都是完成启动 (比如 <code class="language-plaintext highlighter-rouge">1/1</code>)。</p>

<p>  工作节点加入后可以配置不同的标签，比如如下是配置为工作节点和添加 <code class="language-plaintext highlighter-rouge">gputype</code> 字段标签：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl label node vm02 node-role.kubernetes.io/worker<span class="o">=</span>
kubectl label node vm03 node-role.kubernetes.io/worker<span class="o">=</span>
kubectl label node vm02 <span class="nv">gputype</span><span class="o">=</span>P100
kubectl label node vm03 <span class="nv">gputype</span><span class="o">=</span>A100
</code></pre></div></div>

<h3 id="添加组件">添加组件</h3>

<h4 id="配置-calico-网络">配置 Calico 网络</h4>

<p>  Calico 支持一套灵活的网络选项，可以根据情况选择最有效的选项，包括非覆盖和覆盖网络，带或不带 BGP。Calico 使用相同的引擎为主机、Pod 和应用程序在服务网格层执行网络策略。如下所示可以很简单地为 K8S 集群启用 Calico 网络：</p>

<ol>
  <li>创建 Calico 所需的 operator（需要镜像 <code class="language-plaintext highlighter-rouge">quay.io/tigera/operator:v1.34.5</code>，可提前下载），仅在控制节点创建 Pod；</li>
  <li>创建和初始化 K8S 集群时对应的网络规划，主要是 PodSubset 配置，如下面修改过的 yaml 配置文件。这里为了加速创建过程，还添加了 <code class="language-plaintext highlighter-rouge">registry</code> 字段来使用 DaoCloud 加速器。</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> ~/k8s/calico &amp; <span class="nb">cd</span> ~/k8s/calico
wget <span class="nt">-c</span> https://raw.githubusercontent.com/projectcalico/calico/v3.28.1/manifests/tigera-operator.yaml
wget <span class="nt">-c</span> https://raw.githubusercontent.com/projectcalico/calico/v3.28.1/manifests/custom-resources.yaml 
kubectl create <span class="nt">-f</span> tigera-operator.yaml 
kubectl create <span class="nt">-f</span> custom-resources.yaml
</code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This section includes base Calico installation configuration.</span>
<span class="c1"># For more information, see: https://docs.tigera.io/calico/latest/reference/installation/api#operator.tigera.io/v1.Installation</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">operator.tigera.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Installation</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="c1"># Configures Calico networking.</span>
  <span class="na">calicoNetwork</span><span class="pi">:</span>
    <span class="na">ipPools</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">default-ipv4-ippool</span>
      <span class="na">blockSize</span><span class="pi">:</span> <span class="m">26</span>
      <span class="na">cidr</span><span class="pi">:</span> <span class="s">192.168.144.0/20</span>
      <span class="na">encapsulation</span><span class="pi">:</span> <span class="s">VXLANCrossSubnet</span>
      <span class="na">natOutgoing</span><span class="pi">:</span> <span class="s">Enabled</span>
      <span class="na">nodeSelector</span><span class="pi">:</span> <span class="s">all()</span>
  <span class="na">registry</span><span class="pi">:</span> <span class="s">m.daocloud.io</span>
<span class="nn">---</span>

<span class="c1"># This section configures the Calico API server.</span>
<span class="c1"># For more information, see: https://docs.tigera.io/calico/latest/reference/installation/api#operator.tigera.io/v1.APIServer</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">operator.tigera.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">APIServer</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span> <span class="pi">{}</span>
</code></pre></div></div>

<p>  如果通过 <code class="language-plaintext highlighter-rouge">kubectl get pod --all-namespaces</code> 发现哪个相关 Pod 卡在了拉取镜像的步骤，可以手动镜像。一般来说，使用修改的 DaoCloud 加速器下载应该没什么太大问题。创建 Calico 网络完成后会多出来 3 个命名空间: <code class="language-plaintext highlighter-rouge">tigera-operator</code>、 <code class="language-plaintext highlighter-rouge">calico-system</code> 和 <code class="language-plaintext highlighter-rouge">calico-apiserver</code>。新增的 Pod 应该如下所示：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">节点主机名</th>
      <th style="text-align: left">新增 Pod</th>
      <th style="text-align: left">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">vm01</td>
      <td style="text-align: left">tigera-operator</td>
      <td style="text-align: left">Calico 网络所需的描述子</td>
    </tr>
    <tr>
      <td style="text-align: center">vm01</td>
      <td style="text-align: left">calico-kube-controller</td>
      <td style="text-align: left">Calico 网络控制器</td>
    </tr>
    <tr>
      <td style="text-align: center">vm01</td>
      <td style="text-align: left">calico-apiserver</td>
      <td style="text-align: left">Calico 网络 API，一般有两个 Pod</td>
    </tr>
    <tr>
      <td style="text-align: center">vm01</td>
      <td style="text-align: left">calico-typha</td>
      <td style="text-align: left">优化和减少 Calico 对 K8S API 服务器的负载</td>
    </tr>
    <tr>
      <td style="text-align: center">vm01</td>
      <td style="text-align: left">calico-node</td>
      <td style="text-align: left">Calico 网络节点客户端</td>
    </tr>
    <tr>
      <td style="text-align: center">vm01</td>
      <td style="text-align: left">csi-node-driver</td>
      <td style="text-align: left">CSI 驱动</td>
    </tr>
    <tr>
      <td style="text-align: center">vm02</td>
      <td style="text-align: left">calico-typha</td>
      <td style="text-align: left">优化和减少 Calico 对 K8S API 服务器的负载</td>
    </tr>
    <tr>
      <td style="text-align: center">vm02</td>
      <td style="text-align: left">calico-node</td>
      <td style="text-align: left">Calico 网络节点客户端</td>
    </tr>
    <tr>
      <td style="text-align: center">vm02</td>
      <td style="text-align: left">csi-node-driver</td>
      <td style="text-align: left">CSI 驱动</td>
    </tr>
    <tr>
      <td style="text-align: center">vm03</td>
      <td style="text-align: left">calico-node</td>
      <td style="text-align: left">Calico 网络节点客户端</td>
    </tr>
    <tr>
      <td style="text-align: center">vm03</td>
      <td style="text-align: left">csi-node-driver</td>
      <td style="text-align: left">CSI 驱动</td>
    </tr>
  </tbody>
</table>

<h4 id="配置-nfs-csi-驱动和存储类">配置 NFS CSI 驱动和存储类</h4>

<p>  NFS CSI 驱动由 <a href="https://github.com/kubernetes-csi/csi-driver-nfs">kubernetes-csi/csi-driver-nfs</a> 项目提供支持。不过在正式安装驱动之前需要先安装 NFS 客户端，否则 NFS CSI 驱动也无法正常启用。为了加速下载容器镜像，这里推荐将配置中的 <code class="language-plaintext highlighter-rouge">registry.k8s.io</code> 源切换到 <code class="language-plaintext highlighter-rouge">k8s.m.daocloud.io</code> 加速器。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 在所有节点安装 NFS 客户端支持</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> nfs-common

<span class="c"># 下载 NFS CSI Driver 配置文件</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> ~/k8s/csi <span class="o">&amp;&amp;</span> <span class="nb">cd</span> ~/k8s/csi
git clone https://github.com/kubernetes-csi/csi-driver-nfs.git 

<span class="c"># 修改容器镜像为 DaoCloud 加速器</span>
<span class="nb">cd </span>csi-driver-nfs/deploy/v4.9.0
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s/registry.k8s.io/k8s.m.daocloud.io/"</span> ./<span class="k">*</span>

<span class="c"># 返回上上层目录，并安装 NFS CSI 驱动</span>
<span class="nb">cd</span> ../../
./deploy/install-driver.sh v4.9.0 <span class="nb">local</span> 
</code></pre></div></div>

<p>  安装 NFS CSI 驱动后会在 <code class="language-plaintext highlighter-rouge">kube-system</code> 命名空间中多出四个 Pod，其中一个 Pod 为 <code class="language-plaintext highlighter-rouge">csi-nfs-controller</code>，其他每个节点一个 <code class="language-plaintext highlighter-rouge">csi-nfs-node</code> 的 Pod。然后需要使用 <code class="language-plaintext highlighter-rouge">kubectl apply -f nfs.yaml</code> 命令创建一个 NFS 的存储类用于提供给应用程序，配置文件 <code class="language-plaintext highlighter-rouge">nfs.yaml</code> 内容如下所示：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">storage.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">StorageClass</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nfs-csi</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="na">storageclass.kubernetes.io/is-default-class</span><span class="pi">:</span> <span class="s2">"</span><span class="s">true"</span>
<span class="na">provisioner</span><span class="pi">:</span> <span class="s">nfs.csi.k8s.io</span>
<span class="na">parameters</span><span class="pi">:</span>
  <span class="na">server</span><span class="pi">:</span> <span class="s">nfs_server_ip</span>
  <span class="na">share</span><span class="pi">:</span> <span class="s">/home/data</span>
<span class="na">reclaimPolicy</span><span class="pi">:</span> <span class="s">Retain</span>
<span class="na">volumeBindingMode</span><span class="pi">:</span> <span class="s">Immediate</span>
<span class="na">allowVolumeExpansion</span><span class="pi">:</span> <span class="kc">true</span>
<span class="na">mountOptions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">async</span>
  <span class="pi">-</span> <span class="s">rsize=32768</span>
  <span class="pi">-</span> <span class="s">wsize=32768</span>
  <span class="pi">-</span> <span class="s">nconnect=8</span>
  <span class="pi">-</span> <span class="s">nfsvers=4.1</span>
  <span class="pi">-</span> <span class="s">hard</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看新增的存储类</span>
╰─<span class="nv">$ </span>kubectl get sc
NAME                PROVISIONER      RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
nfs-csi <span class="o">(</span>default<span class="o">)</span>   nfs.csi.k8s.io   Retain          Immediate           <span class="nb">true                   </span>4d1h
</code></pre></div></div>

<h4 id="gpu-支持">GPU 支持</h4>

<p>  K8S 的 GPU 支持是由 NVIDIA 提供的，需要工作节点先安装 NVIDIA 驱动和容器驱动，再在控制节点上部署 nvidia-device 插件支持。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看可安装 NVIDIA 驱动</span>
╰─<span class="nv">$ </span>ubuntu-drivers devices
modalias : pci:v000010DEd000026BAsv000010DEsd00001957bc03sc02i00
vendor   : NVIDIA Corporation
driver   : nvidia-driver-550-open - distro non-free
driver   : nvidia-driver-550 - distro non-free recommended
driver   : nvidia-driver-535-server - distro non-free
driver   : nvidia-driver-535-server-open - distro non-free
driver   : nvidia-driver-535-open - distro non-free
driver   : nvidia-driver-535 - distro non-free
driver   : xserver-xorg-video-nouveau - distro free <span class="nb">builtin</span>

<span class="c"># 安装 NVIDIA 驱动，并重启生效</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> nvidia-driver-535
<span class="nb">sudo </span>apt-mark hold nvidia-driver-535

<span class="c"># 添加 NVIDIA Container Toolkit 源</span>
curl <span class="nt">-fsSL</span> https://mirrors.ustc.edu.cn/libnvidia-container/gpgkey | <span class="nb">sudo </span>gpg <span class="nt">--dearmor</span> <span class="nt">-o</span> /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg <span class="se">\</span>
<span class="o">&amp;&amp;</span> curl <span class="nt">-s</span> <span class="nt">-L</span> https://mirrors.ustc.edu.cn/libnvidia-container/stable/deb/nvidia-container-toolkit.list | <span class="se">\</span>
    <span class="nb">sed</span> <span class="s1">'s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g'</span> | <span class="se">\</span>
    <span class="nb">sudo tee</span> /etc/apt/sources.list.d/nvidia-container-toolkit.list

<span class="c"># 更新软件列表缓存，安装 nvidia-container-toolkit</span>
<span class="nb">sudo </span>apt-get update <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> nvidia-container-toolkit

<span class="c"># 为 containerd 容器运行时增加 NVIDIA 选项</span>
<span class="nb">sudo </span>nvidia-ctk runtime configure <span class="nt">--runtime</span><span class="o">=</span>containerd

<span class="c"># 修改 /etc/containerd/config.toml 配置文件中默认运行时为 NVIDIA</span>
<span class="c"># 原来的默认运行时是 runc</span>
<span class="o">[</span>plugins.<span class="s2">"io.containerd.grpc.v1.cri"</span>.containerd]
      default_runtime_name <span class="o">=</span> <span class="s2">"nvidia"</span>

<span class="c"># 重新加载 containerd 配置文件并重启服务生效</span>
<span class="nb">sudo </span>systemctl daemon-reload
<span class="nb">sudo </span>systemctl restart containerd

<span class="c"># 在控制节点为 K8S 集群创建 NVIDIA device 插件支持</span>
<span class="nb">cd</span> ~/k8s
wget <span class="nt">-c</span> https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/v0.16.2/deployments/static/nvidia-device-plugin.yml

<span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"s/nvcr.io/nvcr.m.daocloud.io/"</span> nvidia-device-plugin.yml
kubectl create <span class="nt">-f</span> nvidia-device-plugin.yml

<span class="c"># 验证 GPU 是否被 K8S 识别</span>
kubectl describe node vm02 | <span class="nb">grep </span>nvidia.com/gpu:
</code></pre></div></div>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  NVIDIA GPU 驱动和容器驱动只需在有 NVIDIA GPU 的工作节点上配置，并且<strong>一定要修改默认运行时为 NVIDIA</strong>，否则无法被 K8S 识别。NVIDIA device 插件支持在控制节点上提交安装请求但会在每一个工作节点上安装，即使没有 NVIDIA GPU 存在。</p>



 </div> </div>
<h2 id="可能遇到的问题和解答">可能遇到的问题和解答</h2>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 如果各节点本身没有任何网络，需要使用内部 HTTP 代理上网怎么办？ </div> </div> <div class="content"> <p>  这种情况下需要为 kubelet 和 containerd 的 service 设置代理。kubelet 的配置文件为 <code class="language-plaintext highlighter-rouge">/usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</code>，containerd 的配置文件为 <code class="language-plaintext highlighter-rouge">/usr/lib/systemd/system/containerd.service</code>。配置内容如下所示。配置完后需要使用 <code class="language-plaintext highlighter-rouge">sudo systemctl daemon-reload</code> 来应用配置更改，并且使用 <code class="language-plaintext highlighter-rouge">sudo systemctl restart kubelet</code> 和 <code class="language-plaintext highlighter-rouge">sudo systemctl restart containerd</code> 重启服务。</p>



 </div> </div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># sudo vim /usr/lib/systemd/system/containerd.service</span>
<span class="c"># sudo vim /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</span>

<span class="o">[</span>Service]
...
<span class="nv">Environment</span><span class="o">=</span><span class="s2">"HTTP_PROXY=http://proxy.ip:3128"</span>
<span class="nv">Environment</span><span class="o">=</span><span class="s2">"HTTPS_PROXY=http://proxy.ip:3128"</span>
<span class="nv">Environment</span><span class="o">=</span><span class="s2">"NO_PROXY=localhost,127.0.0.1"</span>
</code></pre></div></div>

<h2 id="结语">结语</h2>

<p>  K8S 集群的搭建并非一件十分复杂的事情，比较复杂的是根据实际的需求和自己对于 K8S 的理解来搭建出更合适的 K8S 集群。虽然 K8S 集群已经逐步开始取代一般的 Docker 单机应用服务部署方案，但是就个人实际的应用规模或者应用本身而言，K8S 集群本身的维护和调整的代价要远高于 Docker 单机应用服务部署。如果是有高可用性、高可靠性等的需求，那么 K8S 可能是目前最好的需求。</p>

<p>  正如在前言中所述，有了 K8S 持续开发、持续集成和持续部署成为了现实，开发者可以把更多的注意力都放在应用代码开发。同时，类似于 JupyterHub 这类会有动态扩展和分配资源需求的应用，最佳的部署方式可能就是 K8S 了。当然，听说现在的大模型 ChatGPT 等也都是在 K8S 上训练出来的。</p>

<p>  K8S 的确是大有可为！</p>

<h2 id="参考资料">参考资料</h2>

<ol>
  <li><a href="https://www.blackduck.com/en-us/glossary/what-is-continuous-development.html">Continuous Development</a></li>
  <li><a href="https://aws.amazon.com/cn/devops/continuous-integration/">AWS – 什么是持续集成？</a></li>
  <li><a href="https://www.ibm.com/topics/continuous-deployment">IBM – What is continuous deployment?</a></li>
  <li><a href="https://circleci.com/blog/docker-swarm-vs-kubernetes/">Docker Swarm vs Kubernetes: how to choose a container orchestration tool</a></li>
  <li><a href="https://zh.wikipedia.org/zh-cn/Kubernetes">维基百科 – Kubernetes</a></li>
  <li><a href="https://www.ibm.com/blogs/solutions/jp-ja/container-cocreation-center-05/">IBM – 第5回 『Red Hat OpenShift と Kubernetes の違い』</a></li>
  <li><a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/">Kubernetes 文档 - 概念 - Kubernetes 架构</a></li>
  <li><a href="https://cloud.tencent.com/developer/article/1852347">基于 Containerd 运行时搭建 Kubernetes 集群实践</a></li>
</ol>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="k8s" /><category term="Kubernetes" /><category term="K8S" /><category term="kubeadm" /><category term="calico" /><category term="flannel" /><category term="csi-driver" /><category term="NFS" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">生活中的小问题——公交计费问题</title><link href="https://lisz.me/tech/algorithm/bus-ticket.html" rel="alternate" type="text/html" title="生活中的小问题——公交计费问题" /><published>2024-07-02T15:15:00+09:00</published><updated>2024-07-02T15:15:00+09:00</updated><id>https://lisz.me/tech/algorithm/bus-ticket</id><content type="html" xml:base="https://lisz.me/tech/algorithm/bus-ticket.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  谈到生活中经常坐的公交车，比较常见的算法问题可能是寻找“耗时最少公交路线”、“最少换乘公交路线”、“最便宜公交路线”、“综合最优公交路线”等。这些算法由于在地图软件中经常被使用，已经被大家研究得非常透彻，比如 Dijkstra 算法就可以用来计算“最短距离公交路线”。如想了解更多，可以阅读参考资料 2 给出的中文文献。</p>

<p>  相比这些常见的算法问题，不如让我们来一起看看不大被人提及的“公交计费问题”。笔者经常在下雨的时候乘坐公交车，每次上车前会先取一张票，然后下车前可以看屏幕显示来知道票价。于是笔者就有了一个小问题：票价是如何正确显示的，是否可以对其建模并写个小程序模拟一下。</p>

<h2 id="问题描述">问题描述</h2>

<p>  如图 1 所示为公交计费问题描述。</p>

<ul>
  <li><strong>(a) 公交路线图</strong>（图中为右循环路线，但对应的左循环路线也存在），0~20 为站点编号，且 1~3 与 20~18 分别对应相同。公交从站点 0 出发，按照箭头所指的方向依次行进，最终回到站点 0 并停止运行。</li>
  <li><strong>(b) 相邻站点间距离</strong>，以 km 为距离计算单位，给出的数值为公交在站点间实际行进距离。</li>
  <li><strong>(c) 公交票价计算方式</strong>，距离不足 2 km 为基本票价 190 日元，超过 2 km 的话每超过 1 km 加收 50 日元，如不足 1 km 按照 1 km 计算。注意，此处的距离为循环线路中上车站点与下车站点的<strong>有效距离</strong>，即站点间在循环线路上的最短距离而非实际运行距离。比如，即使从站点 0 上车，经过一圈循环后再从站点 0 下车，也只能收取基本票价 190 日元，因为有效距离为 0 km。（以上计算方式参考自资料 3）</li>
  <li><strong>(d) 公交最后返回起始站点时计费状态</strong>，灰底色为站点编号，白底色为票价。</li>
</ul>

<p><img src="https://i.lisz.top/blog/GTgvbN.webp" alt="图 1. 公交计费问题描述。 The description of bus ticket problem." /></p>

<h3 id="问题目标">问题目标</h3>

<ol>
  <li>打印欢迎消息，提示是否从站点 0 发车；</li>
  <li>发车后，通过回车或其他操作在下一站点停车，打印当前票价状态，尚未抵达站点票价为空；</li>
  <li>经过循环后回到站点 0，通过回车或其他操作停车，打印当前票价状态，如图 1(d) 所示。</li>
</ol>

<h2 id="解决方案">解决方案</h2>

<h3 id="问题分析">问题分析</h3>

<p>  解决公交计费问题，首先要将图 1 中给出的信息进行集成，可得如下图 2。其中，站点间的橙色数字为相邻站点间距离，红色数字为几个关键（0~2 km，2~3 km 和 3~4 km 的阈值站点）站点与出发站点 0 之间的<strong>有效距离</strong>。</p>

<p><img src="https://i.lisz.top/blog/DD2KNn.webp" alt="图 2. 信息集成后的公交路线图。 The route including the distances and some importance valid distances." /></p>

<p>  其实整个问题的核心就在于对<strong>有效距离</strong>的理解。从题干可知，有效距离并非是实际行进距离。这主要是因为给出的公交路线是环线而非直线，即出发站点与结束站点为同一站点。除此之外，刚开始的 1~3 与最后的 20~18 三个站点是重合的。根据给出的例子解释，我们可以将这里的“<strong>有效距离</strong>”粗略定义为“<strong>上车站点与下车站点在公交路线上正反距离的最小值</strong>”。我们不妨从以下示例中进一步加深对于“<strong>有效距离</strong>”的理解：（~ 表示“大约”）</p>

<ul>
  <li><strong>例 1</strong>：上车站点为站点 3，下车站点为站点 17。因为站点 3 与站点 18 重合，所以有效距离等同于站点 17 和 18 之间的距离 0.45 km。</li>
  <li><strong>例 2</strong>：上车站点为站点 5，下车站点为站点 18。如例 1 方式计算可得有效距离为 0.85 km。</li>
  <li><strong>例 3</strong>：上车站点为站点 4，下车站点为站点 17。虽然按照路线实际行进距离很远，但是实际两站之间路线上最短距离大约为 0.45 km，即有效距离为 ~0.45 km。</li>
  <li><strong>例 4</strong>：上车站点为站点 5，下车站点为站点 15。如例 2 方式计算可得有效距离为 ~1.6 km。</li>
  <li><strong>例 5</strong>：上车站点为站点 6，下车站点为站点 14。按照图中方向实际行进距离计算，可知正向距离为 2.75 km，按照路线上最短反向距离为 ~2.25 km，因此有效距离为 ~2.25 km。</li>
</ul>

<p>得出总结：</p>

<ul>
  <li>从例 1、2 可以看出，当上车站点和下车站点分别在重合直线和循环圈上时，位于重合直线上的站点需要注意切换到对应站点进行双重计算正反向距离，从而得到正确的有效距离。</li>
  <li>从例 3~5 可以看出，当上车站点和下车站点均在循环圈上时，计算反向距离不涉及直线站点（即跨过出发站点 0）。即使站点 17 到站点 4 的实际行进路线不存在，也需以站点 17 到站点 4 闭合的循环圈来进行计算反向距离。</li>
</ul>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 为何不跨过出发站点 0 计算反向距离？ </div> </div> <div class="content"> <p>  题干中给出信息“<strong>公交从站点 0 出发最终回到站点 0 并停止运行</strong>”，鉴于任何跨过出发站点 0 计算的距离实际上只可能由两辆公交车完成，不可能出现在一辆公交的票价计算方式中，当只在循环圈上的站点上下车时应该不考虑直线上的站点（0~3、18~20）。</p>

<p>  说句题外话，如例 3~5 所示，可能直接走过去还更快更方便，而非坐这趟公交。</p>



 </div> </div>
<h3 id="算法描述">算法描述</h3>

<h4 id="变量声明">变量声明</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: center">变量名</th>
      <th style="text-align: center">变量类型</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">distances</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">站点列表，[0, 0.2, 0.3, …]</td>
    </tr>
    <tr>
      <td style="text-align: center">currentStop</td>
      <td style="text-align: center">int</td>
      <td style="text-align: left">当前站点编号，0</td>
    </tr>
    <tr>
      <td style="text-align: center">lineStops</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">直线站点，[1, 2, 3, 18, 19, 20]</td>
    </tr>
    <tr>
      <td style="text-align: center">circleStops</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">循环圈站点，[4, 5, …, 17]</td>
    </tr>
    <tr>
      <td style="text-align: center">ticketBase</td>
      <td style="text-align: center">float</td>
      <td style="text-align: left">基础票价，190.00</td>
    </tr>
    <tr>
      <td style="text-align: center">ticketStep</td>
      <td style="text-align: center">float</td>
      <td style="text-align: left">票价梯度，50.00</td>
    </tr>
    <tr>
      <td style="text-align: center">ticketUnit</td>
      <td style="text-align: center">str</td>
      <td style="text-align: left">票价单位，JPY</td>
    </tr>
    <tr>
      <td style="text-align: center">baseDistance</td>
      <td style="text-align: center">float</td>
      <td style="text-align: left">基础距离，2.00</td>
    </tr>
    <tr>
      <td style="text-align: center">stepDistance</td>
      <td style="text-align: center">float</td>
      <td style="text-align: left">基础距离，1.00</td>
    </tr>
    <tr>
      <td style="text-align: center">distanceUnit</td>
      <td style="text-align: center">str</td>
      <td style="text-align: left">距离单位，km</td>
    </tr>
    <tr>
      <td style="text-align: center">validDistances</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">有效距离，长度为 21，默认值为 None</td>
    </tr>
    <tr>
      <td style="text-align: center">prices</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">票价，长度为 21，默认值为 None</td>
    </tr>
    <tr>
      <td style="text-align: center">validStops</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">有效站点，经过站点时将编号添加到列表里，默认为 [0]</td>
    </tr>
  </tbody>
</table>

<h4 id="步骤描述">步骤描述</h4>

<p>  程序整体步骤：</p>

<ol>
  <li>初始化变量，当前站点编号为 0，询问是否启动；接受到启动指令（回车）后开始行进（提示）。</li>
  <li>遇到停车指令（回车）后，切换站点编号为下一站点（+1），添加站点编号到 validStops。</li>
  <li>循环计算 validStops 中各站点的有效距离 validDistances（具体见下）。</li>
  <li>循环计算各站点的票价同时更新 prices。</li>
  <li>打印计费矩阵。</li>
  <li>接受到启动指令（回车）后继续行进（提示），重复 2~5 步骤直至重新回到站点 0。</li>
  <li>打印到达终点站提示信息，结束程序。</li>
</ol>

<p>  计算任意两个上下车站点间的有效距离的步骤：</p>

<ol>
  <li>已知上车站点 a 和下车站点 b，当两站点相同时有效距离为 0，如不同进入下一步骤。</li>
  <li>利用 lineStops 和 circleStops 两个变量判断 a 和 b 位于直线部分或循环圈部分。</li>
  <li>如果两站点都是直线部分，利用对称方式标准化为 1~3 的站点编号，直接计算之间距离为有效距离。</li>
  <li>如果两站点都是循环圈部分，利用 circleStops 进行循环遍历叠加计算正反距离，取较小的值为有效距离。</li>
  <li>如果一站点在直线部分、一站点在循环圈部分，对直线部分的站点（标准化后的 1~3 站点）计算正反距离，取较小的值为有效距离。</li>
  <li>返回有效距离。</li>
</ol>

<h3 id="程序模拟">程序模拟</h3>

<p>  根据以上思路，笔者采用 Python 实现了解决方案。源代码请见 <a href="https://gist.github.com/zhonger/3546f08c0fe5b3e4ea360288a6b15d42">Github Gist</a>。以下为程序模拟运行效果：</p>

<script src="https://asciinema.org/a/666775.js" id="asciicast-666775" async="true"></script>

<h2 id="结语">结语</h2>

<p>  虽然现有的公交线路大部分还是很规则的，不同时存在循环圈和直线的情况，计费也较为简单，但是思考特殊公交线路的计费方式也不失为一件有趣的事情。上面给出的分析和算法描述，也可以用其他编程语言实现，比如用前端编程语言就可以直接可视化整个公交计费过程。</p>

<h2 id="参考资料">参考资料</h2>

<ol>
  <li><a href="https://www.freecodecamp.org/chinese/news/dijkstras-shortest-path-algorithm-visual-introduction/">图文详解 Dijkstra 最短路径算法</a></li>
  <li><a href="https://zhangroup.aporc.org/images/files/1.pdf">周文峰等，《运筹与管理》，<strong>最优公交线路选择问题的数学模型及算法</strong>，2018</a></li>
  <li><a href="https://www.kantetsu.co.jp/cms/wp-content/uploads/2024/02/801e8420390b8e91fa42443e742d6c27.pdf">筑波大学循环线票价表</a></li>
</ol>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="algorithm" /><category term="algorithm" /><category term="算法" /><category term="program" /><category term="代码实现" /><category term="python" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">命令行工具开发指南——入门篇</title><link href="https://lisz.me/tech/cli/introduction.html" rel="alternate" type="text/html" title="命令行工具开发指南——入门篇" /><published>2024-05-29T17:15:00+09:00</published><updated>2024-05-29T17:15:00+09:00</updated><id>https://lisz.me/tech/cli/introduction</id><content type="html" xml:base="https://lisz.me/tech/cli/introduction.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  <strong>命令行工具</strong>（Command Line，Cli）作为我们日常开发常用的辅助性工具，几乎遍布于各种操作中。根据<strong>使用目的</strong>的不同大致可以分为以下几类：</p>

<ul>
  <li><strong>从模板中生成项目</strong>：比如使用 <code class="language-plaintext highlighter-rouge">npm init</code> 从空模版创建一个新的 NodeJS 项目，使用 <code class="language-plaintext highlighter-rouge">composer create-project laravel/laravel example-app</code> 创建一个全新的 Laravel 项目（PHP 项目）等。</li>
  <li><strong>启用开发者服务模式</strong>：比如使用 <code class="language-plaintext highlighter-rouge">python -m http.server 8000</code> 在 8000 端口开启一个临时 HTTP 服务器，使用 <code class="language-plaintext highlighter-rouge">bundle exec jekyll s</code> 在 4000 端口开启一个临时 Jekyll 服务器等。</li>
  <li><strong>特定功能交互</strong>：比如流行的 IP 信息查询工具 <a href="https://github.com/zu1k/nali">nali</a>、磁盘空间利用率和空余空间查询工具 <a href="https://github.com/muesli/duf">duf</a>、快速磁盘使用分析工具 <a href="https://github.com/dundee/gdu">gdu</a> 等。</li>
</ul>

<p>  其实任何编程语言都可以用来开发命令行工具，无论是常见的 Golang、Python、NodeJS、PHP、Java，还是 Rust、Ruby、C++、C 或者是古老的 Fortran 等。只是取决于所要实现的功能和具体的使用场景，开发者会采用合适的编程语言开发命令行工具。比如说，Linux 系统中包含了大量的命令行工具，基本上都是用 C 语言编写的，主要是因为 C 语言在 Linux 系统中的执行效率相对更高。对于一般高级编程语言，自带的包管理工具也是由自身高级编程语言编写的命令行工具。类似 Rust、Fortran 等编译型语言则需要通过编译生成<strong>二进制可执行文件</strong>后才能执行相应的任务。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 二进制可执行文件与源文件有何不同？ </div> </div> <div class="content"> <p>   二进制可执行文件是指源代码通过编译器编译成计算机可以直接识别的二进制码文件。二进制码文件是无法使用任何源码编辑器打开的，只能由操作系统调用执行或特别的二进制码查看器打开。一般来说，二进制可执行文件是很难跨越操作系统的，即针对不同的操作系统需要分别编译生成对应的二进制可执行文件。<u>尤其是当有其他静态库或者动态链接库依赖时，二进制可执行文件甚至无法跨主机运行</u>。 而源文件是可以在任何操作系统用源码编辑器打开的。大多时候商业公司为了保证源代码的商业版权，只会为用户提供应用的二进制可执行文件。（当然一般可能是包含图形用户界面的。）</p>



 </div> </div>
<h2 id="为何命令行而非图形界面">为何命令行而非图形界面</h2>

<p>  命令行可以说是操作系统应用和编程语言编写应用最基本的形式，图形（用户）界面（Graphic User Interface，GUI）则是在源代码的基础上提供可视化的交互方式、通过键鼠操作来降低用户使用的门槛。这也是为什么 Windows 操作系统比 Linux 操作系统更加流行的原因之一。<strong>但是有的时候，界面也有可能会成为用户学习和使用的累赘。</strong></p>

<h3 id="简单界面-vs-复杂界面">简单界面 vs 复杂界面</h3>

<p>  就拿代码编辑器来说，我们所熟知的“宇宙第一编辑器” Visual Studio 几乎支持所有编程语言，尤其是对于构建 C# 项目来说可以<strong>半代码半可视化修改</strong>。尽管这在很大程度上降低了开发者使用成本，但是学习 Visual Studio 编辑器本身的成本却很高。（说句老实话，笔者从大学本科开始接触 Visual Studio 到现在都没怎么学会使用，😂只会最基本的功能而已。）而且，在普通笔记本电脑上使用 Visual Studio 编辑器运行大型项目时，CPU 和内存资源极大可能会被大量占用，打开一个浏览器页面可能也很艰难。</p>

<p>  相比而言，同样由微软推出的 Visual Studio Code 则是简单界面的优秀代表。化繁为简，Visual Studio Code 本身仅支持最简单的功能：文件目录区、编辑区、终端区三部分布局，基本的代码高亮功能，插件功能，主题功能等。无论是 Python 开发者，还是 Golang 开发者，都能一打开直接上手，只是需要根据编程语言不同安装一些插件来提升开发效率而已。在系统占用资源方面，Visual Studio Code 比 Visual Studio 显著降低，尽管可能也会受安装插件的少量影响。当然有得也有舍，Visual Studio Code 中支持更多文件定义配置或命令行配置，对于没有学过 Linux 的用户可能会有点学习难度。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> Linux 哲学 </div> </div> <div class="content"> <p>  “一切皆文件”。任何系统、项目、工具都是由一系列的文件组成的，通过配置文件可以实现直接管理。</p>

<p>  虽然这是 Linux 系统设计的哲学思想，但其实是所有操作系统设计的哲学思想，只是顶层封装的程度有所不同。Windows 系统也是“一切皆文件”的，不然那些编辑器的配置都存在哪里了呢。相比 Linux 和 MacOS 系统而言，Windows 系统的顶层封装程度最高，用户对于底层文件的直接管理非常少，尤其是对系统级别的配置管理只能通过图形界面交互完成。MacOS 系统则是介于两者之间，顶层封装程度虽然高但也提供对大部分系统级别配置的直接管理，即可以通过修改文件来实现管理。尽管依旧存在有些系统级别配置难以直接修改，比如说操作系统启动项。</p>



 </div> </div>
<h3 id="更简单的命令行">更简单的命令行</h3>

<p>  界面在执行系列任务时一般需要多步操作，一顿点点点之后才能完成。当然如果图形界面和功能设计的比较合理的话，可能也只需要一步操作。当我们需要进行批量操作时，即使图形界面只需要一步操作，依旧需要一顿点点点。命令行则没有这种问题，只需要简单写个有循环的脚本即可循环调用命令行工具批量执行。</p>

<p>  另外，命令行工具仅在执行时会占用系统资源，一旦完成即可完全释放。图形界面应用一般需要常驻后台，虽然优化得好的时候所占用的系统资源也可忽略不计，但是还是会有后台进程的。</p>

<p>  尽管命令行工具极少会有显式的界面交互，但是也可以在终端提供非常丰富的命令行交互、功能解释、自动补全、自动建议等。用户使用起来一般没有太大问题，只需要调用子命令和参数即可实现操作。</p>

<h2 id="命令行工具开发">命令行工具开发</h2>

<h3 id="设计标准和规范">设计标准和规范</h3>

<p>  命令行工具开发通常依据两个标准和规范进行：POSIX (Protable Operating System Interface，可移植操作系统接口) 标准和 GNU (GNU’s Not Unix) 项目。POSIX 标准是 IEEE 为维护操作系统间适配性而制定的一系列标准，其中一个标准定义了命令行程序的语法和语义。GNU 旨在创建与 Unix 兼容的自由软件，其中一个子项目 <a href="https://www.gnu.org/software/coreutils/">GNU Coreutils</a> 提供了很多常用的命令行程序，比如 <code class="language-plaintext highlighter-rouge">ls</code>、<code class="language-plaintext highlighter-rouge">cp</code> 和 <code class="language-plaintext highlighter-rouge">mv</code> 等。据此为命令行程序建立了以下的设计标准和规范：</p>

<ul>
  <li>单字母标志 (single-letter flag) 以一个短横线 <code class="language-plaintext highlighter-rouge">-</code> 开始，且可以合并使用：比如 <code class="language-plaintext highlighter-rouge">-d</code> (全称 <code class="language-plaintext highlighter-rouge">--debug</code>) 和 <code class="language-plaintext highlighter-rouge">-v</code> (全称 <code class="language-plaintext highlighter-rouge">--version</code>) 合并使用 <code class="language-plaintext highlighter-rouge">-dv</code> 来以调试模式输出命令行版本号。</li>
  <li>长标志 (long flag) 以两个短横线 <code class="language-plaintext highlighter-rouge">--</code> 开始，但无法合并使用：比如 <code class="language-plaintext highlighter-rouge">--debug</code> 或 <code class="language-plaintext highlighter-rouge">--version</code> 可以被命令行正常解析，但 <code class="language-plaintext highlighter-rouge">--debugversion</code> 无法被正常解析。</li>
  <li>选项 (Options) 跟在单字母标志后没有分隔符，但跟在长标志后使用等号 <code class="language-plaintext highlighter-rouge">=</code> 来分隔标志和选项值：比如 <code class="language-plaintext highlighter-rouge">-n example</code> 和 <code class="language-plaintext highlighter-rouge">--name=example</code> 分别为单字母标志和长标志的选项用法，二者完全等价。</li>
  <li>参数 (Args) 跟在标志或选项之后时没有任何分隔符，仅有空格：比如 <code class="language-plaintext highlighter-rouge">curl -o out.html https://www.google.com</code> 中的 <code class="language-plaintext highlighter-rouge">https://www.google.com</code> 是参数，一般用法类似 <code class="language-plaintext highlighter-rouge">curl [Options] &lt;Arg&gt;</code>。</li>
  <li>子命令 (Sub command) 与主命令之间没有分隔符，仅有空格：比如 <code class="language-plaintext highlighter-rouge">git commit</code> 中 <code class="language-plaintext highlighter-rouge">git</code> 是主命令、<code class="language-plaintext highlighter-rouge">commit</code> 是子命令。</li>
  <li>单独的两个短横线 <code class="language-plaintext highlighter-rouge">--</code>（后不接标志）表示标志或选项的结束和参数的开始：比如 <code class="language-plaintext highlighter-rouge">rm -- -f</code> 中的 <code class="language-plaintext highlighter-rouge">-f</code> 表示的是要删除的文件 <code class="language-plaintext highlighter-rouge">-f</code>，而不是强制删除文件的选项。</li>
</ul>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 提示 </div> </div> <div class="content"> <p>  按照以上设计标准和规范开发的命令行工具使用体验会与常用的命令保持一致，对于用户来说非常容易上手，这也是制定设计标准和规范的主要原因。</p>



 </div> </div>
<h3 id="功能设计">功能设计</h3>

<p>  核心功能设计主要是指命令行工具所支持的子命令、参数、选项设计。其中，子命令表示功能集合，参数表示输入输出变量，选项表示功能的微调。如下所示为笔者开发的命令行工具 <a href="../../../tech/project/pictl.html">pictl</a> （基于 Python 语言开发）的帮助信息。目前提供四个子命令：<code class="language-plaintext highlighter-rouge">config</code>（配置基本信息），<code class="language-plaintext highlighter-rouge">compress</code>（压缩任意图片为 <code class="language-plaintext highlighter-rouge">webp</code> 格式）,<code class="language-plaintext highlighter-rouge">upload</code>（上传图片）和 <code class="language-plaintext highlighter-rouge">cup</code>（压缩并上传图片）。全局只支持 <code class="language-plaintext highlighter-rouge">-h</code>（<code class="language-plaintext highlighter-rouge">--help</code>）打印帮助信息和 <code class="language-plaintext highlighter-rouge">-V</code>（<code class="language-plaintext highlighter-rouge">--version</code>）打印版本信息两个选项。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl
Usage: pictl <span class="o">[</span>OPTIONS] COMMAND <span class="o">[</span>ARGS]...

  A <span class="nb">command </span>line tool <span class="k">for </span>image processing and uploading <span class="o">(</span>ex. S3-type<span class="o">)</span><span class="nb">.</span>

  Now it supports:
    - transformation from other image types to <span class="sb">`</span>webp<span class="sb">`</span> image as well as
      image compression.
    - image file uploading to AWS S3 or Cloudflare R2.

Options:
  <span class="nt">-V</span>, <span class="nt">--version</span>  Show the pictl version.
  <span class="nt">-h</span>, <span class="nt">--help</span>     Show this message and exit.

Commands:
  compress  Compress any image into <span class="sb">`</span>webp<span class="sb">`</span> image.
  config    Operations <span class="k">for </span>the config file <span class="sb">`</span>~/.pictlrc<span class="sb">`</span><span class="nb">.</span>
  cup       Compress image and upload to remote storage <span class="o">(</span>compress and...
  upload    Upload the file to remote storage.
</code></pre></div></div>

<h4 id="子命令">子命令</h4>

<p>  <strong>子命令是否越少越好或者越多越好？亦或是不多不少比较好？</strong>其实，根据实际功能需求的不同子命令的数量会有很大的差异。比如上面提到的 pictl 目前所支持的子命令只有 4 个，curl 不支持子命令但支持选项超过 20 个，git 支持的常用子命令多达 22 个（如下所示，实际子命令可能接近 100 个），docker 支持的子命令超过 30 个。子命令实际上是可以多层迭代调用的，即可以存在多层级。但是在功能设计时，一般将对同一对象操作的功能归类到同一子命令下面，形成多层级子命令。当然为了简化子命令的层级调用，最多的实践方式就是类似于 git 中的<strong>用选项来代替多层的子命令</strong>。比如 <code class="language-plaintext highlighter-rouge">git branch</code> 子命令是对分支（branch）的列举（<code class="language-plaintext highlighter-rouge">git branch -l</code>）、创建（<code class="language-plaintext highlighter-rouge">git branch &lt;name&gt;</code>）和删除（<code class="language-plaintext highlighter-rouge">git branch -d &lt;name&gt;</code>）的功能集合。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>git <span class="nt">-h</span>
usage: git <span class="o">[</span><span class="nt">-v</span> | <span class="nt">--version</span><span class="o">]</span> <span class="o">[</span><span class="nt">-h</span> | <span class="nt">--help</span><span class="o">]</span> <span class="o">[</span><span class="nt">-C</span> &lt;path&gt;] <span class="o">[</span><span class="nt">-c</span> &lt;name&gt;<span class="o">=</span>&lt;value&gt;]
           <span class="o">[</span><span class="nt">--exec-path</span><span class="o">[=</span>&lt;path&gt;]] <span class="o">[</span><span class="nt">--html-path</span><span class="o">]</span> <span class="o">[</span><span class="nt">--man-path</span><span class="o">]</span> <span class="o">[</span><span class="nt">--info-path</span><span class="o">]</span>
           <span class="o">[</span><span class="nt">-p</span> | <span class="nt">--paginate</span> | <span class="nt">-P</span> | <span class="nt">--no-pager</span><span class="o">]</span> <span class="o">[</span><span class="nt">--no-replace-objects</span><span class="o">]</span> <span class="o">[</span><span class="nt">--bare</span><span class="o">]</span>
           <span class="o">[</span><span class="nt">--git-dir</span><span class="o">=</span>&lt;path&gt;] <span class="o">[</span><span class="nt">--work-tree</span><span class="o">=</span>&lt;path&gt;] <span class="o">[</span><span class="nt">--namespace</span><span class="o">=</span>&lt;name&gt;]
           <span class="o">[</span><span class="nt">--super-prefix</span><span class="o">=</span>&lt;path&gt;] <span class="o">[</span><span class="nt">--config-env</span><span class="o">=</span>&lt;name&gt;<span class="o">=</span>&lt;envvar&gt;]
           &lt;<span class="nb">command</span><span class="o">&gt;</span> <span class="o">[</span>&lt;args&gt;]

These are common Git commands used <span class="k">in </span>various situations:

start a working area <span class="o">(</span>see also: git <span class="nb">help </span>tutorial<span class="o">)</span>
   clone     Clone a repository into a new directory
   init      Create an empty Git repository or reinitialize an existing one

work on the current change <span class="o">(</span>see also: git <span class="nb">help </span>everyday<span class="o">)</span>
   add       Add file contents to the index
   <span class="nb">mv        </span>Move or rename a file, a directory, or a symlink
   restore   Restore working tree files
   <span class="nb">rm        </span>Remove files from the working tree and from the index

examine the <span class="nb">history </span>and state <span class="o">(</span>see also: git <span class="nb">help </span>revisions<span class="o">)</span>
   bisect    Use binary search to find the commit that introduced a bug
   diff      Show changes between commits, commit and working tree, etc
   <span class="nb">grep      </span>Print lines matching a pattern
   log       Show commit logs
   show      Show various types of objects
   status    Show the working tree status

grow, mark and tweak your common <span class="nb">history
   </span>branch    List, create, or delete branches
   commit    Record changes to the repository
   merge     Join two or more development histories together
   rebase    Reapply commits on top of another base tip
   reset     Reset current HEAD to the specified state
   switch    Switch branches
   tag       Create, list, delete or verify a tag object signed with GPG

collaborate <span class="o">(</span>see also: git <span class="nb">help </span>workflows<span class="o">)</span>
   fetch     Download objects and refs from another repository
   pull      Fetch from and integrate with another repository or a <span class="nb">local </span>branch
   push      Update remote refs along with associated objects

<span class="s1">'git help -a'</span> and <span class="s1">'git help -g'</span> list available subcommands and some
concept guides. See <span class="s1">'git help &lt;command&gt;'</span> or <span class="s1">'git help &lt;concept&gt;'</span>
to <span class="nb">read </span>about a specific subcommand or concept.
See <span class="s1">'git help git'</span> <span class="k">for </span>an overview of the system.
</code></pre></div></div>

<p>  功能设计中对子命令的设计是由核心功能驱动的。在条件允许的情况下，尽可能压缩子命令列表是有利于用户上手使用的。为了命令行工具使用时命令不会过长，建议提供比较常用的默认选项值从而减少用户自定义的可能性。当然，对全部选项的单字母标志支持也是有效缩短命令长度的方法之一。除此之外，提供配置文件也是非常可取的方法。<code class="language-plaintext highlighter-rouge">git</code>、<code class="language-plaintext highlighter-rouge">curl</code>、<code class="language-plaintext highlighter-rouge">wget</code>、<code class="language-plaintext highlighter-rouge">docker</code> 等都提供对应的配置文件 <code class="language-plaintext highlighter-rouge">.gitconfig</code>、<code class="language-plaintext highlighter-rouge">.curlrc</code>、<code class="language-plaintext highlighter-rouge">.wgetrc</code> 和 <code class="language-plaintext highlighter-rouge">.dockerrc</code> 进行全局配置定义，当然 <code class="language-plaintext highlighter-rouge">pictl</code> 也提供 <code class="language-plaintext highlighter-rouge">.pictlrc</code> 配置文件。</p>

<h4 id="代码架构">代码架构</h4>

<p>  尽管不同编程语言因为自身原因（编译型或解析型语言，面向对象或面向过程等），可能会有不同的代码架构偏好，我们可能依然可以采用一个宽泛且可行的通用代码架构思路——<strong>面向功能开发</strong>。这里的功能可以是一个操作或者一个对象，比如说压缩图片这样一个功能，主要是将输入图片转换成想要的图片格式输出。除此之外，可能还可以提供压缩质量控制、尺寸控制、自动重命名、自动加水印等微调功能。这些微调功能虽然实际上可以完全独立，但由于是压缩图片功能的附属功能，最好采用选项调用的方式来实现。代码架构上，子命令调用对应的函数会成为<strong>顶级函数</strong>。其他微调功能虽然是独立函数或对象，<u>但仅在子命令函数中被调用</u>。实际开发过程中，微调功能并非一开始就包括所有，大部分会作为一些特性逐步增加到主代码中。这意味着，对用户来说新增一个微调功能仅仅多了一个子命令下的选项支持，不需要重新学习和适应。</p>

<p>  如果压缩图片功能的基础（图片转换）需要自行编写代码，那么可能需要考虑到很多种图片格式的相互转换，这在具体代码实践中是非常麻烦的。比较可行的方法之一是，可以采用一种图片格式作为中间标准格式，每次新增一种图片格式的支持只需要增加与中间标准格式的相互转换即可。当然这里采用的中间标准格式可能是需要高保真的（或者高分辨率的），避免在用了中间标准格式转换之后图片质量自动下降。</p>

<h3 id="错误处理和自动建议">错误处理和自动建议</h3>

<p>  当我们打算开发一款命令行工具时，除了核心功能是必不可少的，错误处理和自动建议也是需要考虑在内的。了解这点最简单的办法就是从实例中学习。如下所示，是将 git 提交修改（commit）的命令 <code class="language-plaintext highlighter-rouge">git commit</code> 故意打成为 <code class="language-plaintext highlighter-rouge">git commi</code> 的输出结果。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>git commi
git: <span class="s1">'commi'</span> is not a git command. See <span class="s1">'git --help'</span><span class="nb">.</span>

The most similar commands are
 commit
 column
 config
</code></pre></div></div>

<p>  当命令行工具接收到用户输入时，首先需要做的就是对输入的合法性进行验证：一方面，是否存在不可用的子命令或非法使用（比如错误迭代调用）；另一方面，尝试解析参数并验证完整性。这两部分的验证会尽可能地将错误的原因和可能有用的建议提示给用户。类似上面，命令行工具会提示用户使用的子命令不存在，请使用 <code class="language-plaintext highlighter-rouge">git --help</code> 了解更多。另外，会将输入的子命令字符串与所有合法的子命令字符串进行对比，根据相似性大小排列向用户自动建议。至于对选项的解析相对来说可以比较宽容一点，即直接忽略不合法的选项声明、仅读取合法的选项声明，因此可以不返回相关错误提醒及帮助。</p>

<p>  当子命令、参数、选项均通过验证之后，命令行工具的功能代码执行时也会发生错误。如下所示，在一个非 git 项目文件夹内执行 <code class="language-plaintext highlighter-rouge">git commit</code> 时，命令行工具会将具体的错误直接提示：当前目录或任何父目录不是一个 git 项目，不存在 <code class="language-plaintext highlighter-rouge">.git</code> 文件夹。这里需要注意的是，通常我们可能对错误或异常的处理会直接使用编程语言本身提供的方式，比如 Python 语言中的 <code class="language-plaintext highlighter-rouge">raise ValueError("'element' parameter is not defined.")</code>。当然这种错误处理本身没有任何问题，只不过同时还会输出错误发生的代码位置等其他与用户使用无关的信息，尽管这种信息在开发过程中有利于开发者调试代码。出于为用户考虑，错误处理信息默认应该以简单可读的方式打印出来、且仅限于提示关键信息。如果用户或者开发者想要了解更多，可以通过 <code class="language-plaintext highlighter-rouge">-v</code> 或者 <code class="language-plaintext highlighter-rouge">--verbose</code> 选项来打印更多调试信息。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>git commit
fatal: not a git repository <span class="o">(</span>or any of the parent directories<span class="o">)</span>: .git
</code></pre></div></div>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> -v 和 -V </div> </div> <div class="content"> <p>  通常来说，<code class="language-plaintext highlighter-rouge">-v</code>（<code class="language-plaintext highlighter-rouge">--verbose</code>）和<code class="language-plaintext highlighter-rouge">-V</code>（<code class="language-plaintext highlighter-rouge">--version</code>）会被认为是不同的选项，分别用于开启调试模式和打印版本信息。当用户发现命令行工具使用出现不可预知的问题（错误提示与实际原因不符或其他不在开发者知晓范围内的问题）时，需要开启调试模式来排除本地环境的问题，同时也可能在向开发者反馈问题时提供足够的信息来帮助定位问题的原因。版本信息通常也是提交反馈问题时所需的必要信息。</p>



 </div> </div>
<h3 id="技术选型">技术选型</h3>

<p>  技术选型指的是<strong>用哪种编程语言以及哪种框架来实现命令行工具</strong>。<strong>第一种</strong>是从开发者自身熟悉和掌握的编程语言出发，尽可能降低编程语言上的学习成本。不过对于已经掌握一门或多门编程语言的开发者来说，学习新编程语言可能也不是件难事。<strong>第二种</strong>是从应用场景出发：如果是开发为机器学习应用的前置或后置步骤的数据准备、数据处理、可视化等功能的命令行工具，采用 Python 语言可能会更加方便有效；如果是开发包含与操作系统交互的网络分析、磁盘分析等功能的命令行工具，采用 Rust 或者 Golang 语言可能会比较得心应手；如果是开发与平台接口交互（如 Web API 调用）的命令行工具，采用 NodeJS 语言可能适配性更佳。详细请查看参考资料 [1-5]。</p>

<h2 id="结语">结语</h2>

<p>  诚然，命令行工具并非是所有用户的喜爱，但的确是最小化操作步骤、提升效率的方式之一。以上所述的命令行工具开发指南入门篇大部分是在理论层面上的，至于在不同编程语言上的实践后续也计划展开：</p>

<ul>
  <li>《命令行工具开发指南 —— Python 实践篇》</li>
  <li>《命令行工具开发指南 —— Rust 实践篇》</li>
  <li>《命令行工具开发指南 —— Golang 实践篇》</li>
  <li>《命令行工具开发指南 —— NodeJS 实践篇》</li>
</ul>

<p>  有关于命令行工具开发进阶的依赖管理、编译构建、信号和日志处理、用户输入验证、自动补全（Auto Completion）、文档、测试和发布等也将在实践篇中分别具体阐述。</p>

<h2 id="参考资料">参考资料</h2>

<ol>
  <li><a href="https://juejin.cn/post/7178666619135066170">快手数平前端团队 – 掌握 Node CLI 工具开发，为团队研发提效！</a></li>
  <li><a href="https://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html">阮一峰的网络日志 – Node.js 命令行程序开发教程</a></li>
  <li><a href="https://suibianxiedianer.github.io/rust-cli-book-zh_CN/README_zh.html">Rust 中的命令行应用</a></li>
  <li><a href="https://pythonguidecn.readthedocs.io/zh/latest/scenarios/cli.html">命令行应用 - Python 最佳实践指南</a></li>
  <li><a href="https://tonybai.com/2023/03/25/the-guide-of-developing-cli-program-in-go/">Tony Bai – Go 开发命令行程序指南</a></li>
  <li><a href="https://en.wikipedia.org/wiki/POSIX">Wikipedia – POSIX</a></li>
</ol>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="cli" /><category term="command line" /><category term="命令行" /><category term="develop" /><category term="开发" /><category term="tool" /><category term="工具" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">图片处理及上传命令行工具 —— PICTL</title><link href="https://lisz.me/tech/project/pictl.html" rel="alternate" type="text/html" title="图片处理及上传命令行工具 —— PICTL" /><published>2023-06-13T13:41:01+09:00</published><updated>2023-06-13T13:41:01+09:00</updated><id>https://lisz.me/tech/project/pictl</id><content type="html" xml:base="https://lisz.me/tech/project/pictl.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  自从博客从 WordPress 转到静态博客（先 Hexo 后 Jekyll）之后，文章的图片处理、图片上传就成了一个不大顺畅的事情。最先是使用了 <a href="https://vgy.me">vgy.me</a> 提供的免费图床，支持直接从剪切板上传，操作上相对比较简单，也不需要任何本地存储。不过后来 vgy.me 进行了升级改版，原先的剪切板上传功能也不再支持了，偶尔还出现图片像素被降低、丢失的问题。同时，考虑到 WebP 格式可能会适合博客使用，而 vgy.me 还不支持该格式。于是开始切换到 “对象存储 + CDN” 的方案。本地准备好的 PNG 格式图片，先通过 <a href="https://developers.google.com/speed/webp/">cwebp</a> 命令行转成 WebP 格式图片，再通过 <a href="https://github.com/gee1k/uPic">uPic</a> 工具修改文件名后上传到对象存储。由于此前采用的是腾讯云的 COS 对象存储和 CDN，经常面临着 SSL 证书更新等琐碎的事情。这样一来，整体的效率实际上并不高，只能说勉强接受。</p>

<h3 id="现有工具及存储考察">现有工具及存储考察</h3>

<p>  为此，也对其他工具和对象存储进行了考察。</p>

<p>  <a href="https://github.com/Molunerfinn/PicGo">PicGo</a> 是一款集客户端 UI 和命令行于一体的图片上传工具，虽然可以利用命令串联的方式简单将图片格式转换和上传两步变成一步，但还是有那么点不舒服的地方，比如 PicGo 不提供文件名修改（为固定长度随机字符串）的特性。而 uPic 本身关注于客户端桌面交互，不提供命令行接口。</p>

<p>  至于对象存储，国内各家云服务厂商提供的都需要自行手动更新 SSL 证书，且收费。尽管腾讯云 CDN 目前老用户可以每月领券免费使用，但一旦忘记就开始被收费了。实际上也有逐步转向收费的趋势。国外各家云服务厂商基本上都需要收费使用对象存储或者 CDN，大差不差。</p>

<p>  当然，网上一直有一种 “Backblaze B2 + Cloudflare” 的解决方案。由于 B2 本身存储和读写操作都有免费额度，流量需要收费，且无法自定义域名，而 B2 和 Cloudflare 同属于宽带联盟（内部流量免费），Cloudflare 还提供 URL 重写功能，这种解决方案一时成为了潮流。不过，B2 的访问链接是中间带着一串参数，重写之后仍然还是有部分参数，最终的 URL 并不是那么朴素。总的来说，还是有那么点别扭。</p>

<h3 id="r2-的出现">R2 的出现</h3>

<p>  因此观望了许久，直到 Cloudflare 推出了 R2。R2 是一款对标 AWS S3 的产品，基于 Cloudflare 对宽带联盟的承诺而构建，为存储对象提供零成本出口，实际上就是免费 CDN。由于 Cloudflare 本身就是一家 CDN 服务商，自定义对象存储访问域名、自动生成部署 SSL 证书这些事情就变得轻而易举了。R2 提供 10GB 的免费存储，读操作每月免费 1000 万次，写、更新和删除操作每月免费 100 万次。这对于一般的静态博客来说，应该完全足够了，即使超出了免费额度，超出部分收费也相较其他云服务厂商便宜一些。</p>

<p>  对笔者而言，R2 产品将对象存储和 CDN 两款产品有机地结合起来，解决了静态博客图片对外访问前的“最后一公里”。于是想从 COS 迁移到 R2，无奈 uPic 这个时候卖了个“破绽”。uPic 似乎在开始转向商业收费，Github 上不再发布新版本，而仅在 Appstore 上继续更新对 R2 的支持。当然，Appstore 上的 uPic 是收费的（4.99 美元，其实也不贵）。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  R2 虽然说是对标 AWS S3，但是并没有完整实现所有 API 接口，所以目前 Github 上发布的 uPic 版本无法兼容。尽管可以自行通过修改 uPic 的开源代码来实现兼容，但毕竟修改别人的代码的成本还是有一点高的。</p>



 </div> </div>
<h2 id="开个新项目">开个新项目</h2>

<p>  在充分梳理个人使用需求之后，还是决定开个新项目——开发一款简单易用的命令行工具 PICTL（全称 <strong>Pi</strong>cture <strong>C</strong>on<strong>t</strong>ro<strong>l</strong>）。该工具须具备以下特性：</p>

<ul>
  <li>考虑图片的存储空间大小和网页加载时长，所有图片应被压缩并转成 WebP 格式；</li>
  <li>所有图片的名称应被修改成一个固定长度随机字符串，并支持上传到类 S3 的对象存储；</li>
  <li>简单易用，命令行优先，无网页或桌面交互界面；</li>
  <li>（可选）自动添加水印；</li>
  <li>（可选）根据设定自动调整图片尺寸；</li>
  <li>（可选）可以直接从剪切板读取图片。</li>
</ul>

<h2 id="架构设计">架构设计</h2>

<p>  根据所列出的特性，这款命令行工具主要的模块就是：<strong>图片处理模块</strong>和<strong>上传模块</strong>，架构如下图所示。</p>

<p><img src="https://i.lisz.top/blog/Gl8qhI.webp" alt="PICTL 架构图 The architecture of PICTL" /></p>

<p>  图片处理模块包括图片压缩、图片格式转换、图片水印、尺寸调整等功能，可以进行无缝横向扩展。上传模块主要包括对于三种存储方式的支持：<strong>第一类</strong>是最为广泛的类 S3 对象存储，如 R2、AWS S3 及国内外云服务厂商各种对象存储等，<strong>第二类</strong>是目前仍然在博客中广泛流行的第三方图床，如 <a href="https://sm.ms">SM.MS</a>、<a href="https://vgy.me">vgy.me</a>、<a href="https://github.com/chevereto/chevereto">chevereto</a> 类型图床等，<strong>第三类</strong>是自托管 Git 平台和 FTP 平台。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 特此声明 </div> </div> <div class="content"> <p>  鉴于 Github、Gitlab、Gitee 等公共代码托管平台均禁止把 Git 仓库作为图床的做法，本工具仅支持自建 Git 平台，如自建 Gitlab 和 Gitlab Pages。如试图上传到公共代码托管平台，本工具会自行中断上传。</p>



 </div> </div>
<p>  本工具由于仅支持命令行，所以计划用 Python 和 <a href="https://click.palletsprojects.com/">Click</a> 进行开发。虽然借助 <a href="https://google.github.io/python-fire/">Google Fire</a> 也可以快速开发命令行工具，但其使用方式上与原生 *nix 的命令行工具有所不同。相比之下，用 Click 开发可能会麻烦一点，但能够开发出更类原生的 Python 命令行工具。当然，目前开发上还是比较喜欢使用 Rust 或者 Go 语言来开发高性能的命令行工具。不过，本工具只是做一些非常简单的工作，没有性能上的瓶颈，用 Python 开发也足够了。</p>

<h2 id="开发计划">开发计划</h2>

<p>  请移步 <a href="https://github.com/users/zhonger/projects/5">Github Project</a> 了解更多。</p>

<h2 id="使用方法">使用方法</h2>

<p>  目前，PICTL 已经在 <a href="https://github.com/zhonger/pictl/releases">Github</a> 和 <a href="https://pypi.org/project/pictl/">PyPI</a> 同步发布了 v0.1.0 版本。该版本实现了以上架构图中的基本功能，即特性中的前三点必要项。接下来介绍一下如何安装和使用本工具。</p>

<h3 id="安装">安装</h3>

<p>  目前支持两种安装方式：<strong>源码安装</strong>和 <strong>PIP 安装</strong>，后续将增加对于 brew 的支持。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  安装前，请务必确保已满足 Python 版本高于 3.10 的条件。</p>



 </div> </div>
<h4 id="源码安装">源码安装</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/zhonger/pictl
<span class="nb">cd </span>pictl
pip3 <span class="nb">install</span> <span class="nb">.</span>
</code></pre></div></div>

<h4 id="pip-安装">PIP 安装</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install </span>pictl
</code></pre></div></div>

<h3 id="使用">使用</h3>

<h4 id="显示版本">显示版本</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl <span class="nt">-V</span>
PICTL 0.1.0
</code></pre></div></div>

<h4 id="列举所有支持命令">列举所有支持命令</h4>

<p>  目前 v0.1.0 版本包含四个子命令：config（配置管理），compress（图片处理），upload（上传文件）和 cup（一键式压缩、转换、上传）。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl
Usage: pictl <span class="o">[</span>OPTIONS] COMMAND <span class="o">[</span>ARGS]...

  A <span class="nb">command </span>line tool <span class="k">for </span>image processing and uploading <span class="o">(</span>ex. S3-type<span class="o">)</span><span class="nb">.</span>

  Now it supports:
    - transformation from other image types to <span class="sb">`</span>webp<span class="sb">`</span> image as well as
      image compression.
    - image file uploading to AWS S3 or Cloudflare R2.

Options:
  <span class="nt">-V</span>, <span class="nt">--version</span>  Show the pictl version.
  <span class="nt">-h</span>, <span class="nt">--help</span>     Show this message and exit.

Commands:
  compress  Compress any image into <span class="sb">`</span>webp<span class="sb">`</span> image.
  config    Operations <span class="k">for </span>the config file <span class="sb">`</span>~/.pictlrc<span class="sb">`</span><span class="nb">.</span>
  cup       Compress image and upload to remote storage <span class="o">(</span>compress and...
  upload    Upload the file to remote storage
</code></pre></div></div>

<h4 id="config-子命令">config 子命令</h4>

<p>  config 子命令包含 add（添加配置）、delete（删除配置）、info（查看所有配置）和 init（初始化配置）四种操作。使用本工具需要先执行初始行配置操作，再执行其他配置操作。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config
Usage: pictl config <span class="o">[</span>OPTIONS] COMMAND <span class="o">[</span>ARGS]...

  Operations <span class="k">for </span>the config file <span class="sb">`</span>~/.pictlrc<span class="sb">`</span><span class="nb">.</span>

Options:
  <span class="nt">-h</span>, <span class="nt">--help</span>  Show this message and exit.

Commands:
  add     Add configs to the config file.
  delete  Delete config group from the config file.
  info    Check the configs.
  init    Initialize config file with default configs.
</code></pre></div></div>

<p>  如下所示，使用 <code class="language-plaintext highlighter-rouge">pictl config init</code> 命令初始化配置。第二次执行时，由于已存在配置文件，会提示已经初始化过了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config init
The settings has been initilized <span class="k">in</span> /home/ubuntu/.pictlrc.

╰─<span class="nv">$ </span>pictl config init
/home/ubuntu/.pictlrc already exists.
Please add settings or change it manaully.
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">pictl config info</code> 以 JSON 格式打印所有配置信息。配置文件默认采用 TOML 格式。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config info
<span class="o">{</span>
    <span class="s1">'basic'</span>: <span class="o">{</span><span class="s1">'length'</span>: 6, <span class="s1">'ntype'</span>: <span class="s1">'random'</span>, <span class="s1">'algorithm'</span>: <span class="s1">'sha1'</span><span class="o">}</span>,
<span class="o">}</span>

╰─<span class="nv">$ </span><span class="nb">cat</span> ~/.pictlrc
<span class="o">[</span>basic]
length <span class="o">=</span> 6
ntype <span class="o">=</span> <span class="s2">"random"</span>
algorithm <span class="o">=</span> <span class="s2">"sha1"</span>
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">pictl config add</code> 以命令行交互方式添加配置（以下是 R2 的例子）。添加完成后可以再次查看新增后的所有配置。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config add
<span class="k">******</span> Please input these information <span class="k">******</span>
Group Name <span class="o">(</span>default <span class="s1">'blog'</span><span class="o">)</span>: <span class="nb">test</span>
<span class="o">[</span>?] Type: : R2
   S3
 <span class="o">&gt;</span> R2

Account ID: testid
Bucket Name: <span class="nb">test
</span>Key: testkey
Secret: testsecret
Prefix <span class="o">(</span>Default is None<span class="o">)</span>:
Access Url <span class="o">(</span>like <span class="sb">`</span>https://i.example.com<span class="sb">`</span><span class="o">)</span>: https://i.example.com
New group <span class="s1">'test'</span> has been saved <span class="k">in</span> /Users/zhonger/.pictlrc.

╰─<span class="nv">$ </span>pictl config info
<span class="o">{</span>
    <span class="s1">'basic'</span>: <span class="o">{</span><span class="s1">'length'</span>: 6, <span class="s1">'ntype'</span>: <span class="s1">'random'</span>, <span class="s1">'algorithm'</span>: <span class="s1">'sha1'</span><span class="o">}</span>,
    <span class="s1">'test'</span>: <span class="o">{</span>
        <span class="s1">'endpoint'</span>: <span class="s1">'https://testid.r2.cloudflarestorage.com/test'</span>,
        <span class="s1">'bucket'</span>: <span class="s1">'test'</span>,
        <span class="s1">'prefix'</span>: <span class="s1">''</span>,
        <span class="s1">'key'</span>: <span class="s1">'testkey'</span>,
        <span class="s1">'secret'</span>: <span class="s1">'testsecret'</span>,
        <span class="s1">'url'</span>: <span class="s1">'https://i.example.com'</span>,
        <span class="s1">'type'</span>: <span class="s1">'R2'</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">pictl config delete</code> 命令可以选择删除远程配置组（此处为了展示，除 test 外还添加了其他配置组）。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config delete
<span class="o">[</span>?] Please <span class="k">select </span>one group: : <span class="nb">test
   </span>blog
   cover
 <span class="o">&gt;</span> <span class="nb">test

test </span>has been deleted.
</code></pre></div></div>

<h4 id="compress-子命令">compress 子命令</h4>

<p>  本子命令输入参数为<strong>图片文件名</strong>，可以带路径。输出图片会被保存在命令执行位置，<strong>而非原图片所在目录</strong>。执行该操作后，图片还不会被上传，需要继续使用 upload 命令完成上传。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl compress <span class="nt">-h</span>
Usage: pictl compress <span class="o">[</span>OPTIONS] FILENAME

  Compress any image into <span class="sb">`</span>webp<span class="sb">`</span> image.

  FILENAME is the name of the file to compress.

Options:
  <span class="nt">-h</span>, <span class="nt">--help</span>  Show this message and exit.

╰─<span class="nv">$ </span>pictl compress ../../pictl/fig01.png
The output file is EVyP2J.webp
</code></pre></div></div>

<h4 id="upload-子命令">upload 子命令</h4>

<p>  如下所示，使用 <code class="language-plaintext highlighter-rouge">pictl upload</code> 命令加上指定上传文件名和远程配置组即可完成上传。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl upload <span class="nt">-h</span>
Usage: pictl upload <span class="o">[</span>OPTIONS] FILENAME GROUP

  Upload the file to remote storage.

  FILENAME is the name of the file to upload.
  GROUP is the group <span class="k">in </span>the config file you want to use.

Options:
  <span class="nt">-h</span>, <span class="nt">--help</span>  Show this message and exit.

╰─<span class="nv">$ </span>pictl upload EVyP2J.webp <span class="nb">test
</span>Direct URL: https://i.example.com/EVyP2J.webp
Markdown: <span class="o">![</span>EVyP2J.webp]<span class="o">(</span>https://i.example.com/EVyP2J.webp<span class="o">)</span>
HTML Code: &lt;img <span class="nv">src</span><span class="o">=</span><span class="s2">"https://i.example.com/EVyP2J.webp"</span> <span class="nv">alt</span><span class="o">=</span><span class="s2">"EVyP2J.webp"</span> /&gt;
</code></pre></div></div>

<h4 id="cup-子命令">cup 子命令</h4>

<p>  cup 子命令 = compress 子命令 + upload 子命令，仅需要指定初始图片文件和远程配置组，即可一步完成图片压缩、格式转换、修改名称、上传。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl cup <span class="nt">-h</span>
Usage: pictl cup <span class="o">[</span>OPTIONS] FILENAME GROUP

  Compress image and upload to remote storage <span class="o">(</span>compress and upload<span class="o">)</span><span class="nb">.</span>

  FILENAME is the name of the file to compress.
  GROUP is the group <span class="k">in </span>the config file you want to use.

Options:
  <span class="nt">-h</span>, <span class="nt">--help</span>  Show this message and exit.

╰─<span class="nv">$ </span>pictl cup ../../pictl/fig01.png <span class="nb">test
</span>The output file is Gl8qhI.webp
Direct URL: https://i.example.com/Gl8qhI.webp
Markdown: <span class="o">![</span>Gl8qhI.webp]<span class="o">(</span>https://i.example.com/Gl8qhI.webp<span class="o">)</span>
HTML Code: &lt;img <span class="nv">src</span><span class="o">=</span><span class="s2">"https://i.example.com/Gl8qhI.webp"</span> <span class="nv">alt</span><span class="o">=</span><span class="s2">"Gl8qhI.webp"</span> /&gt;
</code></pre></div></div>

<h2 id="todo">TODO</h2>

<p>  目前的 v0.1.0 版本还比较简陋，不过已经能满足笔者的必要需求，有效提升效率。后续将继续完善、新增功能：</p>

<ul>
  <li>自动补全（shell completion），增强命令行使用体验。</li>
  <li>增加对各云服务厂商提供对象存储的支持。</li>
  <li>增加对各流行图床的支持。</li>
  <li>增加对自托管 Git 的支持。</li>
  <li>增加对 FTP 的支持。</li>
  <li>增加包括水印、调整大小等在内的图片处理的支持。</li>
  <li>增加与 Unplash 等公共图库的连接，更加便于博客封面的操作。</li>
</ul>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://blog.cloudflare.com/introducing-r2-object-storage-zh-cn/">隆重推出 Cloudflare R2 Storage —— 快速、可靠的对象存储，减免出口费用</a></li>
  <li><a href="https://developers.cloudflare.com/r2/">R2 文档</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="project" /><category term="pictl" /><category term="命令行" /><category term="工具" /><category term="cli" /><category term="tool" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">通用运行环境版本管理神器 ASDF</title><link href="https://lisz.me/tech/webmaster/asdf.html" rel="alternate" type="text/html" title="通用运行环境版本管理神器 ASDF" /><published>2023-03-20T15:50:00+09:00</published><updated>2023-03-20T15:50:00+09:00</updated><id>https://lisz.me/tech/webmaster/asdf</id><content type="html" xml:base="https://lisz.me/tech/webmaster/asdf.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  之前介绍了高性能集群中常用的运行环境和软件版本管理工具 Modules，今天打算介绍一款适合个人或团队开发使用的通用运行环境版本管理神器 <a href="https://asdf-vm.com/zh-hans/">ASDF</a>。与高性能计算任务不同，个人或团队开发项目一般来说都是使用独立的设备或环境，然后通过代码版本跟踪 git 等来进行异步协作。所以说，在每个人的单个或多个设备上都安装配置 Modules 显得有点不太现实和高效。但是项目开发所需的代码环境确实有的时候可能比较复杂，比如说同时需要 Ruby、NodeJS、Java、Python 四种环境，而且可能对于每种环境还有版本的限制。这样一来，光配置这一堆环境就要花上大半天时间了。</p>

<h3 id="asdf-简介">ASDF 简介</h3>

<p>  ASDF 提供了全平台通用的环境配置方案，使用单个命令行工具和交互界面就可以管理超复杂的运行环境。以往针对不同运行环境，需要使用不同的配置文件来进行版本的声明。对于 ASDF，只需要一个可共享的 <code class="language-plaintext highlighter-rouge">.tool-versions</code> 配置文件即可。ASDF 涵盖了包括 Ruby、NodeJS、Java、PHP、.Net 在内的几百种运行环境，具体可以查看 <a href="https://github.com/asdf-vm/asdf-plugins">ASDF 插件列表</a> 了解更多。</p>

<p>  另外，ASDF 完全支持包括 Bash、Zsh、Fish 和 Elvish 在内的常用 shell 类型，并提供补全功能。在类似 Github Actions 等的 CI/CD 工作流中，也可以轻松使用 ASDF。值得一提的是，笔者翻译了 ASDF 文档的中文版本并被官方采纳，现在 ASDF 官网支持英语、巴西语和中文三种语言。</p>

<h3 id="为何不选其他方案">为何不选其他方案</h3>

<h4 id="docker">Docker</h4>

<p>  很显然，如果大家的设备上都有 Docker 环境且 CPU 架构相同的话，Docker 无疑是最省心的方案。Docker 镜像的确可以轻松涵盖所有开发环境和实际运行环境（Apache 等 HTTP 服务器、数据库以及其他）。相比笨重的 VMware 或 Virtualbox 虚拟机镜像而言，Docker 镜像也更加小巧、便捷。而且团队可以通过在内部搭建自己的 Docker 镜像仓库，来分享这些镜像给所有参与项目的开发者。唯一可能会有问题的是，设备 CPU 架构和操作系统的多样性可能会给实际操作带来了不小的问题。实际上可能会有 Windows 系统、Linux 系统、MacOS 系统以及 Intel 架构、AMD 架构、ARM 架构（如 M1、M2 等）。可行的解决方法是，尽可能地构建更多架构的镜像。</p>

<h4 id="anaconda">Anaconda</h4>

<p>  Anaconda 现在可能已经完全超出了一个 Python 环境管理工具，有的时候也可以当成通用软件或环境管理器来用。但是毕竟还是以科学计算为主要目的，如果项目仅仅是 Python、R 语言可能还是比较合适的，对于实际编程所需的其他运行环境来说可能还是支持不够的。</p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  据笔者所知，在 <code class="language-plaintext highlighter-rouge">conda-forge</code> 频道里的确有 PHP 等编程语言的支持。除此之外，也有一些热心开发者在个人频道提供了 java-jdk、golang 等编程环境支持。</p>



 </div> </div>
<h4 id="云开发">云开发</h4>

<p>  云开发主要是指基于云基础设施的在线代码开发环境，主要的代表有：</p>

<ul>
  <li><a href="https://aws.amazon.com/cn/cloud9/">Cloud9</a>：笔者最早接触过的云开发，目前已被 AWS 收购，更名为 AWS Cloud9。</li>
  <li><a href="https://github.com/features/codespaces">Codespaces</a>：由 Azure 提供云服务、Github 负责运营的一站式云开发环境。</li>
  <li><a href="https://www.gitpod.io/">Gitpod</a>：基于 VS Code 研发的优秀云开发环境，早期以“便捷、快速”著称，较先于 Codespaces 出现。</li>
  <li><a href="https://cloud.tencent.com/product/cloudstudio">Cloud Studio</a>：由腾讯云提供云服务、基于 VS Code 的国产云开发环境，能够很好地支持个人开发、招聘笔试、课堂教学、应用快捷部署等各种场景。</li>
  <li><a href="https://www.huaweicloud.com/product/cloudide.html">CodeArts IDE Online</a>：由华为云提供云服务、基于 VS Code 的国产云开发环境。除了一般云开发所具备的特点，还支持华为鲲鹏原生环境，能够很好地满足跨架构应用开发的需求。</li>
  <li><a href="https://cn.aliyun.com/product/yunxiao/devstudio">DevStudio</a>：由阿里云提供云服务、基于 VS Code 的国产云开发环境。支持应用开发全流程管理，与阿里云各项基础服务紧密结合，适合大规模团队使用。</li>
</ul>

<p>除了以上列举的云开发之外，也有一些比较传统的小型云开发实践，比如说知名的 <a href="https://jsfiddle.net/">JSFiddle</a>、<a href="https://codepen.io/">CodePen</a>、<a href="https://replit.com/">Replit</a> 等。虽然说这些云开发主要是适合较小代码库，但在实际学习过程中用处也是很大的。</p>

<p>  云开发不仅兼顾了传统开发过程中的协同与流程，又将资源与环境整合在云里面，自然而然是最好的解决方案。随着 VS Code 在开发者之间的流行和云服务提供商的努力，基于 VS Code 的云开发环境层出不穷。即使云开发环境本身免费，云也还是要按量按时计费的。对于还没有足够支持上云的团队或个人来说，ASDF 依然是个不错的选择。</p>

<h2 id="实践">实践</h2>

<h3 id="环境需求">环境需求</h3>

<ul>
  <li>Linux/Unix 环境（Linux、MacOS、Windows WSL）</li>
  <li>git</li>
  <li>bash 等（此处以 zsh 为例）</li>
</ul>

<h3 id="环境配置">环境配置</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 下载源码到 ~/.asdf 目录</span>
git clone https://github.com/asdf-vm/asdf.git ~/.asdf <span class="nt">--branch</span> v0.11.3

<span class="c"># 在 ~/.zshrc 文件中加入内容</span>
<span class="nb">tee</span> <span class="nt">-a</span> ~/.zshrc <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
. "</span><span class="nv">$HOME</span><span class="sh">/.asdf/asdf.sh"
</span><span class="no">EOF

</span><span class="c"># 激活配置</span>
<span class="nb">source</span> ~/.zshrc

<span class="c"># 验证</span>
╰─<span class="nv">$ </span>asdf version
v0.11.3-0adc6c1
</code></pre></div></div>

<h3 id="安装插件">安装插件</h3>

<p>  由于 ASDF 支持插件较多，这里以 Python 环境为例介绍 ASDF 安装插件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 添加插件</span>
asdf plugin add python

<span class="c"># 查看已安装插件</span>
╰─<span class="nv">$ </span>asdf plugin list
python

<span class="c"># 查看最新 Python 版本</span>
╰─<span class="nv">$ </span>asdf latest python
3.11.2

<span class="c"># ASDF 安装 Python 3.11.2 (latest)</span>
╰─<span class="nv">$ </span>asdf <span class="nb">install </span>python latest
python-build 3.11.2 /home/ubuntu/.asdf/installs/python/3.11.2
Downloading Python-3.11.2.tar.xz...
-&gt; https://www.python.org/ftp/python/3.11.2/Python-3.11.2.tar.xz
Installing Python-3.11.2...
Installed Python-3.11.2 to /home/ubuntu/.asdf/installs/python/3.11.2

<span class="c"># 查看已安装 Python 版本列表</span>
╰─<span class="nv">$ </span>asdf list
python
  3.11.2
</code></pre></div></div>

<h3 id="使用">使用</h3>

<p>  ASDF 提供全局版本（Global）和本地版本（Local）两种方式定义运行环境版本。全局版本是系统级别的，类似于 PATH 变量中定义的；本地版本则是为了某个代码库或者部分代码准备的，通常在目录中的 <code class="language-plaintext highlighter-rouge">.tool-versions</code> 文件里定义。为了区分全局和本地的效果差别，这里再安装一个指定 Python 版本。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查询 Python 插件支持的所有版本</span>
╰─<span class="nv">$ </span>asdf list all python
2.1.3
2.2.3
......
stackless-3.7.5

<span class="c"># 安装 Python 3.9.0</span>
╰─<span class="nv">$ </span>asdf <span class="nb">install </span>python 3.9.0
python-build 3.9.0 /home/zhonger/.asdf/installs/python/3.9.0
Downloading Python-3.9.0.tar.xz...
-&gt; https://www.python.org/ftp/python/3.9.0/Python-3.9.0.tar.xz
Installing Python-3.9.0...
patching file Misc/NEWS.d/next/Build/2021-10-11-16-27-38.bpo-45405.iSfdW5.rst
patching file configure
patching file configure.ac
Installed Python-3.9.0 to /home/zhonger/.asdf/installs/python/3.9.0

<span class="c"># 查看已安装 Python 版本列表</span>
╰─<span class="nv">$ </span>asdf list
python
  3.11.2
  3.9.0

<span class="c"># 查看当前系统 Python 及 Python3 版本</span>
╰─<span class="nv">$ </span>python <span class="nt">-V</span>
No python executable found <span class="k">for </span>python system

╰─<span class="nv">$ </span>python3 <span class="nt">-V</span>
Python 3.10.6

<span class="c"># 更改全局版本为 3.11.2 并查看</span>
╰─<span class="nv">$ </span>asdf list
python
 <span class="k">*</span>3.11.2
  3.9.0

╰─<span class="nv">$ </span>python <span class="nt">-V</span>
Python 3.11.2

<span class="c"># 创建子目录指定本地版本并查看</span>
<span class="nb">mkdir </span>py <span class="o">&amp;&amp;</span> <span class="nb">cd </span>py
asdf <span class="nb">local </span>python 3.9.0

╰─<span class="nv">$ </span>python <span class="nt">-V</span>
Python 3.9.0

<span class="c"># 返回父目录查看 Python 版本</span>
╰─<span class="nv">$ </span><span class="nb">cd</span> .. <span class="o">&amp;&amp;</span> python <span class="nt">-V</span>
Python 3.11.2

<span class="c"># 查看当前系统 Python3 版本</span>
╰─<span class="nv">$ </span>python3 <span class="nt">-V</span>
Python 3.10.6
</code></pre></div></div>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  这里有一点比较有趣的是：由于 ASDF 接管的 <code class="language-plaintext highlighter-rouge">python</code> 命令而非 <code class="language-plaintext highlighter-rouge">python3</code> 命令，所以 <code class="language-plaintext highlighter-rouge">python3</code> 命令输出的版本依然还是系统安装版本。</p>



 </div> </div>
<h3 id="其他相关">其他相关</h3>

<p>  如果想要恢复到系统指定版本，可以很容易使用 <code class="language-plaintext highlighter-rouge">asdf global python system</code> 命令。当然，对于本地版本，可以使用 <code class="language-plaintext highlighter-rouge">asdf local python system</code> 来实现。除此之外，还有一些常规操作如下。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看 Python 指定版本安装位置</span>
╰─<span class="nv">$ </span>asdf where python 3.11.2
/home/zhonger/.asdf/installs/python/3.11.2

<span class="c"># 查看命令所在位置</span>
╰─<span class="nv">$ </span>asdf which python
/home/zhonger/.asdf/installs/python/3.11.2/bin/python

<span class="c"># 查看当前 ASDF 管理的运行环境</span>
╰─<span class="nv">$ </span>asdf current
python          3.11.2          /home/ubuntu/.tool-versions

<span class="c"># 查看全局和本地版本配置文件</span>
╰─<span class="nv">$ </span><span class="nb">cat</span> ~/.tool-versions
python 3.11.2

╰─<span class="nv">$ </span><span class="nb">cat</span> ~/py/.tool-versions
python 3.9.0
</code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://asdf-vm.com/zh-hans/guide/getting-started.html">ASDF 官网 - 快速入门</a></li>
  <li><a href="https://asdf-vm.com/zh-hans/manage/versions.html">ASDF 官网 - 版本</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Linux" /><category term="Environment" /><category term="Manage" /><category term="Dev Runtime" /><category term="软件环境" /><category term="多版本" /><category term="管理" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">Modules 配置之 Python</title><link href="https://lisz.me/tech/webmaster/modules-python.html" rel="alternate" type="text/html" title="Modules 配置之 Python" /><published>2023-03-20T12:48:00+09:00</published><updated>2023-03-20T12:48:00+09:00</updated><id>https://lisz.me/tech/webmaster/modules-python</id><content type="html" xml:base="https://lisz.me/tech/webmaster/modules-python.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  近年来得益于其轻量、易学易用、第三方支持依赖库多的特点，Python 语言大量被用于机器学习相关的研究、项目开发。在学术界，有以 <a href="https://scikit-learn.org">Scikit-Learn</a> 为代表的全能机器学习库；在产业界，有以 <a href="https://www.tensorflow.org">TensorFlow</a>、<a href="https://pytorch.org">PyTorch</a> 为代表的生产级机器学习模型计算框架。（当然，学术界实际上构建大规模深度学习模型时也会用到 PyTorch 等计算框架。）但对于大多数人来说，学习这些库、框架或者借助它们从事某些研究、项目开发时，可能还是在用自己的笔记本、台式机。哪怕是在高校的实验室里，这种事情也是屡见不鲜。因此，有交互界面、相对容易上手的 <a href="https://www.anaconda.com">Anaconda</a> 可能会作为大家管理 Python 环境的首选。</p>

<p>  当我们在用 Python 编写一些代码，而代码一次运行不可能在短短几秒、几分钟内得到结果时，将任务提交给高性能工作站或者集群作业系统就显得格外有效。尤其是当应用规模较大、计算迭代次数较多时，非交互式的作业提交方式会变得更加有利。毕竟如果是用自己的笔记本运行着这么大的计算，资源基本上都被计算占用了，根本没办法用笔记本去干点别的事情。甚至说，计算还会使得 CPU 等核心部件温度上升，从而影响计算性能。这样比较下来，不得不说提交任务给高性能工作站或者集群作业系统是多么明智的选择。</p>

<p>  其实，Anaconda 在没有交互界面的服务器操作系统上也还是可以使用的，我们可以使用其免费的精简版 —— <a href="https://conda.io/miniconda">miniconda</a>。虽然 miniconda 已经是精简版了，但和原生 Python 环境比起来还是要多不少东西的。从高性能计算环境的角度来看，使用 Modules 直接管理 Python 环境实际上更加贴近原生，也更加有利于用户与其他环境搭配使用。比如说安装  Python 的 MPI 支持库 —— MPI4PY，仅需要通过 Modules 管理工具加载 Python 和 MPI 两个基础环境，使用 <code class="language-plaintext highlighter-rouge">pip3 install mpi4py</code> 命令即可安装。</p>

<h2 id="实践">实践</h2>

<p>  将 Python 环境纳入 Modules 管理的步骤就是两步：第一步，编译源代码及安装；第二步，添加 Modules 配置文件。当然，最开始还是需要确认一下编译环境是否完备以及文件夹是否准备好。</p>

<h3 id="环境及文件夹准备">环境及文件夹准备</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 安装编译环境</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> build-essential libbz2-dev libdb-dev <span class="se">\</span>
  libreadline-dev libffi-dev libgdbm-dev liblzma-dev <span class="se">\</span>
  libncursesw5-dev libsqlite3-dev libssl-dev <span class="se">\</span>
  zlib1g-dev uuid-dev tk-dev wget
  
<span class="c"># 准备文件夹</span>
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /opt/python/3.10.6
</code></pre></div></div>

<h3 id="编译及安装">编译及安装</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 下载源代码</span>
<span class="nb">cd</span> /tmp
wget <span class="nt">-c</span> https://www.python.org/ftp/python/3.10.6/Python-3.10.6.tar.xz

<span class="c"># 解压源代码</span>
<span class="nb">tar </span>xf Python-3.10.6.tar.xz

<span class="c"># 配置安装路径及编译选项</span>
<span class="nb">cd </span>Python-3.10.6
./configure <span class="nt">--prefix</span><span class="o">=</span>/opt/python/3.10.6 <span class="nt">--enable-optimizations</span> <span class="nt">--with-lto</span> 

<span class="c"># 编译及安装</span>
make <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<h3 id="配置-modules">配置 Modules</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /opt/modules/modulefiles/py
<span class="nb">sudo </span>vim /opt/modules/modulefiles/py/3.10.6
</code></pre></div></div>

<p>  首先如上命令准备文件夹，并新建 module 配置文件，内容如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#%Module</span>
proc ModulesHelp <span class="o">{</span> <span class="o">}</span> <span class="o">{</span>
    puts stderr <span class="se">\t</span>This module file will load Python 3.10.6<span class="s2">"
}

module-whatis  "</span>Enable Python 3.10.6<span class="s2">"

eval set  [ array get env HOME ]
set basedir /opt/python/3.10.6
prepend-path PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/bin<span class="s2">"
prepend-path LIBRARY_PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/lib<span class="s2">"
prepend-path LD_LIBRARY_PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/lib<span class="s2">"
prepend-path INCLUDE_PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/include<span class="s2">"
prepend-path LD_INCLUDE_PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/include<span class="s2">"
</span></code></pre></div></div>

<h3 id="验证">验证</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看所有可用模块</span>
╰─<span class="nv">$ </span>module ava
<span class="nt">--------------------------</span> /opt/modules/modulefiles <span class="nt">---------------------------</span>
dot  module-git  module-info  modules  null  py/3.10.6  use.own

Key:
modulepath
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 加载 python 3.10.6 环境，并确认已加载模块</span>
╰─<span class="nv">$ </span>module load py/3.10.6
╰─<span class="nv">$ </span>module list
Currently Loaded Modulefiles:
 1<span class="o">)</span> py/3.10.6
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 确认目前 python 版本</span>
╰─<span class="nv">$ </span>python3 <span class="nt">-V</span>
Python 3.10.6
</code></pre></div></div>

<h3 id="使用">使用</h3>

<p>  由于以上操作将 Python 3.10.6 安装到了一个系统文件夹中，编译完成后会出现如下警告提示。不过无须担心，普通用户可以通过 venv 虚拟环境工具正常使用。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Installing collected packages: setuptools, pip
  WARNING: The scripts pip3 and pip3.10 are installed <span class="k">in</span> <span class="s1">'/opt/python/3.10.6/bin'</span> which is not on PATH.
  Consider adding this directory to PATH or, <span class="k">if </span>you prefer to suppress this warning, use <span class="nt">--no-warn-script-location</span><span class="nb">.</span>
Successfully installed pip-22.2.1 setuptools-63.2.0
WARNING: Running pip as the <span class="s1">'root'</span> user can result <span class="k">in </span>broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv
</code></pre></div></div>

<p>  如下所示，当已经如<strong>验证</strong>部分加载好 python 3.10.6 模块后，使用以下命令新建虚拟环境、激活后即可使用。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>   新建虚拟环境时最后的参数 env 是指虚拟环境的名字，我们可以取任意符合 python 规则的字符串作为虚拟环境名字。值得注意的是，python 虚拟环境有关的文件将会被安装在命令执行的当前目录下的同名文件夹中。为了便于管理和使用，建议将所有的 python 虚拟环境都放置在同一目录下。</p>



 </div> </div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 新建 env 虚拟环境</span>
╰─<span class="nv">$ </span>python3 <span class="nt">-m</span> venv <span class="nb">env</span>

<span class="c"># 激活 env 虚拟环境</span>
╰─<span class="nv">$ </span><span class="nb">source env</span>/bin/activate

<span class="c"># 可以看到 &lt;env&gt; 的环境提示</span>
<span class="c"># 尝试升级 pip，可以看到成功升级 </span>
╭─zhonger@lep-u ~ ‹env›
╰─<span class="nv">$ </span>pip3 <span class="nb">install</span> <span class="nt">-U</span> pip
Requirement already satisfied: pip <span class="k">in</span> ./env/lib/python3.10/site-packages <span class="o">(</span>22.2.1<span class="o">)</span>
Collecting pip
  Using cached pip-23.0.1-py3-none-any.whl <span class="o">(</span>2.1 MB<span class="o">)</span>
Installing collected packages: pip
  Attempting uninstall: pip
    Found existing installation: pip 22.2.1
    Uninstalling pip-22.2.1:
      Successfully uninstalled pip-22.2.1
Successfully installed pip-23.0.1

<span class="c"># 取消激活 env 虚拟环境</span>
╰─<span class="nv">$ </span>deactivate
</code></pre></div></div>

<h2 id="有趣的问题">有趣的问题</h2>

<p>  如果使用 module 提供的 python 模块创建了虚拟环境后，实际运行虚拟环境时还需要使用 module 加载 python 模块吗？答案是<strong>不需要</strong>。虚拟环境的本质是拷贝运行相同命令所需的必要文件，如下对比查看一下 python 模块和 env 虚拟环境的顶级目录。可以发现，两者的差别不是很大。env 虚拟环境少了 share 目录，多了 pyvenv.cfg 文件。查看该文件可知，存在与 python 模块之间的关系的声明。再查看 bin 目录，可以看到 python 可执行命令用了链接的方式，pip 命令则是直接从原来的 python 模块复制过来的。于是，这就能允许普通用户自行管理  pip 命令和 python 库了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span><span class="nb">ls</span> /opt/python/3.10.6
bin  include  lib  share

╰─<span class="nv">$ </span><span class="nb">ls env
</span>bin  include  lib  lib64  pyvenv.cfg

╰─<span class="nv">$ </span><span class="nb">cat env</span>/pyvenv.cfg
home <span class="o">=</span> /opt/python/3.10.6/bin
include-system-site-packages <span class="o">=</span> <span class="nb">false
</span>version <span class="o">=</span> 3.10.6

╰─<span class="nv">$ </span>ll <span class="nb">env</span>/bin
total 36K
<span class="nt">-rw-r--r--</span> 1 zhonger zhonger 8.9K Mar 20 15:20 Activate.ps1
<span class="nt">-rw-r--r--</span> 1 zhonger zhonger 2.0K Mar 20 15:20 activate
<span class="nt">-rw-r--r--</span> 1 zhonger zhonger  908 Mar 20 15:20 activate.csh
<span class="nt">-rw-r--r--</span> 1 zhonger zhonger 2.1K Mar 20 15:20 activate.fish
<span class="nt">-rwxrwxr-x</span> 1 zhonger zhonger  234 Mar 20 15:20 pip
<span class="nt">-rwxrwxr-x</span> 1 zhonger zhonger  234 Mar 20 15:20 pip3
<span class="nt">-rwxrwxr-x</span> 1 zhonger zhonger  234 Mar 20 15:20 pip3.10
lrwxrwxrwx 1 zhonger zhonger    7 Mar 20 15:20 python -&gt; python3
lrwxrwxrwx 1 zhonger zhonger   30 Mar 20 15:20 python3 -&gt; /opt/python/3.10.6/bin/python3
lrwxrwxrwx 1 zhonger zhonger    7 Mar 20 15:20 python3.10 -&gt; python3
</code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://docs.python.org/zh-cn/3/using/unix.html#building-python">Python 官方文档 - 构建 Python</a></li>
  <li><a href="https://docs.python.org/zh-cn/3/using/configure.html#configure-options">Python 官方文档 - 性能选项</a></li>
  <li><a href="https://docs.python.org/zh-cn/3/tutorial/venv.html">Python 官方文档 - 虚拟环境和包</a></li>
  <li><a href="https://www.python.jp/install/ubuntu/index.html">Ubuntu 環境の Python</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Linux" /><category term="Modules" /><category term="Python" /><category term="软件环境" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">集群动态环境管理神器 Modules</title><link href="https://lisz.me/tech/webmaster/modules.html" rel="alternate" type="text/html" title="集群动态环境管理神器 Modules" /><published>2022-10-26T15:48:00+09:00</published><updated>2022-10-26T15:48:00+09:00</updated><id>https://lisz.me/tech/webmaster/modules</id><content type="html" xml:base="https://lisz.me/tech/webmaster/modules.html"><![CDATA[<h2 id="前言">前言</h2>

<div class="premonition citation"> <div class="header"> <svg class="icon citation" aria-hidden="true"> <use xlink:href="#icon-citation"></use> </svg> </div> <div class="content"> <p>  Modules 包是一款简化 shell 初始化的工具，允许用户在会话期间使用模块文件轻松切换环境。</p>



 </div> <div class="ref"> ------ Environment Modules 官网 </div> </div>
<p>  在高性能集群或者超算中，我们可以经常看到 Modules 的身影。它可以帮助我们轻松加载运行程序所需的各类环境，比如说笔者之前写过的第一性原理计算软件 CONQUEST 的运行，就需要包括 Intel OneAPI HPCKit、FFTW3、LibXC 在内的多种环境；又比如说运行大规模的机器学习模型时，可能需要 Python、GPU 环境和 PyTorch 等依赖库。</p>

<p>  由于集群往往是面向很多人服务的，如果管理员将软件安装到全局环境，则只能安装某个软件的某个特定版本，而不能同时为不同的用户提供所需的同款软件的不同版本。举个例子，笔者编写的代码只能在 Python 3.10 环境下运行，而其他用户编写的代码所支持的 Python 版本是 3.0，那么可能最简单的解决方法是笔者自行编译一个 Python 3.10 的环境，然后利用 PATH 等变量的配置来提升优先级。或许之后有一天，另外一个用户也要使用 Python 3.10 环境，那么是不是让他再自行编译配置一遍呢？哈哈哈，听起来有点无奈，但是<strong>千万不要高估集群的使用用户</strong>，可能自行编译并配置 Python 3.10 对他们来说也有点困难。因此，Modules 成为了集群动态管理软件环境的最佳选择。集群管理员可以预先编译和配置好各种环境的各种版本，用户使用时只需要执行类似 <code class="language-plaintext highlighter-rouge">module load py/3.10.6</code> 的命令就可以轻松加载 Python 3.10.6 环境。</p>

<p>  Modules 所支持的模块不仅仅可以是编程语言的多版本，还可以是其他任意的基础环境，比如说 gcc、openmpi 等编译环境。这样一来，不仅可以为用户提供足够的编程环境直接使用，还可以为一些想要自行编译运行环境的用户提供了便利。</p>

<h2 id="实践">实践</h2>

<h3 id="源码编译安装-modules">源码编译安装 Modules</h3>

<p>  Modules 可以在 Linux、Windows、MacOS 任一操作系统上安装运行，这里仅介绍类 Unix 操作系统下的编译安装过程。由于 Modules 需要使用 tcl 工具来解析 modulefiles，所以系统必须预先安装 tcl 及其开发者库。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 根据实际情况三者选其一</span>
<span class="c"># Debian/Ubuntu 等 APT 系列操作系统上安装 tcl</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> tcl tcl-dev
<span class="c"># CentOS 等 YUM 系列操作系统上安装 tcl</span>
<span class="nb">sudo </span>yum <span class="nb">install</span> <span class="nt">-y</span> tcl tcl-devel
<span class="c"># MacOS 操作系统上安装 tcl （需有 brew 工具）</span>
brew <span class="nb">install </span>tcl-tk

<span class="c"># 下载源代码并解压</span>
wget <span class="nt">-c</span> https://github.com/cea-hpc/modules/releases/download/v5.1.1/modules-5.1.1.tar.gz
<span class="nb">tar </span>xfz modules-5.1.1.tar.gz

<span class="c"># 创建安装目录</span>
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /opt/modules

<span class="c"># 进入目录并配置安装目录</span>
<span class="nb">cd </span>modules-5.1.1
./configure <span class="nt">--prefix</span><span class="o">=</span>/opt/modules
<span class="c"># MacOS 可能需要如下另外指定 tclConfig.sh 文件所在的位置</span>
./configure <span class="nt">--prefix</span><span class="o">=</span>/opt/modules <span class="nt">--with-tcl</span><span class="o">=</span>/opt/homebrew/opt/tcl-tk/lib

<span class="c"># 编译并安装到 /opt/modules 目录</span>
make <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<h3 id="使-modules-生效">使 Modules 生效</h3>

<p>  并非是编译完了之后就可以直接使用 Modules，还有至关重要的一步–<strong>添加生效命令</strong>。首先需要确认当前使用的 Shell 是什么，一般来说默认是 Bash，当然也有 Zsh 等等。然后，在对应的 Shell 配置文件中增加一行生效命令。操作如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 确认当前使用的 Shell</span>
╰─<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$SHELL</span>
/bin/zsh

<span class="c"># 查看 Modules 支持的 Shell</span>
╰─<span class="nv">$ </span><span class="nb">ls</span> /opt/modules/init
bash            cmake           fish            ksh             lisp            profile.csh     python.py       ruby.rb         tcl             tcsh_completion zsh-functions
bash_completion csh             fish_completion ksh-functions   perl.pm         profile.sh      r.R             sh              tcsh            zsh
<span class="c"># 如上所示，大部分流行的 Shell 都在支持列表中</span>

<span class="c"># 使 Modules 生效</span>
vim ~/.zshrc
<span class="c"># 添加以下内容</span>
<span class="nb">source</span> /opt/modules/init/zsh
</code></pre></div></div>

<h3 id="源码编译安装-tcl">源码编译安装 tcl</h3>

<p>  Modules 的编译安装是不是很简单？不过如果 tcl 工具无法使用命令安装的话，就只能从源码编译安装，也比较方便，如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 下载源码并解压</span>
wget <span class="nt">-c</span> https://prdownloads.sourceforge.net/tcl/tcl8.6.12-src.tar.gz
<span class="nb">tar </span>xfz tcl8.6.12-src.tar.gz

<span class="c"># 创建安装目录</span>
<span class="nb">sudo mkdir</span> /opt/tcl

<span class="c"># 进入目录并配置安装目录</span>
<span class="nb">cd </span>tcl8.6.12/unix
./configure <span class="nt">--prefix</span><span class="o">=</span>/opt/tcl

<span class="c"># 编译并安装</span>
make <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<h3 id="modules-相关命令">Modules 相关命令</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看所有可用模块</span>
module avail / module ava

<span class="c"># 加载指定模块（支持同时加载多个模块）</span>
module load py/3.10.6 mpi

<span class="c"># 查看已加载模块</span>
module list

<span class="c"># 查看指定模块</span>
module show py/3.10.6

<span class="c"># 添加自定义模块配置目录</span>
module use <span class="nt">--apend</span> ~/opt/modulefiles
</code></pre></div></div>

<h2 id="添加软件环境">添加软件环境</h2>

<h3 id="modulefiles-库">Modulefiles 库</h3>

<p>  Modules 编译安装后默认会有一些环境，它们的配置文件都被存储在安装目录的 modulefiles 文件夹中，如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>module ava
<span class="nt">---------------------------</span> /opt/modules/modulefiles <span class="nt">---------------------------</span>
dot  module-git  module-info  modules  null  use.own

Key:
modulepath

╰─<span class="nv">$ </span><span class="nb">ls</span> /opt/modules/modulefiles
dot         module-git  module-info modules     null        use.own
</code></pre></div></div>

<p>  一般来说，打算提供给所有用户的环境配置都可以放在这个目录里，这样任何用户都可以查看到。</p>

<h3 id="modulefiles-模板">Modulefiles 模板</h3>

<p>  这里我们可以把 <code class="language-plaintext highlighter-rouge">use.own</code> 文件作为模板来学习一下如何编写 Modulefiles 文件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#%Module1.0#####################################################################</span>
<span class="c">##</span>
<span class="c">## use.own modulefile</span>
<span class="c">##</span>
proc ModulesHelp <span class="o">{</span> <span class="o">}</span> <span class="o">{</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">This module file will add </span><span class="se">\$</span><span class="s2">HOME/privatemodules to the"</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">list of directories that the module command will search"</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">for modules.  Place your own module files here."</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">This module, when loaded, will create this directory"</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">if necessary."</span>
<span class="o">}</span>

module-whatis   <span class="s2">"adds your own modulefiles directory to MODULEPATH"</span>

<span class="nb">eval set</span>  <span class="o">[</span> array get <span class="nb">env </span>HOME <span class="o">]</span>
<span class="nb">set </span>ownmoddir   <span class="nv">$HOME</span>/privatemodules

<span class="c"># create directory if necessary</span>
<span class="k">if</span> <span class="o">[</span> module-info mode load <span class="o">]</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">{</span> <span class="o">!</span> <span class="o">[</span> file exists <span class="nv">$ownmoddir</span> <span class="o">]</span> <span class="o">}</span> <span class="o">{</span>
        file <span class="nb">mkdir</span> <span class="nv">$ownmoddir</span>
        <span class="nb">set </span>null <span class="o">[</span>open <span class="nv">$ownmoddir</span>/null w]
        puts <span class="nv">$null</span> <span class="s2">"#%Module########################################################################"</span>
        puts <span class="nv">$null</span> <span class="s2">"##"</span>
        puts <span class="nv">$null</span> <span class="s2">"## null modulefile"</span>
        puts <span class="nv">$null</span> <span class="s2">"##"</span>
        puts <span class="nv">$null</span> <span class="s2">"proc ModulesHelp { } {"</span>
        puts <span class="nv">$null</span> <span class="s2">"    puts stderr </span><span class="se">\"\t</span><span class="s2">This module does absolutely nothing.</span><span class="se">\"</span><span class="s2">"</span>
        puts <span class="nv">$null</span> <span class="s2">"    puts stderr </span><span class="se">\"\t</span><span class="s2">It's meant simply as a place holder in your</span><span class="se">\"</span><span class="s2">"</span>
        puts <span class="nv">$null</span> <span class="s2">"    puts stderr </span><span class="se">\"\t</span><span class="s2">dot file initialization.</span><span class="se">\"</span><span class="s2">"</span>
        puts <span class="nv">$null</span> <span class="s2">"}"</span>
        puts <span class="nv">$null</span> <span class="s2">""</span>
        puts <span class="nv">$null</span> <span class="s2">"module-whatis   </span><span class="se">\"</span><span class="s2">does absolutely nothing</span><span class="se">\"</span><span class="s2">"</span>
    <span class="o">}</span>
<span class="o">}</span>

module use <span class="nt">--append</span> <span class="nv">$ownmoddir</span>
</code></pre></div></div>

<p>  Modulefiles 文件一般符合以下规则：</p>

<ul>
  <li>Modulefiles 文件必须以 <code class="language-plaintext highlighter-rouge">#%Module1.0</code> 开头；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">proc ModulesHelp {}</code> 函数来添加模块详细描述；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">module-whatis</code> 字段来添加一句话简短描述；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">eval set [ array get env HOME]</code> 来获取系统变量 <code class="language-plaintext highlighter-rouge">$HOME</code>；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">set ownmoddir</code> 来定义变量 <code class="language-plaintext highlighter-rouge">ownmoddir</code>；</li>
  <li>后续脚本可以根据需求进行添加内容。</li>
</ul>

<p>  这里先开个坑，后续打算补充 Modules 配置系列文章：</p>

<ul>
  <li><a href="modules-python.html">《Modules 配置之 Python》</a></li>
  <li><a href="modules-conda.html">《Modules 配置之 Anaconda》</a></li>
  <li><a href="modules-intel.html">《Modules 配置之 Intel OneAPI》</a></li>
</ul>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://modules.readthedocs.io/en/latest/index.html">Environment Modules 官方文档</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Linux" /><category term="集群" /><category term="Cluster" /><category term="Modules" /><category term="软件环境" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">LDAP 集成之 OpenVPN 篇</title><link href="https://lisz.me/tech/webmaster/ldap-openvpn.html" rel="alternate" type="text/html" title="LDAP 集成之 OpenVPN 篇" /><published>2022-09-28T15:04:00+09:00</published><updated>2022-09-28T15:04:00+09:00</updated><id>https://lisz.me/tech/webmaster/ldap-openvpn</id><content type="html" xml:base="https://lisz.me/tech/webmaster/ldap-openvpn.html"><![CDATA[<h2 id="前言">前言</h2>

<h3 id="easy-connect">Easy Connect</h3>

<p>  公司、学校、云服务等一般需要将内外网进行分离，如果想要从外部网络访问某些内部应用，通常需要使用公司、学校、云服务提供的专用网络接入服务。国内公司、学校比较常用的是由深信服开发的 Easy Connect，一种 SSL VPN 技术的实现。虽然每年需要支付一定的费用来维护、升级 Easy Connect 服务，但是毕竟它能够提供比较细粒度的权限控制，比如说对目标 IP、目标端口的特别指定，能够有效保护内网服务器只有 Web 应用本身能被用户接入，而类似于 SSH 等服务及端口则可以通过单独申请和配置来实现。总而言之，除了需要付费，似乎没有什么不好的地方。</p>

<p>  实际上如果是在大公司或者学校的话，可能在内网里面还会有更深的内网存在。举个例子，正常的内网是日常的办公或开发网络，服务器所处的内网是独立的网络，即使是已经连接了办公网络，还是需要通过专用网络接入服务器内网才能进行服务器的维护。如果是以数据中心的模式运营的话，甚至说每一次访问服务器都是需要经过临时审批和登录密码发放的。一旦过了有效时间或者完成了任务，访问都将会被拒绝。</p>

<h3 id="openvpn">OpenVPN</h3>

<p>  虽然 Easy Connect 可以用于上述的场景，但是似乎显得有些大材小用了，毕竟还是要支付一定费用的。为了尽量降低成本，开源的 OpenVPN 或许是一种不错的选择。据笔者所知，Easy Connect 根据购买的许可不同允许的同时在线人数可能也会不同，实际上可能存在“需大于供”的问题。为了缓解这一可能存在的问题，还是会搭建一套 OpenVPN 来作为冗余接入方式。其实 OpenVPN 的商业版本许可也是会有人数限制的，只不过因为只是备份方式也没有太大关系。</p>

<p>  OpenVPN 除了开源免费之外，还支持大部分主流的认证方式，比如说 LDAP 认证、微软的商业级目录服务 Active Directory（简称 AD）认证等。近年来，基于 Identify Provider（简称 IdP）、Single Sign On（简称 SSO）、Central Authentication Service（简称 CAS）等的国产化的一站式登录服务解决方案也在逐渐替换原来的 LDAP 或 AD 直接认证，LDAP 或 AD 将作为底层的基础认证方式存在。所以说，开源免费的 LDAP 目录服务在一般的团队中还是足够的，作为 OpenVPN 的认证方式也是完全能满足要求的。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 提醒 </div> </div> <div class="content"> <p>  在公网上搭建专用网络接入服务是需要有工信部颁发的专门资格许可的，一般公司、学校、云服务都是有该类资格许可，所以可以对外提供该项服务。而个人是无法获得这类许可，除非注册公司并申请该类许可。如果个人在云服务上搭建该类服务，将会面临被云服务提供商警告甚至单方面停止服务的风险。</p>



 </div> </div>
<h2 id="实践">实践</h2>

<h3 id="环境要求">环境要求</h3>

<p>  在实践前请务必保证具备以下环境：</p>

<ul>
  <li>Docker</li>
  <li>docker-compose</li>
  <li>可用的 LDAP 目录服务</li>
</ul>

<h3 id="启动实例">启动实例</h3>

<p>  为了方便部署和测试，这里采用 <a href="https://hub.docker.com/r/wheelybird/openvpn-ldap-otp">wheelybird/openvpn-ldap-otp</a> 提供的 Docker 镜像。这个镜像比较小，同时也支持 x64 和 arm 两种体系架构，能满足大部分主流服务器平台。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># docker-compose.yml</span>

<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">openvpn</span><span class="pi">:</span>
    <span class="na">cap_add</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">NET_ADMIN</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">wheelybird/openvpn-ldap-otp</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">openvpn</span>
    <span class="na">ports</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s2">"</span><span class="s">1194:1194/udp"</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">volumes</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">/etc/localtime:/etc/localtime:ro</span>
     <span class="pi">-</span> <span class="s">/etc/timezone:/etc/timezone:ro</span>
     <span class="pi">-</span> <span class="s">./openvpn-data:/etc/openvpn</span>
    <span class="na">environment</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">OVPN_SERVER_CN=oc-vpn.example.com</span>
     <span class="pi">-</span> <span class="s">LDAP_URI=ldap://ldap.example.com</span>
     <span class="pi">-</span> <span class="s">LDAP_BASE_DN=ou=users,dc=example,dc=com</span>
     <span class="pi">-</span> <span class="s">LDAP_BIND_USER_DN=cn=admin,dc=example,dc=com</span>
     <span class="pi">-</span> <span class="s">LDAP_BIND_USER_PASS=password</span>
     <span class="pi">-</span> <span class="s">LDAP_LOGIN_ATTRIBUTE=uid</span>
     <span class="pi">-</span> <span class="s">LOG_TO_STDOUT=false</span>
     <span class="pi">-</span> <span class="s">OVPN_DNS_SEARCH_DOMAIN=example.com</span>
</code></pre></div></div>

<p>  使用以下 docker-compose.yml 文件和 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 命令启动实例。为了能够避免实例在重新创建后证书发生改变，将 Docker 实例中 /etc/openvpn 的目录持久化（与本地目录绑定）是非常重要的。在这里给出的环境变量（environment）中，前三项 OVPN_SERVER_CN、LDAP_URI、LDAP_BASE_DN 是必须要有的。如果 LDAP 目录服务默认是不能被匿名查找的，也必须包含 LDAP_BIND_USER_DN 和 LDAP_BIND_USER_PASS 变量的（即管理员账户名和密码）。当然，如果你想要指定匹配登录用户名字段，则需要新增 LDAP_LOGIN_ATTRIBUTE 变量。该变量默认是 uid 字段，也可以指定为其他 LDAP 目录服务中包含的字段，比如 email。这个镜像默认是会将服务的实时输出打印在终端，如果想要以日志文件的形式保存下来，则将变量 LOG_TO_STDOUT 置为 false 即可。</p>

<p>  一般来说，服务器内网为了管理方便，会根据服务器的 ip 和编号来配置对应的域名解析及反向域名解析，形如 <code class="language-plaintext highlighter-rouge">ec2-1-1-1-1.aws.com</code>，也有可能就是简单的 <code class="language-plaintext highlighter-rouge">c1.sever.aws.com</code>。所以当接入服务器内网后，我们可能会期望用 c1 来作为这台服务器的标签，而在终端我们也可能通过 <code class="language-plaintext highlighter-rouge">ping c1</code> 来测试通路。实际上只要在启动实例时新增变量 OVPN_DNS_SEARCH_DOMAIN 就可以实现，当然这里变量对应的值也应该变成 <code class="language-plaintext highlighter-rouge">server.aws.com</code>。相当于，有了这个配置后，本地 DNS 解析没有记录时会自动尝试加入后缀来解析。这样一来，是不是方便了很多呢？</p>

<p>  除此之外，该镜像还支持其他一些特性，比如 OTP，请访问 <a href="https://github.com/wheelybird/openvpn-server-ldap-otp">wheelybird/openvpn-ldap-otp</a> 了解更多。</p>

<h4 id="生成配置文件">生成配置文件</h4>

<p>  在生成配置文件上，<a href="https://github.com/wheelybird/openvpn-server-ldap-otp">wheelybird/openvpn-ldap-otp</a> 要比 <a href="https://github.com/kylemanna/docker-openvpn">kylemanna/docker-openvpn</a> 更复杂一些，可以手动从 Docker 实例的日志文件或终端输出内容中看到内容，大致内容形式如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#---------- Start of client.ovpn ----------</span>

client
tls-client
dev tun
persist-key
persist-tun
remote-cert-tls server
key-direction 1
auth SHA512
proto tcp
reneg-sec 0

comp-lzo
redirect-gateway def1
auth-user-pass

<span class="c"># Set log file verbosity</span>
verb 3

&lt;connection&gt;
remote oc-vpn.example.com 1194 udp
float
nobind
&lt;/connection&gt;

&lt;ca&gt;
<span class="nt">-----BEGIN</span> CERTIFICATE-----
.........
.........
<span class="nt">-----END</span> CERTIFICATE-----
&lt;/ca&gt;
&lt;tls-auth&gt;
<span class="c">#</span>
<span class="c"># 2048 bit OpenVPN static key</span>
<span class="c">#</span>
<span class="nt">-----BEGIN</span> OpenVPN Static key V1-----
.........
.........
<span class="nt">-----END</span> OpenVPN Static key V1-----
&lt;/tls-auth&gt;
key-direction 1
<span class="c">#----------  End of client.ovpn  ----------</span>
</code></pre></div></div>

<p>  将以上内容复制保存在 oc-vpn.example.com.ovpn 文件中即可。</p>

<h3 id="测试">测试</h3>

<p>  通常来说使用 OpenVPN 专用或者兼容客户端来加载配置文件 oc-vpn.example.com.ovpn，当然也可以用终端命令连接，如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>openvpn <span class="nt">--config</span> oc-vpn.example.com.ovpn
</code></pre></div></div>

<p>  执行上述命令后会提示输入用户名和密码进行认证，认证通过后会建立连接。默认分配的是 10.50.50.0/24 段中的某个 IP，网关为 10.50.50.254，当然这个也可以在启动实例时自行设置。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 再次提醒 </div> </div> <div class="content"> <p>  以上内容比较适用于团队办公或开发网络与服务器网络独立分离的情况（<strong>内网环境</strong>）。请勿在未获得工信部的资质许可的情况下在公网部署类似服务，一旦被云服务提供商监测到，云服务提供商有权进行警告、断网、关停等操作，并且无法申诉。</p>



 </div> </div>
<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://github.com/wheelybird/openvpn-server-ldap-otp">wheelybird/openvpn-ldap-otp</a></li>
  <li><a href="https://github.com/kylemanna/docker-openvpn">kylemanna/docker-openvpn</a></li>
</ul>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 提示 </div> </div> <div class="content"> <p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=1jkj42lj2m4nn">加入链接</a>。</p>



 </div> </div>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="LDAP" /><category term="OpenVPN" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">LDAP 集成之 Squid 篇</title><link href="https://lisz.me/tech/webmaster/ldap-squid.html" rel="alternate" type="text/html" title="LDAP 集成之 Squid 篇" /><published>2022-09-28T15:00:00+09:00</published><updated>2022-09-28T15:00:00+09:00</updated><id>https://lisz.me/tech/webmaster/ldap-squid</id><content type="html" xml:base="https://lisz.me/tech/webmaster/ldap-squid.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  Squid cache，简称 Squid，是一款高性能的代理缓存软件。Squid 本身支持包括 HTTP、HTTPS、FTP、SSH 在内的多种协议，且采用一个单独的、非模块化的、I/O 驱动的进程来处理所有的客户端请求，从而提供<strong>主动缓存加速</strong>的功能。除此之外，Squid 还可以提供<strong>应用层过滤控制</strong>的功能，也可与其他的<strong>防病毒</strong>软件一起使用。在一些大公司、学校、研究机构内部，一般采用 Squid 代理上网的方式，可以过滤危险内容或操作、节省网络带宽、提升访问速度。</p>

<p>  但实际上 Squid 代理也可用于正向代理，即为外来用户访问内网应用提速。这也是 CDN（内容分发网络）的加速原理，利用位于全球网络边缘的节点提供服务，而实际上的应用内容则通过边缘节点间的内网来缓存提速。</p>

<p>  虽然 Squid 一般部署在团队或公司网络内部，但是由于用户的权限不同可能需要应用不同的规则，所以能够与 LDAP 认证服务结合就变得非常重要了。</p>

<h2 id="实践">实践</h2>

<h3 id="环境要求">环境要求</h3>

<p>  在进行正式的实践之前，务必确保已有以下环境：</p>

<ul>
  <li>Docker</li>
  <li>docker-compose</li>
</ul>

<h3 id="启动实例">启动实例</h3>

<p>  笔者已经编译并公开了在多种体系架构上可用的 Docker 镜像 <a href="https://github.com/zhonger/docker-squid">zhonger/squid</a>。这里直接使用以下 docker-compose.yml 配置文件和 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 命令启动实例。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># docker-compose.yml</span>
<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.2'</span>

<span class="na">services</span><span class="pi">:</span> 
  <span class="na">squid</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">zhonger/squid</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">squid</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">squid</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">3128:3128"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">/etc/timezone:/etc/timezone:ro</span>
      <span class="pi">-</span> <span class="s">/etc/localtime:/etc/localtime:ro</span>
    <span class="na">environment</span><span class="pi">:</span> 
      <span class="pi">-</span> <span class="s">SQUID_SSH=true</span>
      <span class="pi">-</span> <span class="s">SQUID_RSYNC=false</span>
      <span class="pi">-</span> <span class="s">LDAP_ENABLE=true</span>
      <span class="pi">-</span> <span class="s">LDAP_HOST=yourldap.domain.com</span>
      <span class="pi">-</span> <span class="s">LDAP_PORT=389</span>
      <span class="pi">-</span> <span class="s">LDAP_BindDN="cn=admin,dc=yourdomain,dc=com"</span>
      <span class="pi">-</span> <span class="s">LDAP_BindPass="********"</span>
      <span class="pi">-</span> <span class="s">LDAP_DN="ou=Users,dc=yourdomain,dc=com"</span>
      <span class="pi">-</span> <span class="s">LDAP_ATTRIBUT="uid=%s"</span>
      <span class="pi">-</span> <span class="s">PROXY_NAME="Proxy Display Name"</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
</code></pre></div></div>

<p>  上面有关的配置变量及其含义可以访问 <a href="https://github.com/zhonger/docker-squid">zhonger/squid</a> 了解更多。</p>

<h4 id="测试">测试</h4>

<p>  通过浏览器访问 http://ip:3128 并输入对应的用户名和密码可以看到类似下面的内容。</p>

<p><img src="https://i.lisz.top/blog/nUOnpb.webp" alt="nUOnpb" /></p>

<h3 id="客户端连接">客户端连接</h3>

<p>  由于我们未指定实际需要访问的地址，Squid 会直接报错。一般使用时，需要使用操作系统的网络设置中的代理来配置好 Squid。如下图所示，勾选“网页代理（HTTP）”并填写相关的 IP、端口、用户名及密码。如果想要同样应用在访问 HTTPS 站点，则还需要勾选“安全网页代理（HTTPS）”及填写相关信息。然后点击保存生效。</p>

<p><img src="https://i.lisz.top/blog/oXWsLE.webp" alt="oXWsLE" /></p>

<p>  这样一来就可以将访问的流量完全交给 Squid 来控制了。当然，如果不确定客户端连接是否成功，可以通过访问 <a href="https://ip.sb">ip.sb</a> 来确认当前客户端流量出口 IP 是否为 Squid 服务器 IP。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="http://www.squid-cache.org/">Squid cache</a></li>
  <li><a href="https://zh.wikipedia.org/zh-cn/Squid_(%E8%BD%AF%E4%BB%B6)">Squid 软件</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="LDAP" /><category term="Squid" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">内网私有域名解析</title><link href="https://lisz.me/tech/webmaster/internal-dns.html" rel="alternate" type="text/html" title="内网私有域名解析" /><published>2022-08-04T11:30:00+09:00</published><updated>2022-08-04T11:30:00+09:00</updated><id>https://lisz.me/tech/webmaster/internal-dns</id><content type="html" xml:base="https://lisz.me/tech/webmaster/internal-dns.html"><![CDATA[<h2 id="前言">前言</h2>

<h3 id="域名和域名解析">域名和域名解析</h3>

<p>  大家可能知道，在网络被发明出来之后一段时间，大家采用 <code class="language-plaintext highlighter-rouge">IP + Port</code> 的方式一起共享资源。后来随着资源越来越多，这样一种方式显得非常不友好。比如说，现在有 254 个 IP，每个 IP 上有 20 个 Web 应用，那么我们就必须记住 5080 个 <code class="language-plaintext highlighter-rouge">IP + Port</code> 的组合，简直太折磨人了。于是在 1983 年，保罗・莫卡派乔斯发明了域名解析服务和域名服务（DNS，Domain Name System）。从此以后，大家开始用域名来访问各种各样的应用服务。显然，相比原来 <code class="language-plaintext highlighter-rouge">IP + Port</code> 的方式，域名的含义更加具象、更容易被人记住。</p>

<p>  域名解析实际上就是把 IP 和一串有意义的字符对应，这是一对多的关系，即一个 IP 可能对应多个域名。域名的管理单位我们称之为域名注册管理机构，他们掌握着顶级域名的管理权利。比如说，.net、.com、.org 就是顶级域名，域名注册管理机构对顶级域名具有完整的权利。就像上次讲到的 SSL 根证书一样，光有域名注册管理机构还是不够的，他们没有办法直接把域名卖给全世界所有的公司或者个人，而是需要域名注册商承担这部分工作。像我们比较熟知的国内的万网（现在阿里云域名）、DNSPod（现在腾讯云域名）等，国外的 Gandi、Godaddy 等，都是域名注册商。顶级域名根据用途不同可以分为，国别域名后缀和通用域名后缀。国别域名后缀就是指定给各个国家或地区使用的，通用域名后缀就是其余的。我们可以在某域名注册商处购买某个域名后缀（也称顶级域名）的子域名（也称二级域名），比如说我们可以购买域名后缀为 .com 的域名 baidu.com（当然 baidu.com 早就被注册了，我们只能购买还未被注册的域名）。由于一些品牌效应，大部分域名后缀都会保留一些子域名，我们一般称之为<strong>溢价域名</strong>。一般来说，溢价域名也会比普通域名价格更贵。当我们购买了域名之后，域名注册商会免费提供域名解析服务。当然，我们也可以要求使用其他厂商提供的免费或收费域名解析服务，甚至也可自行搭建域名解析服务。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 小提醒 </div> </div> <div class="content"> <p>  国内需具备一定资质才能在公网上搭建域名解析服务，否则会面临警告和阻断的风险。</p>



 </div> </div>
<p>  为了简便，我们一般把域名解析服务称为 DNS 服务。在操作系统中，53 端口被视为 DNS 服务的标准端口（TCP/UDP 服务），853 端口被视为 DNS over TLS 的标准端口（TCP 服务）。除此之外，DNS over HTTPS（TCP 服务）和 DNS over Quic（新协议，UDP 服务）的标准端口是 443。所以现有能够公开使用的 DNS 服务都采用了标准端口，比如国内著名的 114 DNS、阿里云 DNS、腾讯云 DNS、百度云 DNS 都是如此。如果想要了解更多开放可用的 DNS 服务可以查看 <a href="https://adguard-dns.io/kb/general/dns-providers/">这里</a>。</p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 小知识 </div> </div> <div class="content"> <p>  DNS 按照功能上的不同可以分为 <strong>权威 DNS</strong> 和 <strong>递归 DNS</strong>。权威 DNS 负责对某个或多个子域名进行管理，注册商提供的域名解析服务就是这一类。递归 DNS 负责接收客户端的请求并将查询到的域名对应记录返回给客户端，也就是说它本身不对任何子域名进行管理，只转述别人告诉它的结果。</p>



 </div> </div>
<p>  当我们使用 DNS 时，它（这里指递归 DNS）会如下图所示按照域名系统的构成逐级进行查询。比如说，现在我们想访问 www.baidu.com：</p>

<ol>
  <li>客户端（我们）向递归 DNS 请求解析 www.baidu.com；</li>
  <li>递归 DNS 会先去问一下它的上游 DNS，如果不存在上游 DNS，它就只能去问 DNS 根服务器；</li>
  <li>DNS 根服务器并不知道具体的解析记录，但是会告诉递归 DNS 顶级域名 .com 的 DNS 服务器；</li>
  <li>递归 DNS 接着向 .com 的 DNS 服务器询问；</li>
  <li>结果 .com 的 DNS 服务器也不知道具体的解析记录，但是会告诉递归 DNS 二级域名 baidu.com 的 DNS 服务器；</li>
  <li>这样递归 DNS 才会去问域名 baidu.com 的权威 DNS；</li>
  <li>然后，baidu.com 权威 DNS 响应 www.baidu.com 对应的 A 记录（或者 AAAA 记录）是什么；</li>
  <li>最后，递归 DNS 将解析结果告诉客户端（我们）。</li>
</ol>

<p><img src="https://i.lisz.top/blog/hwyKGH.webp" alt="域名解析过程 DNS Resolution Process" /></p>

<p>  那么问题来了，<strong>一个 DNS 能否同时是权威 DNS 和递归 DNS 呢？</strong>实际上是不可能的，但是可以实现这种效果。如果我们把权威 DNS 隐藏在递归 DNS 的后面，那么对于顶级域名 DNS 来说，你指定的递归 DNS 就是它理解的权威 DNS。这里的隐藏指的是，当有请求询问递归 DNS 的权威解析记录时，递归 DNS 根据规则将请求转发给背后真正的权威 DNS。等待权威 DNS 返回解析记录后，递归 DNS 再把结果返回给请求方（其他递归 DNS 或者客户端）。</p>

<h3 id="私有域名解析">私有域名解析</h3>

<h4 id="必要性">必要性</h4>

<p>  以上谈到的都是公有域名的相关事情，为什么又要考虑私有域名解析呢？首先，公有域名和私有域名本质上可以没有区别，都是在域名注册商处购买的域名，也可以有所区别，即私有域名是未购买的或者是非 ICANN 支持的域名（比如 .lisz 后缀）。这样一来，我们将不再受<strong>域名是否注册</strong>的限制而应用在内部网络中。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  当然，我们应当避免使用 ICANN 支持的域名后缀且可注册的域名，毕竟可能以后会有人购买这个域名。</p>



 </div> </div>
<p>  其次，解析记录的<strong>内外分离</strong>需求。随着基础服务架构和应用架构的不断发展，越来越多像云计算、Kubernetes 这样需要采用域名解析来连通内部服务。如果我们直接采用一个权威 DNS 来解析这些记录，那就意味着所有人都可以通过查询来知道这些解析记录，甚至有些人就能大致猜出服务架构，这并不是很安全。出于安全上的考量，将同一个域名的解析记录进行内外分离能够在一定程度上提升安全。</p>

<p>  如参考资料中《内网域名系统的安全保密风险研究》所说，“随着内网规模的不断扩大，特别是国家电子政务内网的建成、扩展，在电子政务内网中构建国家级可信内网域名体系的需求越来越迫切，内网域名系统会成为内网的核心基础设施，其安全问题将会越来越被关注。”私有域名解析，即内网域名系统在内网安全中发挥着举足轻重的作用。</p>

<h4 id="用途">用途</h4>

<p>  笔者在实际使用 AWS、Azure、Oracle、阿里云、腾讯云、Ucloud 的过程中，也发现了私有域名解析的应用。举个例子，Oracle 云创建的每一台 VPS 都会有一个内部 FQDN（以 oraclecv.com 为后缀的多级域名）。当你在 VPS 上使用 dig 命令查询这个 FQDN 对应的 A 记录时，VPS 的内网 IP 会被返回。当你在自己的设备上使用 dig 命令查询时，返回为空。再举个例子，云计算厂商的 VPS 默认配置的是他们自家的镜像源，比如腾讯云 VPS 的默认镜像源域名为 mirrors.tencentyun.com，而这个域名在公网上是查不到解析记录的。可见，云计算厂商的架构上也在使用私有域名解析。</p>

<p>  当然，云计算厂商们也向用户提供依托于 VPC（私有网络）的私有域名解析服务，即该私有域名解析服务只有在同一 VPC 内的 VPS 可以使用。而我们又知道，VPC 是属于用户个人的，也就是说不同用户之间的私有域名解析服务完全互不干扰。</p>

<p>  在参考资料一中，阿里云列出了实际云服务中私有域名解析的四大应用场景：</p>

<ul>
  <li><strong>主机名管理</strong>：根据用途、机器信息语义化命名，对运维人员更友好。</li>
  <li><strong>内部调用 API</strong>：内部 API 用域名来访问，即使对应集群或者 IP 发生变化，也可以无感切换。</li>
  <li><strong>内部域名隐私保护</strong>：和上面笔者提到的必要性第二点一样，提升隐私保护。</li>
  <li><strong>私有地址反向解析</strong>：绑定后可以通过 host、traceroute 或其他操作直接识别访问 IP 的来源，便于运维人员排查问题。</li>
</ul>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 小知识 </div> </div> <div class="content"> <p>  域名解析分为<strong>正向解析</strong>和<strong>反向解析</strong>，我们一般见过的“域名 → IP”的域名解析就是正向解析，而反向解析则是“IP → 域名”。一般来说，反向解析多用于邮件服务器的可信认证。将 IP 与 邮件服务器域名的正反向解析都绑定后，能够增强邮件服务器的可信度，降低被收信服务器判定为 <strong>垃圾 IP</strong> 发信的概率。</p>



 </div> </div>
<h2 id="实践">实践</h2>

<h3 id="方案一">方案一</h3>

<p>  内网私有域名解析实际上就是要在内网中搭建一台权威 DNS 和递归 DNS：权威 DNS 用于管理私有域名，递归 DNS 用于解析权威 DNS 记录以及正常的公网解析记录。当然，在公司网络或者机房集群网络中，一般会搭建权威 DNS 集群和递归 DNS 集群来提升可靠性和可用性。权威 DNS 集群通常是主从架构，主节点作为接受域名解析操作的主要接收方，从节点将实时同步主节点记录。当主节点发现故障时，从节点自动升级为主节点。并非所有的集群都是这样，但是这样更加能避免因主节点宕机后无法进行域名解析的更改操作。由于这与采用架设 DNS 服务的软件相关，这里就不作过多探讨。</p>

<p>  与权威 DNS 集群不同的是，内网递归 DNS 集群实际上一般会有两个节点暴露出来。这一点与公网中提供公网递归 DNS 服务是一样的。比如 114 DNS 会告诉大家要设置两个 DNS IP 地址，即 114.114.114.114 和 114.114.115.115。为什么要这样呢？主要还是因为通过冗余来提高可靠性和可用性。我们可能会简单地以为 114 DNS 就只有这两个 IP，但实际上它们的背后还有很多台递归 DNS 服务器。这两台服务器的作用并不是直接处理解析请求，而是为想要域名解析的客户端提供一个更加快和高效的方式来使用递归 DNS。类似于复杂 Web 系统中首先会在交换机上用网关进行优化，然后在服务器上利用 LVS 来负载均衡，之后再利用多个服务后台来分别处理相同的业务，最后再返回信息给用户。这两台递归 DNS 节点也起到了负载均衡的作用。</p>

<p>  当然，这两个 IP 也不是一般的 IP，而是使用了 Anycast 技术的 IP。也就是说，在互联网上会有多台服务器使用了这两个 IP，而当我们向这两个 IP 发起请求时，BGP 会根据客户端所处的地理位置和网络情况将 IP 定位到离客户端最近的两台服务器上。有一个比较客观的体验就是，当我们在全国不同地方 ping 这两个 IP 时，发现似乎延迟差不多且都很短。但是无论我们的骨干网建得多么好，因地理位置和跨网（电信、联通、移动、教育网）所带来的延迟也是无法避免的。唯一一个延迟都很短的可能解释就是响应请求的机器实际上并非同一位置的同两台，而是位于不同位置的不同两台。</p>

<h3 id="方案二">方案二</h3>

<p>  上面的方案考虑的问题比较多，也比较适合在大规模集群或内网中进行实践，但是在小集群中可能就有点过于庞大了，显得没有必要。其实，小集群或者小团队内网可以采用“合二为一”的方案，即递归 DNS 与权威 DNS 由一台服务器来同时提供。由于小集群内网私有域名解析和公有域名解析不需要接近于零的宕机率，所以完全可以最简化。当前最流行的免费解决方案可能就是 AdGuard Home 了。</p>

<div class="premonition citation"> <div class="header"> <svg class="icon citation" aria-hidden="true"> <use xlink:href="#icon-citation"></use> </svg> </div> <div class="content"> <p>  AdGuard Home 是一款全网广告拦截与反跟踪软件。在您将其安装完毕后，它将保护您所有家用设备，同时您不再需要安装任何客户端软件。随着物联网与连接设备的兴起，掌控您自己的整个网络环境变得越来越重要。</p>



 </div> <div class="ref"> ------ AdGuard 主页 </div> </div>
<p>  AdGuard Home 之所以这么受到欢迎，主要是因为其丰富的功能和简单的可视化操作，对于管理员来说非常友好。而且，AdGuard Home 的部署也非常简单，支持多平台架构、多方式一键部署，比如 AdGuard Home 也能在 ARM 芯片上用 Docker 容器的方式一键部署。虽然 AdGuard Home 自带简单的解析记录重写，可以满足大部分常用的内网私有域名解析需求，但是像一些比较高级的解析记录可能就无法做到，比如 TXT 记录。尽管 TXT 记录在 <strong>IP</strong> 和<strong>域名</strong>的相互映射中并不起到作用，但是 TXT 记录可以填写比较长的内容，非常适合用来验证对于域名的管理权限，像 HTTPS 证书的申请一般就是采用新增 TXT 记录的方式验证，还有 Gitlab Page 的自定义域名绑定也是如此。所以为了提供比较完整的域名解析服务，这里还是建议增加一个权威 DNS，可以采用 PowerDNS + PowerDNS Admin（交互界面）或者 Bind9 等。</p>

<p>  考虑到友好的交互界面更容易上手使用，这里只介绍 AdGuard Home + PowerDNS 的方案。需要提前准备的环境有：</p>

<ul>
  <li>Docker</li>
  <li>docker-compose</li>
</ul>

<h3 id="adguard-home">AdGuard Home</h3>

<p>  由于 AdGuard Home 官方已经提供了多平台架构的 Docker 镜像，我们直接使用即可，docker-compose.yml 文件如下所示：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3"</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">adgurad</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">adguard/adguardhome</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">53:53/tcp</span>
      <span class="pi">-</span> <span class="s">53:53/udp</span>
      <span class="pi">-</span> <span class="s">80:80/tcp</span>
      <span class="pi">-</span> <span class="s">443:443/tcp</span>
      <span class="pi">-</span> <span class="s">3000:3000/tcp</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./work:/opt/adguardhome/work</span>
      <span class="pi">-</span> <span class="s">./conf:/opt/adguardhome/conf</span>
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 命令启动 AdGuard Home 实例。</p>

<h4 id="初始化">初始化</h4>

<p>  使用浏览器访问 <a href="http://localhost:3000">http://localhost:3000</a> 进行实例初始化设置，如下所示根据页面提示设置好用户名和密码。</p>

<p><img src="https://i.lisz.top/blog/PreFoj.webp" alt="初始化 AdGuard Home Initial" /></p>

<p><img src="https://i.lisz.top/blog/7LHDlg.webp" alt="确认端口 Check ports" /></p>

<p><img src="https://i.lisz.top/blog/qjTNW8.webp" alt="设置管理员 Set Admin" /></p>

<p><img src="https://i.lisz.top/blog/yLkLc4.webp" alt="客户端配置指南 Client setting guideline" /></p>

<p><img src="https://i.lisz.top/blog/buQ6LT.webp" alt="完成初始化 Finish the initialization" /></p>

<p>  初始化成功后，页面会自动跳转到登录界面 <a href="http://localhost">http://localhost</a>（80 端口）。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  由于在实际环境中，我们不一定是在本机启动该实例，所以可能需要使用服务器的 IP 来替代 localhost 访问。另外，如果原来就有 Nginx 或其他服务占用了 80 端口，我们在配置端口映射的时候可能就会设置到另外一个端口，因此自动跳转到的页面并非是 AdGuard Home 的首页。我们需要使用 IP + 映射 80 的端口来定位到首页。</p>



 </div> </div>
<p><img src="https://i.lisz.top/blog/Wwb5At.webp" alt="登录页面 AdGuard Home Login" /></p>

<h4 id="私有域名转发">私有域名转发</h4>

<p>  由于接下来我们将要用 PowerDNS 来管理权威域名解析，所以需要设置私有域名规则，即当 AdGuard Home 收到关于内网自定义权威域名的请求时，就会把请求转给 PowerDNS。这在 AdGuard Home 中也是比较容易就能设置好的，如下图所示，添加一行规则使得匹配的所有二级域名请求转发给 PowerDNS。</p>

<p><img src="https://i.lisz.top/blog/4GMZAO.webp" alt="配置转发 Redirect to Authroized DNS" /></p>

<h3 id="powerdns">PowerDNS</h3>

<p>  虽然 PowerDNS 和 PowerDNS-Admin 官方都提供了 Docker 镜像，但是搭配起来用还是有点莫名其妙的问题。为了更加简单，笔者参考官方自行构建了 <code class="language-plaintext highlighter-rouge">zhonger/pdns</code> 和 <code class="language-plaintext highlighter-rouge">zhonger/powerdns-admin</code> 两个 Docker 镜像，搭配使用更加便捷可用。如果想要了解更多，可以查看 <a href="../docker/powerdns.html">《Docker 镜像构建之 PowerDNS 篇》</a>。
  </p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3"</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">pdns</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">zhonger/pdns:latest</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">753:53/tcp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">753:53/udp"</span>
      <span class="c1"># - "8081:8081"</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">PDNS_launch=gsqlite3</span>
      <span class="pi">-</span> <span class="s">PDNS_gsqlite3_database=/var/lib/powerdns/pdns.sqlite3</span>
      <span class="pi">-</span> <span class="s">PDNS_webserver_address=0.0.0.0</span>
      <span class="pi">-</span> <span class="s">PDNS_webserver_allow_from=127.0.0.1,10.0.0.0/8,172.0.0.0/8,192.168.0.0/16</span>
      <span class="pi">-</span> <span class="s">PDNS_api=yes</span>
      <span class="pi">-</span> <span class="s">PDNS_api_key={Random Long String}</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">/etc/localtime:/etc/localtime:ro</span>
      <span class="pi">-</span> <span class="s">./powerdns:/var/lib/powerdns</span>
  <span class="na">db</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">mysql:latest</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">MYSQL_ALLOW_EMPTY_PASSWORD=yes</span>
      <span class="pi">-</span> <span class="s">MYSQL_DATABASE=powerdnsadmin</span>
      <span class="pi">-</span> <span class="s">MYSQL_USER=pdns</span> 
      <span class="pi">-</span> <span class="s">MYSQL_PASSWORD=mypdns</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">/etc/localtime:/etc/localtime:ro</span>
      <span class="pi">-</span> <span class="s">./pda-mysql:/var/lib/mysql</span>

  <span class="na">app</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">zhonger/powerdns-admin:latest</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">db</span>
      <span class="pi">-</span> <span class="s">pdns</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">8080:80"</span>
    <span class="na">logging</span><span class="pi">:</span>
      <span class="na">driver</span><span class="pi">:</span> <span class="s">json-file</span>
      <span class="na">options</span><span class="pi">:</span>
        <span class="na">max-size</span><span class="pi">:</span> <span class="s">50m</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">/etc/localtime:/etc/localtime:ro</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">SQLALCHEMY_DATABASE_URI=mysql://pdns:mypdns@db/powerdnsadmin</span>
      <span class="pi">-</span> <span class="s">GUNICORN_TIMEOUT=60</span>
      <span class="pi">-</span> <span class="s">GUNICORN_WORKERS=2</span>
      <span class="pi">-</span> <span class="s">GUNICORN_LOGLEVEL=DEBUG</span>
      <span class="pi">-</span> <span class="s">OFFLINE_MODE=False</span> <span class="c1"># True for offline, False for external resources </span>
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 命令启动 PowerDNS 和 PowerDNS-Admin 实例。</p>

<h4 id="初始化用户">初始化用户</h4>

<p>  PowerDNS-Admin 本身不会自动初始化管理员用户，而是将注册的第一个用户认定为管理员用户。使用浏览器访问 PowerDNS-Admin 登录页面 <a href="http://localhost:8080">http://localhost:8080</a>，如下图所示点击 Create an account 链接跳转到注册页。</p>

<p><img src="https://i.lisz.top/blog/9NDNpc.webp" alt="PowerDNS-Admin 登录页 Login page" /></p>

<p>  如下图所示，填写姓名、邮箱、用户名和密码，点击 Register 按钮即可完成注册。这里，PowerDNS-Admin 默认采用邮箱的 Gavatar 头像作为用户头像。</p>

<p><img src="https://i.lisz.top/blog/TJqhDE.webp" alt="PowerDNS-Admin 注册页 Register page" /></p>

<h4 id="初始化配置">初始化配置</h4>

<p>  注册和登录后，会跳转到 PDNS 配置页面。这里由于 PDNS 和 PowerDNS-Admin 实例是在同一个网络中，可以直接使用 pdns 来代替 PDNS 实例的 IP 地址。PDNS API KEY 则是刚才启动时设置的那一长串字符（PDNS_api_key）。PDNS VERSION 最好是与 PDNS 实际使用的一致，不过不一致也不会有什么事。<code class="language-plaintext highlighter-rouge">zhonger/pdns:latest</code> 目前实际是 4.6 版本，这里默认填的 4.1.1 也可以。然后点击 Update 按钮保存配置。</p>

<p><img src="https://i.lisz.top/blog/CJ1Wl1.webp" alt="CJ1Wl1" /></p>

<p>  保存配置成功后，如果填写信息无误，点击侧边导航中的 PDNS 就可以看到 PDNS 的各项配置信息。如果填写有误，则没有任何信息。</p>

<p><img src="https://i.lisz.top/blog/UdkXGi.webp" alt="UdkXGi" /></p>

<h4 id="新增域名">新增域名</h4>

<p>  接下来就可以点击侧边导航栏中的 New Domain 来新增私有域名 home.lisz。如下图所示，我们需要填写的是域名，需要选择的是域名模板，一般 basic_template_1 即可。之后点击 Submit 按钮提交。</p>

<p><img src="https://i.lisz.top/blog/nMyRKR.webp" alt="nMyRKR" /></p>

<h4 id="新增解析记录">新增解析记录</h4>

<p>  新增域名成功后，我们就可以在 Dashboard 里面的域名列表看到 home.lisz 了。点击即可进入域名解析。</p>

<p><img src="https://i.lisz.top/blog/naFe9s.webp" alt="naFe9s" /></p>

<p>  这里我们以一个 CNAME 和 A 记录为例，来尝试新增解析记录。如下图所示，点击左上角的 Add Record 添加记录，完成后点击右上角的 Apply Changes 来提交解析记录到 PDNS。</p>

<p><img src="https://i.lisz.top/blog/SmwtCT.webp" alt="SmwtCT" /></p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 小知识 </div> </div> <div class="content"> <p>  实际域名解析时我们一般会采用 CNAME 和 A 记录联合使用的方式，这样相当于在 DNS 解析层面就有负载均衡了。A 记录是域名与 IP 的关系，这就意味着同一个域名可以有多个 A 记录。CNAME 记录是域名与域名的关系，而两个域名分别是为了不同的目的，前一个是为了给大家使用的，后一个是为了运维人员使用的。当存在 CNAME → A 时，客户端会根据网络情况来判断使用哪一条 A 记录对应的 IP，从而提升用户体验。</p>



 </div> </div>
<h3 id="验证">验证</h3>

<h4 id="验证权威-dns-是否正常">验证权威 DNS 是否正常</h4>

<p>  如下所示向 AdGuard Home 询问私有域名解析记录，解析正常。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>─<span class="nv">$ </span>dig @127.0.0.1 <span class="nt">-p</span> 53 www.home.lisz

<span class="p">;</span> &lt;&lt;<span class="o">&gt;&gt;</span> DiG 9.18.1-1ubuntu1.1-Ubuntu &lt;&lt;<span class="o">&gt;&gt;</span> @127.0.0.1 <span class="nt">-p</span> 53 www.home.lisz
<span class="p">;</span> <span class="o">(</span>1 server found<span class="o">)</span>
<span class="p">;;</span> global options: +cmd
<span class="p">;;</span> Got answer:
<span class="p">;;</span> -&gt;&gt;HEADER<span class="o">&lt;&lt;-</span> <span class="no">opcode</span><span class="sh">: QUERY, status: NOERROR, id: 47193
;; flags: qr aa rd; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1
;; WARNING: recursion requested but not available

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1232
;; QUESTION SECTION:
;www.home.lisz.                 IN      A

;; ANSWER SECTION:
www.home.lisz.          60      IN      CNAME   www101.home.lisz.
www101.home.lisz.       60      IN      A       192.168.1.1

;; Query time: 20 msec
;; SERVER: 127.0.0.1#53(127.0.0.1) (UDP)
;; WHEN: Tue Aug 23 17:05:15 JST 2022
;; MSG SIZE  rcvd: 79
</span></code></pre></div></div>

<h4 id="验证递归-dns-是否正常">验证递归 DNS 是否正常</h4>

<p>  如下所示，向 AdGuard Home 询问公有域名解析记录，解析正常。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-<span class="nv">$ </span>dig @127.0.0.1 <span class="nt">-p</span> 53 www.baidu.com

<span class="p">;</span> &lt;&lt;<span class="o">&gt;&gt;</span> DiG 9.18.1-1ubuntu1.1-Ubuntu &lt;&lt;<span class="o">&gt;&gt;</span> @127.0.0.1 <span class="nt">-p</span> 53 www.baidu.com
<span class="p">;</span> <span class="o">(</span>1 server found<span class="o">)</span>
<span class="p">;;</span> global options: +cmd
<span class="p">;;</span> Got answer:
<span class="p">;;</span> -&gt;&gt;HEADER<span class="o">&lt;&lt;-</span> <span class="no">opcode</span><span class="sh">: QUERY, status: NOERROR, id: 8988
;; flags: qr rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1232
;; QUESTION SECTION:
;www.baidu.com.                 IN      A

;; ANSWER SECTION:
www.baidu.com.          831     IN      CNAME   www.a.shifen.com.
www.a.shifen.com.       28      IN      CNAME   www.wshifen.com.
www.wshifen.com.        192     IN      A       45.113.192.102
www.wshifen.com.        192     IN      A       45.113.192.101

;; Query time: 244 msec
;; SERVER: 127.0.0.1#53(127.0.0.1) (UDP)
;; WHEN: Tue Aug 23 17:06:03 JST 2022
;; MSG SIZE  rcvd: 127
</span></code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://help.aliyun.com/document_detail/64623.html">阿里云帮助中心 - 云解析 - 应用场景</a></li>
  <li><a href="https://cloud.tencent.com/document/product/1338/50547">腾讯云文档中心 - 子域名递归解析说明</a></li>
  <li><a href="https://support.huaweicloud.com/dns_faq/dns_faq_040.html">华为云文档 - 如何设置内网域名既支持内网解析，也支持公网解析？</a></li>
  <li><a href="https://cloud.tencent.com/developer/article/1123748">公司内网搭建代理 DNS 使用内网域名代替 ip 地址</a></li>
  <li><a href="https://cloud.tencent.com/developer/article/1821030">一文搞懂 DNS 基础知识，收藏起来有备无患~</a></li>
  <li><a href="https://cloud.tencent.com/developer/article/1691018">搞它！！！深入了解DNS域名解析服务，教你搭建一个属于自己的DNS服务器（正向解析、反向解析、泛域名解析、邮件交换解析、别名解析、分离解析，主从结构解析）</a></li>
  <li><a href="https://www.modb.pro/db/433331">推荐一款 Private DNS 服务</a></li>
  <li><a href="https://sspai.com/post/63088">AdGuard Home 安装及使用指北</a></li>
  <li><a href="http://www.gjbmj.gov.cn/n1/2021/0722/c411145-32166624.html">内网域名系统的安全保密风险研究</a></li>
  <li><a href="https://computingforgeeks.com/running-powerdns-and-powerdns-admin-in-docker-containers/">Running PowerDNS and PowerDNS Admin in Docker Containers</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="域名解析" /><category term="DNS" /><category term="私有域名" /><category term="内网" /><summary type="html"><![CDATA[前言]]></summary></entry></feed>